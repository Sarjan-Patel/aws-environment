"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/drift-tick/route";
exports.ids = ["app/api/drift-tick/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdrift-tick%2Froute&page=%2Fapi%2Fdrift-tick%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdrift-tick%2Froute.ts&appDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdrift-tick%2Froute&page=%2Fapi%2Fdrift-tick%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdrift-tick%2Froute.ts&appDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_sarjanpatel_Github_Repositories_aws_environment_agentic_ai_platform_app_api_drift_tick_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/drift-tick/route.ts */ \"(rsc)/./app/api/drift-tick/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/drift-tick/route\",\n        pathname: \"/api/drift-tick\",\n        filename: \"route\",\n        bundlePath: \"app/api/drift-tick/route\"\n    },\n    resolvedPagePath: \"/Users/sarjanpatel/Github Repositories/aws-environment/agentic-ai-platform/app/api/drift-tick/route.ts\",\n    nextConfigOutput,\n    userland: _Users_sarjanpatel_Github_Repositories_aws_environment_agentic_ai_platform_app_api_drift_tick_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/drift-tick/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZkcmlmdC10aWNrJTJGcm91dGUmcGFnZT0lMkZhcGklMkZkcmlmdC10aWNrJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZHJpZnQtdGljayUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRnNhcmphbnBhdGVsJTJGR2l0aHViJTIwUmVwb3NpdG9yaWVzJTJGYXdzLWVudmlyb25tZW50JTJGYWdlbnRpYy1haS1wbGF0Zm9ybSUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZzYXJqYW5wYXRlbCUyRkdpdGh1YiUyMFJlcG9zaXRvcmllcyUyRmF3cy1lbnZpcm9ubWVudCUyRmFnZW50aWMtYWktcGxhdGZvcm0maXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ3NEO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdlbnRpYy1haS1wbGF0Zm9ybS8/Yzg5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvc2FyamFucGF0ZWwvR2l0aHViIFJlcG9zaXRvcmllcy9hd3MtZW52aXJvbm1lbnQvYWdlbnRpYy1haS1wbGF0Zm9ybS9hcHAvYXBpL2RyaWZ0LXRpY2svcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2RyaWZ0LXRpY2svcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9kcmlmdC10aWNrXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9kcmlmdC10aWNrL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL3NhcmphbnBhdGVsL0dpdGh1YiBSZXBvc2l0b3JpZXMvYXdzLWVudmlyb25tZW50L2FnZW50aWMtYWktcGxhdGZvcm0vYXBwL2FwaS9kcmlmdC10aWNrL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9kcmlmdC10aWNrL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdrift-tick%2Froute&page=%2Fapi%2Fdrift-tick%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdrift-tick%2Froute.ts&appDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/drift-tick/route.ts":
/*!*************************************!*\
  !*** ./app/api/drift-tick/route.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var _lib_agent_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/agent/detector */ \"(rsc)/./lib/agent/detector.ts\");\n/* harmony import */ var _lib_agent_executor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/agent/executor */ \"(rsc)/./lib/agent/executor.ts\");\n/* harmony import */ var _lib_agent_scenarios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/agent/scenarios */ \"(rsc)/./lib/agent/scenarios.ts\");\n\n\n\n\n\n// Server-side debug logger with timestamps\nconst debug = (message, data)=>{\n    const timestamp = new Date().toISOString();\n    if (data !== undefined) {\n        console.log(`[${timestamp}] [API /drift-tick] ${message}`, data);\n    } else {\n        console.log(`[${timestamp}] [API /drift-tick] ${message}`);\n    }\n};\n/**\n * Seed wasteful data to ensure detection always has resources to find\n * This runs before detection to guarantee test data exists\n */ async function seedWastefulData(supabase) {\n    const counts = {\n        rds: 0,\n        cache: 0,\n        s3: 0,\n        snapshots: 0,\n        asg: 0,\n        loadBalancers: 0\n    };\n    try {\n        // 1. Seed idle RDS instances (CPU < 15%, connections <= 1)\n        const { data: rdsInstances } = await supabase.from(\"rds_instances\").select(\"id, db_instance_id\").eq(\"state\", \"available\").limit(3);\n        if (rdsInstances && rdsInstances.length > 0) {\n            for (const instance of rdsInstances.slice(0, 2)){\n                const { error } = await supabase.from(\"rds_instances\").update({\n                    avg_cpu_7d: Math.random() * 10 + 2,\n                    avg_connections_7d: Math.random() < 0.5 ? 0 : 1\n                }).eq(\"id\", instance.id);\n                if (!error) counts.rds++;\n            }\n        }\n        // 2. Seed idle ElastiCache clusters (CPU < 15%, connections <= 3)\n        const { data: cacheClusters } = await supabase.from(\"cache_clusters\").select(\"id, cluster_id\").limit(3);\n        if (cacheClusters && cacheClusters.length > 0) {\n            for (const cluster of cacheClusters.slice(0, 2)){\n                const { error } = await supabase.from(\"cache_clusters\").update({\n                    avg_cpu_7d: Math.random() * 10 + 2,\n                    avg_connections_7d: Math.floor(Math.random() * 3)\n                }).eq(\"id\", cluster.id);\n                if (!error) counts.cache++;\n            }\n        }\n        // 3. Seed S3 buckets without lifecycle policies\n        const { data: s3Buckets } = await supabase.from(\"s3_buckets\").select(\"id\").limit(3);\n        if (s3Buckets && s3Buckets.length > 0) {\n            for (const bucket of s3Buckets.slice(0, 2)){\n                const { error } = await supabase.from(\"s3_buckets\").update({\n                    lifecycle_rules: null\n                }).eq(\"id\", bucket.id);\n                if (!error) counts.s3++;\n            }\n        }\n        // 4. Seed old snapshots (> 90 days)\n        const { data: snapshots } = await supabase.from(\"snapshots\").select(\"id\").limit(3);\n        if (snapshots && snapshots.length > 0) {\n            for (const snapshot of snapshots.slice(0, 2)){\n                const daysOld = 95 + Math.floor(Math.random() * 60) // 95-155 days\n                ;\n                const oldDate = new Date();\n                oldDate.setDate(oldDate.getDate() - daysOld);\n                const { error } = await supabase.from(\"snapshots\").update({\n                    created_at: oldDate.toISOString()\n                }).eq(\"id\", snapshot.id);\n                if (!error) counts.snapshots++;\n            }\n        }\n        // 5. Seed wasteful ASGs (feature/preview environments with low utilization)\n        const { data: asgs } = await supabase.from(\"autoscaling_groups\").select(\"id, name\").limit(3);\n        if (asgs && asgs.length > 0) {\n            const envs = [\n                \"feature-branch\",\n                \"preview\",\n                \"dev-test\"\n            ];\n            const staleDate = new Date();\n            staleDate.setDate(staleDate.getDate() - 14) // 14 days old\n            ;\n            for(let i = 0; i < Math.min(2, asgs.length); i++){\n                const { error } = await supabase.from(\"autoscaling_groups\").update({\n                    env: envs[i % envs.length],\n                    current_utilization: Math.random() * 15 + 3,\n                    desired_capacity: 2 + Math.floor(Math.random() * 2),\n                    min_size: 1,\n                    created_at: staleDate.toISOString()\n                }).eq(\"id\", asgs[i].id);\n                if (!error) counts.asg++;\n            }\n        }\n        // 6. Seed idle load balancers (low request count)\n        const { data: lbs } = await supabase.from(\"load_balancers\").select(\"id, name\").limit(3);\n        if (lbs && lbs.length > 0) {\n            for (const lb of lbs.slice(0, 2)){\n                const { error } = await supabase.from(\"load_balancers\").update({\n                    avg_request_count_7d: Math.floor(Math.random() * 100)\n                }).eq(\"id\", lb.id);\n                if (!error) counts.loadBalancers++;\n            }\n        }\n    } catch (error) {\n        debug(\"Error seeding wasteful data:\", error);\n    }\n    return counts;\n}\n/**\n * POST /api/drift-tick\n *\n * Main drift detection and auto-execution endpoint.\n * This is the \"heartbeat\" of the optimization agent:\n * 1. Runs waste detection across all resources\n * 2. Checks if automated mode is enabled\n * 3. If automated, executes all auto-safe actions automatically\n *\n * This endpoint can be called:\n * - Manually via the UI refresh button\n * - On a schedule (cron job)\n * - Via webhook from external systems\n *\n * Body params:\n * - autoExecute: (optional) Override the execution mode (true = auto-execute, false = detect only)\n */ async function POST(request) {\n    const requestStartTime = performance.now();\n    debug(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\");\n    debug(\"‚ïë                    DRIFT TICK STARTED                        ‚ïë\");\n    debug(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\");\n    try {\n        // Parse request body\n        const body = await request.json().catch(()=>({}));\n        debug(\"Request body:\", body);\n        // Get Supabase credentials from environment\n        const supabaseUrl = \"https://vqcvrwkdvxzgucqcfcoq.supabase.co\";\n        const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxY3Zyd2tkdnh6Z3VjcWNmY29xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg1MzkwMTYsImV4cCI6MjA4NDExNTAxNn0.yID9xy9fbd8UiYjdlq4LSZwuUUUKqQ1G_J03t3Vio4I\";\n        if (!supabaseUrl || !supabaseKey) {\n            debug(\"‚ùå ERROR: No database credentials found\");\n            debug(\"  NEXT_PUBLIC_SUPABASE_URL:\", supabaseUrl ? \"SET\" : \"NOT SET\");\n            debug(\"  SUPABASE_SERVICE_ROLE_KEY:\", process.env.SUPABASE_SERVICE_ROLE_KEY ? \"SET\" : \"NOT SET\");\n            debug(\"  NEXT_PUBLIC_SUPABASE_ANON_KEY:\",  true ? \"SET\" : 0);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Not connected to database. Please configure connection.\"\n            }, {\n                status: 401\n            });\n        }\n        debug(\"Database credentials: OK\");\n        // Create Supabase client for seeding\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_4__.createClient)(supabaseUrl, supabaseKey);\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // STEP 0: Seed wasteful data (ensures detections always exist)\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        debug(\"‚îÄ‚îÄ‚îÄ STEP 0: SEEDING WASTEFUL DATA ‚îÄ‚îÄ‚îÄ\");\n        const seedStartTime = performance.now();\n        const seedCounts = await seedWastefulData(supabase);\n        const seedDuration = performance.now() - seedStartTime;\n        debug(`Seeding completed in ${seedDuration.toFixed(0)}ms`);\n        debug(`Seeded: RDS=${seedCounts.rds}, Cache=${seedCounts.cache}, S3=${seedCounts.s3}, Snapshots=${seedCounts.snapshots}, ASG=${seedCounts.asg}, LB=${seedCounts.loadBalancers}`);\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // STEP 1: Run waste detection\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        debug(\"‚îÄ‚îÄ‚îÄ STEP 1: WASTE DETECTION ‚îÄ‚îÄ‚îÄ\");\n        const detectionStartTime = performance.now();\n        const detector = (0,_lib_agent_detector__WEBPACK_IMPORTED_MODULE_1__.createDetector)(supabaseUrl, supabaseKey);\n        const result = await detector.detectAll();\n        const detectionDuration = performance.now() - detectionStartTime;\n        debug(`Detection completed in ${detectionDuration.toFixed(0)}ms`);\n        debug(`Total detections: ${result.detections.length}`);\n        debug(`Total potential savings: $${result.summary.totalPotentialSavings.toFixed(2)}/mo`);\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // STEP 2: Check execution mode setting\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        debug(\"‚îÄ‚îÄ‚îÄ STEP 2: EXECUTION MODE CHECK ‚îÄ‚îÄ‚îÄ\");\n        // Check if auto-execute is explicitly set in body, otherwise check settings\n        let shouldAutoExecute = body.autoExecute;\n        let modeSource = \"request body\";\n        if (typeof shouldAutoExecute !== \"boolean\") {\n            debug(\"autoExecute not in request body, checking database settings...\");\n            const { data: settings, error: settingsError } = await supabase.from(\"settings\").select(\"value\").eq(\"key\", \"execution_settings\").single();\n            if (settingsError) {\n                debug(\"Settings query error:\", settingsError.message);\n                debug(\"Error code:\", settingsError.code);\n                if (settingsError.code === \"PGRST116\") {\n                    debug(\"Settings row not found - defaulting to manual mode\");\n                } else if (settingsError.code === \"42P01\") {\n                    debug(\"Settings table does not exist - defaulting to manual mode\");\n                }\n                shouldAutoExecute = false;\n                modeSource = \"default (settings not found)\";\n            } else {\n                debug(\"Settings from database:\", settings?.value);\n                shouldAutoExecute = settings?.value?.mode === \"automated\";\n                modeSource = \"database settings\";\n            }\n        } else {\n            debug(`autoExecute explicitly set in request body: ${shouldAutoExecute}`);\n        }\n        debug(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);\n        debug(`EXECUTION MODE: ${shouldAutoExecute ? \"\\uD83D\\uDFE2 AUTOMATED\" : \"\\uD83D\\uDD34 MANUAL\"}`);\n        debug(`Mode source: ${modeSource}`);\n        debug(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // STEP 3: Filter for auto-safe detections\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        debug(\"‚îÄ‚îÄ‚îÄ STEP 3: FILTER AUTO-SAFE DETECTIONS ‚îÄ‚îÄ‚îÄ\");\n        const autoSafeIds = _lib_agent_scenarios__WEBPACK_IMPORTED_MODULE_3__.AUTO_SAFE_SCENARIOS.map((s)=>s.id);\n        debug(\"Auto-safe scenario IDs:\", autoSafeIds);\n        const autoSafeDetections = result.detections.filter((d)=>autoSafeIds.includes(d.scenarioId));\n        debug(`Auto-safe detections: ${autoSafeDetections.length} of ${result.detections.length} total`);\n        if (autoSafeDetections.length > 0) {\n            debug(\"Auto-safe detection details:\");\n            autoSafeDetections.forEach((d, i)=>{\n                debug(`  ${i + 1}. ${d.resourceName} (${d.scenarioId}) - $${d.potentialSavings.toFixed(2)}/mo`);\n            });\n        }\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // STEP 4: Execute actions if automated mode\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        debug(\"‚îÄ‚îÄ‚îÄ STEP 4: EXECUTION ‚îÄ‚îÄ‚îÄ\");\n        let executionResults = [];\n        if (!shouldAutoExecute) {\n            debug(\"‚è∏Ô∏è  SKIPPING EXECUTION - Mode is MANUAL\");\n            debug(\"   To auto-execute, either:\");\n            debug(\"   1. Toggle to 'Automated' mode in the UI\");\n            debug(\"   2. Pass { autoExecute: true } in the request body\");\n        } else if (autoSafeDetections.length === 0) {\n            debug(\"‚è∏Ô∏è  SKIPPING EXECUTION - No auto-safe detections found\");\n        } else {\n            debug(`üöÄ EXECUTING ${autoSafeDetections.length} AUTO-SAFE ACTIONS...`);\n            const executor = (0,_lib_agent_executor__WEBPACK_IMPORTED_MODULE_2__.createExecutor)(supabaseUrl, supabaseKey);\n            for(let i = 0; i < autoSafeDetections.length; i++){\n                const detection = autoSafeDetections[i];\n                const actionStartTime = performance.now();\n                const scenario = _lib_agent_scenarios__WEBPACK_IMPORTED_MODULE_3__.WASTE_SCENARIOS[detection.scenarioId];\n                debug(`‚îÄ‚îÄ‚îÄ Action ${i + 1}/${autoSafeDetections.length} ‚îÄ‚îÄ‚îÄ`);\n                debug(`Resource: ${detection.resourceName}`);\n                debug(`Resource ID: ${detection.resourceId}`);\n                debug(`Scenario: ${detection.scenarioId}`);\n                if (!scenario) {\n                    debug(`‚ö†Ô∏è  Unknown scenario: ${detection.scenarioId} - SKIPPING`);\n                    continue;\n                }\n                debug(`Action: ${scenario.action}`);\n                try {\n                    const params = {\n                        action: scenario.action,\n                        resourceType: scenario.resourceType,\n                        resourceId: detection.resourceId,\n                        resourceName: detection.resourceName,\n                        detectionId: detection.id,\n                        scenarioId: detection.scenarioId,\n                        details: detection.details\n                    };\n                    debug(\"Executing with params:\", params);\n                    const execResult = await executor.executeAction(params);\n                    const actionDuration = performance.now() - actionStartTime;\n                    executionResults.push({\n                        resourceId: detection.resourceId,\n                        resourceName: detection.resourceName,\n                        action: scenario.action,\n                        success: execResult.success,\n                        message: execResult.message,\n                        durationMs: Math.round(actionDuration)\n                    });\n                    if (execResult.success) {\n                        debug(`‚úÖ SUCCESS: ${execResult.message} (${actionDuration.toFixed(0)}ms)`);\n                    } else {\n                        debug(`‚ùå FAILED: ${execResult.message} (${actionDuration.toFixed(0)}ms)`);\n                    }\n                } catch (error) {\n                    const actionDuration = performance.now() - actionStartTime;\n                    const message = error instanceof Error ? error.message : \"Unknown error\";\n                    executionResults.push({\n                        resourceId: detection.resourceId,\n                        resourceName: detection.resourceName,\n                        action: scenario.action,\n                        success: false,\n                        message,\n                        durationMs: Math.round(actionDuration)\n                    });\n                    debug(`‚ùå EXCEPTION: ${message} (${actionDuration.toFixed(0)}ms)`);\n                    console.error(\"Full error:\", error);\n                }\n            }\n        }\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        // SUMMARY\n        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n        const totalDuration = performance.now() - requestStartTime;\n        const successCount = executionResults.filter((r)=>r.success).length;\n        const failCount = executionResults.filter((r)=>!r.success).length;\n        debug(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\");\n        debug(\"‚ïë                    DRIFT TICK COMPLETE                       ‚ïë\");\n        debug(\"‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\");\n        debug(`‚ïë  Total Duration: ${totalDuration.toFixed(0)}ms`);\n        debug(`‚ïë  Seeding Duration: ${seedDuration.toFixed(0)}ms`);\n        debug(`‚ïë  Detection Duration: ${detectionDuration.toFixed(0)}ms`);\n        debug(`‚ïë  `);\n        debug(`‚ïë  üå± SEEDING:`);\n        debug(`‚ïë     RDS: ${seedCounts.rds}, Cache: ${seedCounts.cache}, S3: ${seedCounts.s3}`);\n        debug(`‚ïë     Snapshots: ${seedCounts.snapshots}, ASG: ${seedCounts.asg}, LB: ${seedCounts.loadBalancers}`);\n        debug(`‚ïë  `);\n        debug(`‚ïë  üìä DETECTIONS:`);\n        debug(`‚ïë     Total: ${result.detections.length}`);\n        debug(`‚ïë     Auto-Safe: ${autoSafeDetections.length}`);\n        debug(`‚ïë     Total Savings: $${result.summary.totalPotentialSavings.toFixed(2)}/mo`);\n        debug(`‚ïë  `);\n        debug(`‚ïë  ‚ö° EXECUTION:`);\n        debug(`‚ïë     Mode: ${shouldAutoExecute ? \"AUTOMATED\" : \"MANUAL\"}`);\n        debug(`‚ïë     Executed: ${executionResults.length}`);\n        debug(`‚ïë     Success: ${successCount}`);\n        debug(`‚ïë     Failed: ${failCount}`);\n        debug(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\");\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: {\n                seeding: {\n                    rds: seedCounts.rds,\n                    cache: seedCounts.cache,\n                    s3: seedCounts.s3,\n                    snapshots: seedCounts.snapshots,\n                    asg: seedCounts.asg,\n                    loadBalancers: seedCounts.loadBalancers\n                },\n                detection: {\n                    totalDetections: result.detections.length,\n                    autoSafeDetections: autoSafeDetections.length,\n                    totalSavings: result.summary.totalPotentialSavings,\n                    autoSafeSavings: autoSafeDetections.reduce((sum, d)=>sum + d.potentialSavings, 0),\n                    byScenario: result.summary.byScenario\n                },\n                execution: {\n                    mode: shouldAutoExecute ? \"automated\" : \"manual\",\n                    executed: executionResults.length,\n                    success: successCount,\n                    failed: failCount,\n                    results: executionResults\n                },\n                timing: {\n                    seedingMs: Math.round(seedDuration),\n                    detectionMs: Math.round(detectionDuration),\n                    totalMs: Math.round(totalDuration)\n                }\n            }\n        });\n    } catch (error) {\n        const totalDuration = performance.now() - requestStartTime;\n        debug(`‚ùå FATAL ERROR after ${totalDuration.toFixed(0)}ms:`);\n        console.error(error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error instanceof Error ? error.message : \"Drift tick failed\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * GET /api/drift-tick\n *\n * Get the status of the drift-tick system.\n */ async function GET() {\n    debug(\"GET /api/drift-tick - Status check\");\n    try {\n        const supabaseUrl = \"https://vqcvrwkdvxzgucqcfcoq.supabase.co\";\n        const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZxY3Zyd2tkdnh6Z3VjcWNmY29xIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg1MzkwMTYsImV4cCI6MjA4NDExNTAxNn0.yID9xy9fbd8UiYjdlq4LSZwuUUUKqQ1G_J03t3Vio4I\";\n        if (!supabaseUrl || !supabaseKey) {\n            debug(\"No database credentials\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                data: {\n                    connected: false,\n                    mode: \"unknown\",\n                    message: \"Database not configured\"\n                }\n            });\n        }\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_4__.createClient)(supabaseUrl, supabaseKey);\n        const { data: settings, error } = await supabase.from(\"settings\").select(\"value\").eq(\"key\", \"execution_settings\").single();\n        if (error) {\n            debug(\"Settings query error:\", error.message);\n        }\n        const mode = settings?.value?.mode || \"manual\";\n        debug(`Current mode: ${mode}`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: {\n                connected: true,\n                mode,\n                lastUpdated: settings?.value?.updated_at || null,\n                autoSafeScenarios: _lib_agent_scenarios__WEBPACK_IMPORTED_MODULE_3__.AUTO_SAFE_SCENARIOS.length\n            }\n        });\n    } catch (error) {\n        debug(\"GET error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error instanceof Error ? error.message : \"Failed to get status\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNoQ3BFLE1BQU07WUFDTixPQUFPTixxREFBWUEsQ0FBQ3FFLElBQUksQ0FBQztnQkFDdkJRLFNBQVM7Z0JBQ1RyRSxNQUFNO29CQUNKNkksV0FBVztvQkFDWGxELE1BQU07b0JBQ041RixTQUFTO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLE1BQU1TLFdBQVdmLG1FQUFZQSxDQUFDc0UsYUFBYUc7UUFDM0MsTUFBTSxFQUFFbEUsTUFBTXNGLFFBQVEsRUFBRTlELEtBQUssRUFBRSxHQUFHLE1BQU1oQixTQUNyQ1MsSUFBSSxDQUFDLFlBQ0xDLE1BQU0sQ0FBQyxTQUNQQyxFQUFFLENBQUMsT0FBTyxzQkFDVnFFLE1BQU07UUFFVCxJQUFJaEUsT0FBTztZQUNUMUIsTUFBTSx5QkFBeUIwQixNQUFNekIsT0FBTztRQUM5QztRQUVBLE1BQU00RixPQUFPTCxVQUFVSSxPQUFPQyxRQUFRO1FBQ3RDN0YsTUFBTSxDQUFDLGNBQWMsRUFBRTZGLEtBQUssQ0FBQztRQUU3QixPQUFPbkcscURBQVlBLENBQUNxRSxJQUFJLENBQUM7WUFDdkJRLFNBQVM7WUFDVHJFLE1BQU07Z0JBQ0o2SSxXQUFXO2dCQUNYbEQ7Z0JBQ0FtRCxhQUFheEQsVUFBVUksT0FBT3FELGNBQWM7Z0JBQzVDQyxtQkFBbUJuSixxRUFBbUJBLENBQUN3QixNQUFNO1lBQy9DO1FBQ0Y7SUFDRixFQUFFLE9BQU9HLE9BQU87UUFDZDFCLE1BQU0sY0FBYzBCO1FBQ3BCLE9BQU9oQyxxREFBWUEsQ0FBQ3FFLElBQUksQ0FDdEI7WUFDRVEsU0FBUztZQUNUN0MsT0FBT0EsaUJBQWlCZ0csUUFBUWhHLE1BQU16QixPQUFPLEdBQUc7UUFDbEQsR0FDQTtZQUFFdUUsUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGljLWFpLXBsYXRmb3JtLy4vYXBwL2FwaS9kcmlmdC10aWNrL3JvdXRlLnRzPzM1ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L3NlcnZlclwiXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQsIFN1cGFiYXNlQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiXG5pbXBvcnQgeyBjcmVhdGVEZXRlY3RvciwgRGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSBcIkAvbGliL2FnZW50L2RldGVjdG9yXCJcbmltcG9ydCB7IGNyZWF0ZUV4ZWN1dG9yLCBFeGVjdXRlQWN0aW9uUGFyYW1zIH0gZnJvbSBcIkAvbGliL2FnZW50L2V4ZWN1dG9yXCJcbmltcG9ydCB7IFdBU1RFX1NDRU5BUklPUywgQVVUT19TQUZFX1NDRU5BUklPUyB9IGZyb20gXCJAL2xpYi9hZ2VudC9zY2VuYXJpb3NcIlxuXG4vLyBTZXJ2ZXItc2lkZSBkZWJ1ZyBsb2dnZXIgd2l0aCB0aW1lc3RhbXBzXG5jb25zdCBkZWJ1ZyA9IChtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiB1bmtub3duKSA9PiB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS5sb2coYFske3RpbWVzdGFtcH1dIFtBUEkgL2RyaWZ0LXRpY2tdICR7bWVzc2FnZX1gLCBkYXRhKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGBbJHt0aW1lc3RhbXB9XSBbQVBJIC9kcmlmdC10aWNrXSAke21lc3NhZ2V9YClcbiAgfVxufVxuXG4vKipcbiAqIFNlZWQgd2FzdGVmdWwgZGF0YSB0byBlbnN1cmUgZGV0ZWN0aW9uIGFsd2F5cyBoYXMgcmVzb3VyY2VzIHRvIGZpbmRcbiAqIFRoaXMgcnVucyBiZWZvcmUgZGV0ZWN0aW9uIHRvIGd1YXJhbnRlZSB0ZXN0IGRhdGEgZXhpc3RzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlZWRXYXN0ZWZ1bERhdGEoc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50KTogUHJvbWlzZTx7XG4gIHJkczogbnVtYmVyXG4gIGNhY2hlOiBudW1iZXJcbiAgczM6IG51bWJlclxuICBzbmFwc2hvdHM6IG51bWJlclxuICBhc2c6IG51bWJlclxuICBsb2FkQmFsYW5jZXJzOiBudW1iZXJcbn0+IHtcbiAgY29uc3QgY291bnRzID0geyByZHM6IDAsIGNhY2hlOiAwLCBzMzogMCwgc25hcHNob3RzOiAwLCBhc2c6IDAsIGxvYWRCYWxhbmNlcnM6IDAgfVxuXG4gIHRyeSB7XG4gICAgLy8gMS4gU2VlZCBpZGxlIFJEUyBpbnN0YW5jZXMgKENQVSA8IDE1JSwgY29ubmVjdGlvbnMgPD0gMSlcbiAgICBjb25zdCB7IGRhdGE6IHJkc0luc3RhbmNlcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwicmRzX2luc3RhbmNlc1wiKVxuICAgICAgLnNlbGVjdChcImlkLCBkYl9pbnN0YW5jZV9pZFwiKVxuICAgICAgLmVxKFwic3RhdGVcIiwgXCJhdmFpbGFibGVcIilcbiAgICAgIC5saW1pdCgzKVxuXG4gICAgaWYgKHJkc0luc3RhbmNlcyAmJiByZHNJbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiByZHNJbnN0YW5jZXMuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcInJkc19pbnN0YW5jZXNcIilcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIGF2Z19jcHVfN2Q6IE1hdGgucmFuZG9tKCkgKiAxMCArIDIsIC8vIDItMTIlXG4gICAgICAgICAgICBhdmdfY29ubmVjdGlvbnNfN2Q6IE1hdGgucmFuZG9tKCkgPCAwLjUgPyAwIDogMSwgLy8gMCBvciAxXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBpbnN0YW5jZS5pZClcbiAgICAgICAgaWYgKCFlcnJvcikgY291bnRzLnJkcysrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi4gU2VlZCBpZGxlIEVsYXN0aUNhY2hlIGNsdXN0ZXJzIChDUFUgPCAxNSUsIGNvbm5lY3Rpb25zIDw9IDMpXG4gICAgY29uc3QgeyBkYXRhOiBjYWNoZUNsdXN0ZXJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJjYWNoZV9jbHVzdGVyc1wiKVxuICAgICAgLnNlbGVjdChcImlkLCBjbHVzdGVyX2lkXCIpXG4gICAgICAubGltaXQoMylcblxuICAgIGlmIChjYWNoZUNsdXN0ZXJzICYmIGNhY2hlQ2x1c3RlcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIGNhY2hlQ2x1c3RlcnMuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcImNhY2hlX2NsdXN0ZXJzXCIpXG4gICAgICAgICAgLnVwZGF0ZSh7XG4gICAgICAgICAgICBhdmdfY3B1XzdkOiBNYXRoLnJhbmRvbSgpICogMTAgKyAyLCAvLyAyLTEyJVxuICAgICAgICAgICAgYXZnX2Nvbm5lY3Rpb25zXzdkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKSwgLy8gMC0yXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBjbHVzdGVyLmlkKVxuICAgICAgICBpZiAoIWVycm9yKSBjb3VudHMuY2FjaGUrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFNlZWQgUzMgYnVja2V0cyB3aXRob3V0IGxpZmVjeWNsZSBwb2xpY2llc1xuICAgIGNvbnN0IHsgZGF0YTogczNCdWNrZXRzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJzM19idWNrZXRzXCIpXG4gICAgICAuc2VsZWN0KFwiaWRcIilcbiAgICAgIC5saW1pdCgzKVxuXG4gICAgaWYgKHMzQnVja2V0cyAmJiBzM0J1Y2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBidWNrZXQgb2YgczNCdWNrZXRzLnNsaWNlKDAsIDIpKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJzM19idWNrZXRzXCIpXG4gICAgICAgICAgLnVwZGF0ZSh7IGxpZmVjeWNsZV9ydWxlczogbnVsbCB9KVxuICAgICAgICAgIC5lcShcImlkXCIsIGJ1Y2tldC5pZClcbiAgICAgICAgaWYgKCFlcnJvcikgY291bnRzLnMzKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBTZWVkIG9sZCBzbmFwc2hvdHMgKD4gOTAgZGF5cylcbiAgICBjb25zdCB7IGRhdGE6IHNuYXBzaG90cyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwic25hcHNob3RzXCIpXG4gICAgICAuc2VsZWN0KFwiaWRcIilcbiAgICAgIC5saW1pdCgzKVxuXG4gICAgaWYgKHNuYXBzaG90cyAmJiBzbmFwc2hvdHMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBzbmFwc2hvdCBvZiBzbmFwc2hvdHMuc2xpY2UoMCwgMikpIHtcbiAgICAgICAgY29uc3QgZGF5c09sZCA9IDk1ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjApIC8vIDk1LTE1NSBkYXlzXG4gICAgICAgIGNvbnN0IG9sZERhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICAgIG9sZERhdGUuc2V0RGF0ZShvbGREYXRlLmdldERhdGUoKSAtIGRheXNPbGQpXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJzbmFwc2hvdHNcIilcbiAgICAgICAgICAudXBkYXRlKHsgY3JlYXRlZF9hdDogb2xkRGF0ZS50b0lTT1N0cmluZygpIH0pXG4gICAgICAgICAgLmVxKFwiaWRcIiwgc25hcHNob3QuaWQpXG4gICAgICAgIGlmICghZXJyb3IpIGNvdW50cy5zbmFwc2hvdHMrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFNlZWQgd2FzdGVmdWwgQVNHcyAoZmVhdHVyZS9wcmV2aWV3IGVudmlyb25tZW50cyB3aXRoIGxvdyB1dGlsaXphdGlvbilcbiAgICBjb25zdCB7IGRhdGE6IGFzZ3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgICAgLnNlbGVjdChcImlkLCBuYW1lXCIpXG4gICAgICAubGltaXQoMylcblxuICAgIGlmIChhc2dzICYmIGFzZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZW52cyA9IFtcImZlYXR1cmUtYnJhbmNoXCIsIFwicHJldmlld1wiLCBcImRldi10ZXN0XCJdXG4gICAgICBjb25zdCBzdGFsZURhdGUgPSBuZXcgRGF0ZSgpXG4gICAgICBzdGFsZURhdGUuc2V0RGF0ZShzdGFsZURhdGUuZ2V0RGF0ZSgpIC0gMTQpIC8vIDE0IGRheXMgb2xkXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oMiwgYXNncy5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgZW52OiBlbnZzW2kgJSBlbnZzLmxlbmd0aF0sXG4gICAgICAgICAgICBjdXJyZW50X3V0aWxpemF0aW9uOiBNYXRoLnJhbmRvbSgpICogMTUgKyAzLCAvLyAzLTE4JVxuICAgICAgICAgICAgZGVzaXJlZF9jYXBhY2l0eTogMiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpLCAvLyAyLTNcbiAgICAgICAgICAgIG1pbl9zaXplOiAxLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogc3RhbGVEYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBhc2dzW2ldLmlkKVxuICAgICAgICBpZiAoIWVycm9yKSBjb3VudHMuYXNnKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA2LiBTZWVkIGlkbGUgbG9hZCBiYWxhbmNlcnMgKGxvdyByZXF1ZXN0IGNvdW50KVxuICAgIGNvbnN0IHsgZGF0YTogbGJzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJsb2FkX2JhbGFuY2Vyc1wiKVxuICAgICAgLnNlbGVjdChcImlkLCBuYW1lXCIpXG4gICAgICAubGltaXQoMylcblxuICAgIGlmIChsYnMgJiYgbGJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgbGIgb2YgbGJzLnNsaWNlKDAsIDIpKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJsb2FkX2JhbGFuY2Vyc1wiKVxuICAgICAgICAgIC51cGRhdGUoe1xuICAgICAgICAgICAgYXZnX3JlcXVlc3RfY291bnRfN2Q6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCksIC8vIDAtMTAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZXEoXCJpZFwiLCBsYi5pZClcbiAgICAgICAgaWYgKCFlcnJvcikgY291bnRzLmxvYWRCYWxhbmNlcnMrK1xuICAgICAgfVxuICAgIH1cblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRlYnVnKFwiRXJyb3Igc2VlZGluZyB3YXN0ZWZ1bCBkYXRhOlwiLCBlcnJvcilcbiAgfVxuXG4gIHJldHVybiBjb3VudHNcbn1cblxuLyoqXG4gKiBQT1NUIC9hcGkvZHJpZnQtdGlja1xuICpcbiAqIE1haW4gZHJpZnQgZGV0ZWN0aW9uIGFuZCBhdXRvLWV4ZWN1dGlvbiBlbmRwb2ludC5cbiAqIFRoaXMgaXMgdGhlIFwiaGVhcnRiZWF0XCIgb2YgdGhlIG9wdGltaXphdGlvbiBhZ2VudDpcbiAqIDEuIFJ1bnMgd2FzdGUgZGV0ZWN0aW9uIGFjcm9zcyBhbGwgcmVzb3VyY2VzXG4gKiAyLiBDaGVja3MgaWYgYXV0b21hdGVkIG1vZGUgaXMgZW5hYmxlZFxuICogMy4gSWYgYXV0b21hdGVkLCBleGVjdXRlcyBhbGwgYXV0by1zYWZlIGFjdGlvbnMgYXV0b21hdGljYWxseVxuICpcbiAqIFRoaXMgZW5kcG9pbnQgY2FuIGJlIGNhbGxlZDpcbiAqIC0gTWFudWFsbHkgdmlhIHRoZSBVSSByZWZyZXNoIGJ1dHRvblxuICogLSBPbiBhIHNjaGVkdWxlIChjcm9uIGpvYilcbiAqIC0gVmlhIHdlYmhvb2sgZnJvbSBleHRlcm5hbCBzeXN0ZW1zXG4gKlxuICogQm9keSBwYXJhbXM6XG4gKiAtIGF1dG9FeGVjdXRlOiAob3B0aW9uYWwpIE92ZXJyaWRlIHRoZSBleGVjdXRpb24gbW9kZSAodHJ1ZSA9IGF1dG8tZXhlY3V0ZSwgZmFsc2UgPSBkZXRlY3Qgb25seSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc3QgcmVxdWVzdFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIGRlYnVnKFwi4pWU4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWXXCIpXG4gIGRlYnVnKFwi4pWRICAgICAgICAgICAgICAgICAgICBEUklGVCBUSUNLIFNUQVJURUQgICAgICAgICAgICAgICAgICAgICAgICDilZFcIilcbiAgZGVidWcoXCLilZrilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZ1cIilcblxuICB0cnkge1xuICAgIC8vIFBhcnNlIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKVxuICAgIGRlYnVnKFwiUmVxdWVzdCBib2R5OlwiLCBib2R5KVxuXG4gICAgLy8gR2V0IFN1cGFiYXNlIGNyZWRlbnRpYWxzIGZyb20gZW52aXJvbm1lbnRcbiAgICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTFxuICAgIGNvbnN0IHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxuXG4gICAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VLZXkpIHtcbiAgICAgIGRlYnVnKFwi4p2MIEVSUk9SOiBObyBkYXRhYmFzZSBjcmVkZW50aWFscyBmb3VuZFwiKVxuICAgICAgZGVidWcoXCIgIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDpcIiwgc3VwYWJhc2VVcmwgPyBcIlNFVFwiIDogXCJOT1QgU0VUXCIpXG4gICAgICBkZWJ1ZyhcIiAgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTpcIiwgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA/IFwiU0VUXCIgOiBcIk5PVCBTRVRcIilcbiAgICAgIGRlYnVnKFwiICBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTpcIiwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPyBcIlNFVFwiIDogXCJOT1QgU0VUXCIpXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogXCJOb3QgY29ubmVjdGVkIHRvIGRhdGFiYXNlLiBQbGVhc2UgY29uZmlndXJlIGNvbm5lY3Rpb24uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKVxuICAgIH1cblxuICAgIGRlYnVnKFwiRGF0YWJhc2UgY3JlZGVudGlhbHM6IE9LXCIpXG5cbiAgICAvLyBDcmVhdGUgU3VwYWJhc2UgY2xpZW50IGZvciBzZWVkaW5nXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5KVxuXG4gICAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gICAgLy8gU1RFUCAwOiBTZWVkIHdhc3RlZnVsIGRhdGEgKGVuc3VyZXMgZGV0ZWN0aW9ucyBhbHdheXMgZXhpc3QpXG4gICAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gICAgZGVidWcoXCLilIDilIDilIAgU1RFUCAwOiBTRUVESU5HIFdBU1RFRlVMIERBVEEg4pSA4pSA4pSAXCIpXG4gICAgY29uc3Qgc2VlZFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3Qgc2VlZENvdW50cyA9IGF3YWl0IHNlZWRXYXN0ZWZ1bERhdGEoc3VwYWJhc2UpXG4gICAgY29uc3Qgc2VlZER1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzZWVkU3RhcnRUaW1lXG4gICAgZGVidWcoYFNlZWRpbmcgY29tcGxldGVkIGluICR7c2VlZER1cmF0aW9uLnRvRml4ZWQoMCl9bXNgKVxuICAgIGRlYnVnKGBTZWVkZWQ6IFJEUz0ke3NlZWRDb3VudHMucmRzfSwgQ2FjaGU9JHtzZWVkQ291bnRzLmNhY2hlfSwgUzM9JHtzZWVkQ291bnRzLnMzfSwgU25hcHNob3RzPSR7c2VlZENvdW50cy5zbmFwc2hvdHN9LCBBU0c9JHtzZWVkQ291bnRzLmFzZ30sIExCPSR7c2VlZENvdW50cy5sb2FkQmFsYW5jZXJzfWApXG5cbiAgICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgICAvLyBTVEVQIDE6IFJ1biB3YXN0ZSBkZXRlY3Rpb25cbiAgICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgICBkZWJ1ZyhcIuKUgOKUgOKUgCBTVEVQIDE6IFdBU1RFIERFVEVDVElPTiDilIDilIDilIBcIilcbiAgICBjb25zdCBkZXRlY3Rpb25TdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGRldGVjdG9yID0gY3JlYXRlRGV0ZWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5KVxuICAgIGNvbnN0IHJlc3VsdDogRGV0ZWN0aW9uUmVzdWx0ID0gYXdhaXQgZGV0ZWN0b3IuZGV0ZWN0QWxsKClcbiAgICBjb25zdCBkZXRlY3Rpb25EdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gZGV0ZWN0aW9uU3RhcnRUaW1lXG4gICAgZGVidWcoYERldGVjdGlvbiBjb21wbGV0ZWQgaW4gJHtkZXRlY3Rpb25EdXJhdGlvbi50b0ZpeGVkKDApfW1zYClcbiAgICBkZWJ1ZyhgVG90YWwgZGV0ZWN0aW9uczogJHtyZXN1bHQuZGV0ZWN0aW9ucy5sZW5ndGh9YClcbiAgICBkZWJ1ZyhgVG90YWwgcG90ZW50aWFsIHNhdmluZ3M6ICQke3Jlc3VsdC5zdW1tYXJ5LnRvdGFsUG90ZW50aWFsU2F2aW5ncy50b0ZpeGVkKDIpfS9tb2ApXG5cbiAgICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgICAvLyBTVEVQIDI6IENoZWNrIGV4ZWN1dGlvbiBtb2RlIHNldHRpbmdcbiAgICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgICBkZWJ1ZyhcIuKUgOKUgOKUgCBTVEVQIDI6IEVYRUNVVElPTiBNT0RFIENIRUNLIOKUgOKUgOKUgFwiKVxuXG4gICAgLy8gQ2hlY2sgaWYgYXV0by1leGVjdXRlIGlzIGV4cGxpY2l0bHkgc2V0IGluIGJvZHksIG90aGVyd2lzZSBjaGVjayBzZXR0aW5nc1xuICAgIGxldCBzaG91bGRBdXRvRXhlY3V0ZSA9IGJvZHkuYXV0b0V4ZWN1dGVcbiAgICBsZXQgbW9kZVNvdXJjZSA9IFwicmVxdWVzdCBib2R5XCJcblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkQXV0b0V4ZWN1dGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkZWJ1ZyhcImF1dG9FeGVjdXRlIG5vdCBpbiByZXF1ZXN0IGJvZHksIGNoZWNraW5nIGRhdGFiYXNlIHNldHRpbmdzLi4uXCIpXG4gICAgICBjb25zdCB7IGRhdGE6IHNldHRpbmdzLCBlcnJvcjogc2V0dGluZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oXCJzZXR0aW5nc1wiKVxuICAgICAgICAuc2VsZWN0KFwidmFsdWVcIilcbiAgICAgICAgLmVxKFwia2V5XCIsIFwiZXhlY3V0aW9uX3NldHRpbmdzXCIpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoc2V0dGluZ3NFcnJvcikge1xuICAgICAgICBkZWJ1ZyhcIlNldHRpbmdzIHF1ZXJ5IGVycm9yOlwiLCBzZXR0aW5nc0Vycm9yLm1lc3NhZ2UpXG4gICAgICAgIGRlYnVnKFwiRXJyb3IgY29kZTpcIiwgc2V0dGluZ3NFcnJvci5jb2RlKVxuICAgICAgICBpZiAoc2V0dGluZ3NFcnJvci5jb2RlID09PSBcIlBHUlNUMTE2XCIpIHtcbiAgICAgICAgICBkZWJ1ZyhcIlNldHRpbmdzIHJvdyBub3QgZm91bmQgLSBkZWZhdWx0aW5nIHRvIG1hbnVhbCBtb2RlXCIpXG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3NFcnJvci5jb2RlID09PSBcIjQyUDAxXCIpIHtcbiAgICAgICAgICBkZWJ1ZyhcIlNldHRpbmdzIHRhYmxlIGRvZXMgbm90IGV4aXN0IC0gZGVmYXVsdGluZyB0byBtYW51YWwgbW9kZVwiKVxuICAgICAgICB9XG4gICAgICAgIHNob3VsZEF1dG9FeGVjdXRlID0gZmFsc2VcbiAgICAgICAgbW9kZVNvdXJjZSA9IFwiZGVmYXVsdCAoc2V0dGluZ3Mgbm90IGZvdW5kKVwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZyhcIlNldHRpbmdzIGZyb20gZGF0YWJhc2U6XCIsIHNldHRpbmdzPy52YWx1ZSlcbiAgICAgICAgc2hvdWxkQXV0b0V4ZWN1dGUgPSBzZXR0aW5ncz8udmFsdWU/Lm1vZGUgPT09IFwiYXV0b21hdGVkXCJcbiAgICAgICAgbW9kZVNvdXJjZSA9IFwiZGF0YWJhc2Ugc2V0dGluZ3NcIlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgYXV0b0V4ZWN1dGUgZXhwbGljaXRseSBzZXQgaW4gcmVxdWVzdCBib2R5OiAke3Nob3VsZEF1dG9FeGVjdXRlfWApXG4gICAgfVxuXG4gICAgZGVidWcoYOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkGApXG4gICAgZGVidWcoYEVYRUNVVElPTiBNT0RFOiAke3Nob3VsZEF1dG9FeGVjdXRlID8gXCLwn5+iIEFVVE9NQVRFRFwiIDogXCLwn5S0IE1BTlVBTFwifWApXG4gICAgZGVidWcoYE1vZGUgc291cmNlOiAke21vZGVTb3VyY2V9YClcbiAgICBkZWJ1Zyhg4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQYClcblxuICAgIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAgIC8vIFNURVAgMzogRmlsdGVyIGZvciBhdXRvLXNhZmUgZGV0ZWN0aW9uc1xuICAgIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAgIGRlYnVnKFwi4pSA4pSA4pSAIFNURVAgMzogRklMVEVSIEFVVE8tU0FGRSBERVRFQ1RJT05TIOKUgOKUgOKUgFwiKVxuICAgIGNvbnN0IGF1dG9TYWZlSWRzID0gQVVUT19TQUZFX1NDRU5BUklPUy5tYXAoKHMpID0+IHMuaWQpXG4gICAgZGVidWcoXCJBdXRvLXNhZmUgc2NlbmFyaW8gSURzOlwiLCBhdXRvU2FmZUlkcylcblxuICAgIGNvbnN0IGF1dG9TYWZlRGV0ZWN0aW9ucyA9IHJlc3VsdC5kZXRlY3Rpb25zLmZpbHRlcigoZCkgPT5cbiAgICAgIGF1dG9TYWZlSWRzLmluY2x1ZGVzKGQuc2NlbmFyaW9JZCBhcyB0eXBlb2YgYXV0b1NhZmVJZHNbbnVtYmVyXSlcbiAgICApXG5cbiAgICBkZWJ1ZyhgQXV0by1zYWZlIGRldGVjdGlvbnM6ICR7YXV0b1NhZmVEZXRlY3Rpb25zLmxlbmd0aH0gb2YgJHtyZXN1bHQuZGV0ZWN0aW9ucy5sZW5ndGh9IHRvdGFsYClcbiAgICBpZiAoYXV0b1NhZmVEZXRlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnKFwiQXV0by1zYWZlIGRldGVjdGlvbiBkZXRhaWxzOlwiKVxuICAgICAgYXV0b1NhZmVEZXRlY3Rpb25zLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgZGVidWcoYCAgJHtpICsgMX0uICR7ZC5yZXNvdXJjZU5hbWV9ICgke2Quc2NlbmFyaW9JZH0pIC0gJCR7ZC5wb3RlbnRpYWxTYXZpbmdzLnRvRml4ZWQoMil9L21vYClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gICAgLy8gU1RFUCA0OiBFeGVjdXRlIGFjdGlvbnMgaWYgYXV0b21hdGVkIG1vZGVcbiAgICAvLyDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZBcbiAgICBkZWJ1ZyhcIuKUgOKUgOKUgCBTVEVQIDQ6IEVYRUNVVElPTiDilIDilIDilIBcIilcbiAgICBsZXQgZXhlY3V0aW9uUmVzdWx0czoge1xuICAgICAgcmVzb3VyY2VJZDogc3RyaW5nXG4gICAgICByZXNvdXJjZU5hbWU6IHN0cmluZ1xuICAgICAgYWN0aW9uOiBzdHJpbmdcbiAgICAgIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgICAgIG1lc3NhZ2U6IHN0cmluZ1xuICAgICAgZHVyYXRpb25NczogbnVtYmVyXG4gICAgfVtdID0gW11cblxuICAgIGlmICghc2hvdWxkQXV0b0V4ZWN1dGUpIHtcbiAgICAgIGRlYnVnKFwi4o+477iPICBTS0lQUElORyBFWEVDVVRJT04gLSBNb2RlIGlzIE1BTlVBTFwiKVxuICAgICAgZGVidWcoXCIgICBUbyBhdXRvLWV4ZWN1dGUsIGVpdGhlcjpcIilcbiAgICAgIGRlYnVnKFwiICAgMS4gVG9nZ2xlIHRvICdBdXRvbWF0ZWQnIG1vZGUgaW4gdGhlIFVJXCIpXG4gICAgICBkZWJ1ZyhcIiAgIDIuIFBhc3MgeyBhdXRvRXhlY3V0ZTogdHJ1ZSB9IGluIHRoZSByZXF1ZXN0IGJvZHlcIilcbiAgICB9IGVsc2UgaWYgKGF1dG9TYWZlRGV0ZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlYnVnKFwi4o+477iPICBTS0lQUElORyBFWEVDVVRJT04gLSBObyBhdXRvLXNhZmUgZGV0ZWN0aW9ucyBmb3VuZFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zyhg8J+agCBFWEVDVVRJTkcgJHthdXRvU2FmZURldGVjdGlvbnMubGVuZ3RofSBBVVRPLVNBRkUgQUNUSU9OUy4uLmApXG4gICAgICBjb25zdCBleGVjdXRvciA9IGNyZWF0ZUV4ZWN1dG9yKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSlcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdXRvU2FmZURldGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGV0ZWN0aW9uID0gYXV0b1NhZmVEZXRlY3Rpb25zW2ldXG4gICAgICAgIGNvbnN0IGFjdGlvblN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TW2RldGVjdGlvbi5zY2VuYXJpb0lkIGFzIGtleW9mIHR5cGVvZiBXQVNURV9TQ0VOQVJJT1NdXG5cbiAgICAgICAgZGVidWcoYOKUgOKUgOKUgCBBY3Rpb24gJHtpICsgMX0vJHthdXRvU2FmZURldGVjdGlvbnMubGVuZ3RofSDilIDilIDilIBgKVxuICAgICAgICBkZWJ1ZyhgUmVzb3VyY2U6ICR7ZGV0ZWN0aW9uLnJlc291cmNlTmFtZX1gKVxuICAgICAgICBkZWJ1ZyhgUmVzb3VyY2UgSUQ6ICR7ZGV0ZWN0aW9uLnJlc291cmNlSWR9YClcbiAgICAgICAgZGVidWcoYFNjZW5hcmlvOiAke2RldGVjdGlvbi5zY2VuYXJpb0lkfWApXG5cbiAgICAgICAgaWYgKCFzY2VuYXJpbykge1xuICAgICAgICAgIGRlYnVnKGDimqDvuI8gIFVua25vd24gc2NlbmFyaW86ICR7ZGV0ZWN0aW9uLnNjZW5hcmlvSWR9IC0gU0tJUFBJTkdgKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZyhgQWN0aW9uOiAke3NjZW5hcmlvLmFjdGlvbn1gKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zID0ge1xuICAgICAgICAgICAgYWN0aW9uOiBzY2VuYXJpby5hY3Rpb24sXG4gICAgICAgICAgICByZXNvdXJjZVR5cGU6IHNjZW5hcmlvLnJlc291cmNlVHlwZSxcbiAgICAgICAgICAgIHJlc291cmNlSWQ6IGRldGVjdGlvbi5yZXNvdXJjZUlkLFxuICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiBkZXRlY3Rpb24ucmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgZGV0ZWN0aW9uSWQ6IGRldGVjdGlvbi5pZCxcbiAgICAgICAgICAgIHNjZW5hcmlvSWQ6IGRldGVjdGlvbi5zY2VuYXJpb0lkLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0ZWN0aW9uLmRldGFpbHMsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcoXCJFeGVjdXRpbmcgd2l0aCBwYXJhbXM6XCIsIHBhcmFtcylcbiAgICAgICAgICBjb25zdCBleGVjUmVzdWx0ID0gYXdhaXQgZXhlY3V0b3IuZXhlY3V0ZUFjdGlvbihwYXJhbXMpXG4gICAgICAgICAgY29uc3QgYWN0aW9uRHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGFjdGlvblN0YXJ0VGltZVxuXG4gICAgICAgICAgZXhlY3V0aW9uUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIHJlc291cmNlSWQ6IGRldGVjdGlvbi5yZXNvdXJjZUlkLFxuICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiBkZXRlY3Rpb24ucmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgYWN0aW9uOiBzY2VuYXJpby5hY3Rpb24sXG4gICAgICAgICAgICBzdWNjZXNzOiBleGVjUmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICBtZXNzYWdlOiBleGVjUmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgICAgICBkdXJhdGlvbk1zOiBNYXRoLnJvdW5kKGFjdGlvbkR1cmF0aW9uKSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYgKGV4ZWNSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZGVidWcoYOKchSBTVUNDRVNTOiAke2V4ZWNSZXN1bHQubWVzc2FnZX0gKCR7YWN0aW9uRHVyYXRpb24udG9GaXhlZCgwKX1tcylgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWJ1Zyhg4p2MIEZBSUxFRDogJHtleGVjUmVzdWx0Lm1lc3NhZ2V9ICgke2FjdGlvbkR1cmF0aW9uLnRvRml4ZWQoMCl9bXMpYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc3QgYWN0aW9uRHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGFjdGlvblN0YXJ0VGltZVxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG5cbiAgICAgICAgICBleGVjdXRpb25SZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgcmVzb3VyY2VJZDogZGV0ZWN0aW9uLnJlc291cmNlSWQsXG4gICAgICAgICAgICByZXNvdXJjZU5hbWU6IGRldGVjdGlvbi5yZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICBhY3Rpb246IHNjZW5hcmlvLmFjdGlvbixcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGR1cmF0aW9uTXM6IE1hdGgucm91bmQoYWN0aW9uRHVyYXRpb24pLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBkZWJ1Zyhg4p2MIEVYQ0VQVElPTjogJHttZXNzYWdlfSAoJHthY3Rpb25EdXJhdGlvbi50b0ZpeGVkKDApfW1zKWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZ1bGwgZXJyb3I6XCIsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8g4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQXG4gICAgLy8gU1VNTUFSWVxuICAgIC8vIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkFxuICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHJlcXVlc3RTdGFydFRpbWVcbiAgICBjb25zdCBzdWNjZXNzQ291bnQgPSBleGVjdXRpb25SZXN1bHRzLmZpbHRlcigocikgPT4gci5zdWNjZXNzKS5sZW5ndGhcbiAgICBjb25zdCBmYWlsQ291bnQgPSBleGVjdXRpb25SZXN1bHRzLmZpbHRlcigocikgPT4gIXIuc3VjY2VzcykubGVuZ3RoXG5cbiAgICBkZWJ1ZyhcIuKVlOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVl1wiKVxuICAgIGRlYnVnKFwi4pWRICAgICAgICAgICAgICAgICAgICBEUklGVCBUSUNLIENPTVBMRVRFICAgICAgICAgICAgICAgICAgICAgICDilZFcIilcbiAgICBkZWJ1ZyhcIuKVoOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVo1wiKVxuICAgIGRlYnVnKGDilZEgIFRvdGFsIER1cmF0aW9uOiAke3RvdGFsRHVyYXRpb24udG9GaXhlZCgwKX1tc2ApXG4gICAgZGVidWcoYOKVkSAgU2VlZGluZyBEdXJhdGlvbjogJHtzZWVkRHVyYXRpb24udG9GaXhlZCgwKX1tc2ApXG4gICAgZGVidWcoYOKVkSAgRGV0ZWN0aW9uIER1cmF0aW9uOiAke2RldGVjdGlvbkR1cmF0aW9uLnRvRml4ZWQoMCl9bXNgKVxuICAgIGRlYnVnKGDilZEgIGApXG4gICAgZGVidWcoYOKVkSAg8J+MsSBTRUVESU5HOmApXG4gICAgZGVidWcoYOKVkSAgICAgUkRTOiAke3NlZWRDb3VudHMucmRzfSwgQ2FjaGU6ICR7c2VlZENvdW50cy5jYWNoZX0sIFMzOiAke3NlZWRDb3VudHMuczN9YClcbiAgICBkZWJ1Zyhg4pWRICAgICBTbmFwc2hvdHM6ICR7c2VlZENvdW50cy5zbmFwc2hvdHN9LCBBU0c6ICR7c2VlZENvdW50cy5hc2d9LCBMQjogJHtzZWVkQ291bnRzLmxvYWRCYWxhbmNlcnN9YClcbiAgICBkZWJ1Zyhg4pWRICBgKVxuICAgIGRlYnVnKGDilZEgIPCfk4ogREVURUNUSU9OUzpgKVxuICAgIGRlYnVnKGDilZEgICAgIFRvdGFsOiAke3Jlc3VsdC5kZXRlY3Rpb25zLmxlbmd0aH1gKVxuICAgIGRlYnVnKGDilZEgICAgIEF1dG8tU2FmZTogJHthdXRvU2FmZURldGVjdGlvbnMubGVuZ3RofWApXG4gICAgZGVidWcoYOKVkSAgICAgVG90YWwgU2F2aW5nczogJCR7cmVzdWx0LnN1bW1hcnkudG90YWxQb3RlbnRpYWxTYXZpbmdzLnRvRml4ZWQoMil9L21vYClcbiAgICBkZWJ1Zyhg4pWRICBgKVxuICAgIGRlYnVnKGDilZEgIOKaoSBFWEVDVVRJT046YClcbiAgICBkZWJ1Zyhg4pWRICAgICBNb2RlOiAke3Nob3VsZEF1dG9FeGVjdXRlID8gXCJBVVRPTUFURURcIiA6IFwiTUFOVUFMXCJ9YClcbiAgICBkZWJ1Zyhg4pWRICAgICBFeGVjdXRlZDogJHtleGVjdXRpb25SZXN1bHRzLmxlbmd0aH1gKVxuICAgIGRlYnVnKGDilZEgICAgIFN1Y2Nlc3M6ICR7c3VjY2Vzc0NvdW50fWApXG4gICAgZGVidWcoYOKVkSAgICAgRmFpbGVkOiAke2ZhaWxDb3VudH1gKVxuICAgIGRlYnVnKFwi4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWdXCIpXG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VlZGluZzoge1xuICAgICAgICAgIHJkczogc2VlZENvdW50cy5yZHMsXG4gICAgICAgICAgY2FjaGU6IHNlZWRDb3VudHMuY2FjaGUsXG4gICAgICAgICAgczM6IHNlZWRDb3VudHMuczMsXG4gICAgICAgICAgc25hcHNob3RzOiBzZWVkQ291bnRzLnNuYXBzaG90cyxcbiAgICAgICAgICBhc2c6IHNlZWRDb3VudHMuYXNnLFxuICAgICAgICAgIGxvYWRCYWxhbmNlcnM6IHNlZWRDb3VudHMubG9hZEJhbGFuY2VycyxcbiAgICAgICAgfSxcbiAgICAgICAgZGV0ZWN0aW9uOiB7XG4gICAgICAgICAgdG90YWxEZXRlY3Rpb25zOiByZXN1bHQuZGV0ZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgYXV0b1NhZmVEZXRlY3Rpb25zOiBhdXRvU2FmZURldGVjdGlvbnMubGVuZ3RoLFxuICAgICAgICAgIHRvdGFsU2F2aW5nczogcmVzdWx0LnN1bW1hcnkudG90YWxQb3RlbnRpYWxTYXZpbmdzLFxuICAgICAgICAgIGF1dG9TYWZlU2F2aW5nczogYXV0b1NhZmVEZXRlY3Rpb25zLnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyBkLnBvdGVudGlhbFNhdmluZ3MsIDApLFxuICAgICAgICAgIGJ5U2NlbmFyaW86IHJlc3VsdC5zdW1tYXJ5LmJ5U2NlbmFyaW8sXG4gICAgICAgIH0sXG4gICAgICAgIGV4ZWN1dGlvbjoge1xuICAgICAgICAgIG1vZGU6IHNob3VsZEF1dG9FeGVjdXRlID8gXCJhdXRvbWF0ZWRcIiA6IFwibWFudWFsXCIsXG4gICAgICAgICAgZXhlY3V0ZWQ6IGV4ZWN1dGlvblJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NDb3VudCxcbiAgICAgICAgICBmYWlsZWQ6IGZhaWxDb3VudCxcbiAgICAgICAgICByZXN1bHRzOiBleGVjdXRpb25SZXN1bHRzLFxuICAgICAgICB9LFxuICAgICAgICB0aW1pbmc6IHtcbiAgICAgICAgICBzZWVkaW5nTXM6IE1hdGgucm91bmQoc2VlZER1cmF0aW9uKSxcbiAgICAgICAgICBkZXRlY3Rpb25NczogTWF0aC5yb3VuZChkZXRlY3Rpb25EdXJhdGlvbiksXG4gICAgICAgICAgdG90YWxNczogTWF0aC5yb3VuZCh0b3RhbER1cmF0aW9uKSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lXG4gICAgZGVidWcoYOKdjCBGQVRBTCBFUlJPUiBhZnRlciAke3RvdGFsRHVyYXRpb24udG9GaXhlZCgwKX1tczpgKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJEcmlmdCB0aWNrIGZhaWxlZFwiLFxuICAgICAgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIEdFVCAvYXBpL2RyaWZ0LXRpY2tcbiAqXG4gKiBHZXQgdGhlIHN0YXR1cyBvZiB0aGUgZHJpZnQtdGljayBzeXN0ZW0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQoKSB7XG4gIGRlYnVnKFwiR0VUIC9hcGkvZHJpZnQtdGljayAtIFN0YXR1cyBjaGVja1wiKVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkxcbiAgICBjb25zdCBzdXBhYmFzZUtleSA9IHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVlcblxuICAgIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgICBkZWJ1ZyhcIk5vIGRhdGFiYXNlIGNyZWRlbnRpYWxzXCIpXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiBcInVua25vd25cIixcbiAgICAgICAgICBtZXNzYWdlOiBcIkRhdGFiYXNlIG5vdCBjb25maWd1cmVkXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSlcbiAgICBjb25zdCB7IGRhdGE6IHNldHRpbmdzLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwic2V0dGluZ3NcIilcbiAgICAgIC5zZWxlY3QoXCJ2YWx1ZVwiKVxuICAgICAgLmVxKFwia2V5XCIsIFwiZXhlY3V0aW9uX3NldHRpbmdzXCIpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgZGVidWcoXCJTZXR0aW5ncyBxdWVyeSBlcnJvcjpcIiwgZXJyb3IubWVzc2FnZSlcbiAgICB9XG5cbiAgICBjb25zdCBtb2RlID0gc2V0dGluZ3M/LnZhbHVlPy5tb2RlIHx8IFwibWFudWFsXCJcbiAgICBkZWJ1ZyhgQ3VycmVudCBtb2RlOiAke21vZGV9YClcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZGF0YToge1xuICAgICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBzZXR0aW5ncz8udmFsdWU/LnVwZGF0ZWRfYXQgfHwgbnVsbCxcbiAgICAgICAgYXV0b1NhZmVTY2VuYXJpb3M6IEFVVE9fU0FGRV9TQ0VOQVJJT1MubGVuZ3RoLFxuICAgICAgfSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRlYnVnKFwiR0VUIGVycm9yOlwiLCBlcnJvcilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBnZXQgc3RhdHVzXCIsXG4gICAgICB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKVxuICB9XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiY3JlYXRlQ2xpZW50IiwiY3JlYXRlRGV0ZWN0b3IiLCJjcmVhdGVFeGVjdXRvciIsIldBU1RFX1NDRU5BUklPUyIsIkFVVE9fU0FGRV9TQ0VOQVJJT1MiLCJkZWJ1ZyIsIm1lc3NhZ2UiLCJkYXRhIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImxvZyIsInNlZWRXYXN0ZWZ1bERhdGEiLCJzdXBhYmFzZSIsImNvdW50cyIsInJkcyIsImNhY2hlIiwiczMiLCJzbmFwc2hvdHMiLCJhc2ciLCJsb2FkQmFsYW5jZXJzIiwicmRzSW5zdGFuY2VzIiwiZnJvbSIsInNlbGVjdCIsImVxIiwibGltaXQiLCJsZW5ndGgiLCJpbnN0YW5jZSIsInNsaWNlIiwiZXJyb3IiLCJ1cGRhdGUiLCJhdmdfY3B1XzdkIiwiTWF0aCIsInJhbmRvbSIsImF2Z19jb25uZWN0aW9uc183ZCIsImlkIiwiY2FjaGVDbHVzdGVycyIsImNsdXN0ZXIiLCJmbG9vciIsInMzQnVja2V0cyIsImJ1Y2tldCIsImxpZmVjeWNsZV9ydWxlcyIsInNuYXBzaG90IiwiZGF5c09sZCIsIm9sZERhdGUiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImNyZWF0ZWRfYXQiLCJhc2dzIiwiZW52cyIsInN0YWxlRGF0ZSIsImkiLCJtaW4iLCJlbnYiLCJjdXJyZW50X3V0aWxpemF0aW9uIiwiZGVzaXJlZF9jYXBhY2l0eSIsIm1pbl9zaXplIiwibGJzIiwibGIiLCJhdmdfcmVxdWVzdF9jb3VudF83ZCIsIlBPU1QiLCJyZXF1ZXN0IiwicmVxdWVzdFN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiYm9keSIsImpzb24iLCJjYXRjaCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VjY2VzcyIsInN0YXR1cyIsInNlZWRTdGFydFRpbWUiLCJzZWVkQ291bnRzIiwic2VlZER1cmF0aW9uIiwidG9GaXhlZCIsImRldGVjdGlvblN0YXJ0VGltZSIsImRldGVjdG9yIiwicmVzdWx0IiwiZGV0ZWN0QWxsIiwiZGV0ZWN0aW9uRHVyYXRpb24iLCJkZXRlY3Rpb25zIiwic3VtbWFyeSIsInRvdGFsUG90ZW50aWFsU2F2aW5ncyIsInNob3VsZEF1dG9FeGVjdXRlIiwiYXV0b0V4ZWN1dGUiLCJtb2RlU291cmNlIiwic2V0dGluZ3MiLCJzZXR0aW5nc0Vycm9yIiwic2luZ2xlIiwiY29kZSIsInZhbHVlIiwibW9kZSIsImF1dG9TYWZlSWRzIiwibWFwIiwicyIsImF1dG9TYWZlRGV0ZWN0aW9ucyIsImZpbHRlciIsImQiLCJpbmNsdWRlcyIsInNjZW5hcmlvSWQiLCJmb3JFYWNoIiwicmVzb3VyY2VOYW1lIiwicG90ZW50aWFsU2F2aW5ncyIsImV4ZWN1dGlvblJlc3VsdHMiLCJleGVjdXRvciIsImRldGVjdGlvbiIsImFjdGlvblN0YXJ0VGltZSIsInNjZW5hcmlvIiwicmVzb3VyY2VJZCIsImFjdGlvbiIsInBhcmFtcyIsInJlc291cmNlVHlwZSIsImRldGVjdGlvbklkIiwiZGV0YWlscyIsImV4ZWNSZXN1bHQiLCJleGVjdXRlQWN0aW9uIiwiYWN0aW9uRHVyYXRpb24iLCJwdXNoIiwiZHVyYXRpb25NcyIsInJvdW5kIiwiRXJyb3IiLCJ0b3RhbER1cmF0aW9uIiwic3VjY2Vzc0NvdW50IiwiciIsImZhaWxDb3VudCIsInNlZWRpbmciLCJ0b3RhbERldGVjdGlvbnMiLCJ0b3RhbFNhdmluZ3MiLCJhdXRvU2FmZVNhdmluZ3MiLCJyZWR1Y2UiLCJzdW0iLCJieVNjZW5hcmlvIiwiZXhlY3V0aW9uIiwiZXhlY3V0ZWQiLCJmYWlsZWQiLCJyZXN1bHRzIiwidGltaW5nIiwic2VlZGluZ01zIiwiZGV0ZWN0aW9uTXMiLCJ0b3RhbE1zIiwiR0VUIiwiY29ubmVjdGVkIiwibGFzdFVwZGF0ZWQiLCJ1cGRhdGVkX2F0IiwiYXV0b1NhZmVTY2VuYXJpb3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/drift-tick/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/agent/detector.ts":
/*!*******************************!*\
  !*** ./lib/agent/detector.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WasteDetector: () => (/* binding */ WasteDetector),\n/* harmony export */   clearDetectionCache: () => (/* binding */ clearDetectionCache),\n/* harmony export */   createDetector: () => (/* binding */ createDetector),\n/* harmony export */   getCacheStatus: () => (/* binding */ getCacheStatus)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var _scenarios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scenarios */ \"(rsc)/./lib/agent/scenarios.ts\");\n/* harmony import */ var _lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/utils/pricing */ \"(rsc)/./lib/utils/pricing.ts\");\n/**\n * Waste Detection Engine\n *\n * Core detection logic that analyzes resources from Supabase\n * and identifies waste scenarios with confidence scoring.\n *\n * OPTIMIZED: Uses batch fetching and in-memory processing\n * to reduce database queries from 15+ to 11 parallel queries.\n */ \n\n\nlet detectionCache = null;\nconst CACHE_TTL_MS = 30000 // 30 seconds\n;\n/**\n * Main waste detector class\n */ class WasteDetector {\n    constructor(supabaseUrl, supabaseKey){\n        this.supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(supabaseUrl, supabaseKey);\n    }\n    /**\n   * Run full detection across all resources\n   * OPTIMIZED: Uses batch fetching and caching\n   */ async detectAll() {\n        const detectAllStartTime = performance.now();\n        console.log(\"[Detector] detectAll() started\");\n        // Check cache first\n        if (detectionCache) {\n            const age = Date.now() - detectionCache.timestamp;\n            if (age < CACHE_TTL_MS) {\n                const cacheHitTime = performance.now() - detectAllStartTime;\n                console.log(`[Detector] CACHE HIT - age: ${Math.round(age / 1000)}s, lookup: ${cacheHitTime.toFixed(0)}ms`);\n                return detectionCache.result;\n            }\n            console.log(`[Detector] CACHE EXPIRED - Age: ${Math.round(age / 1000)}s exceeds TTL: ${CACHE_TTL_MS / 1000}s`);\n        } else {\n            console.log(\"[Detector] CACHE MISS - No cached results\");\n        }\n        console.log(\"[Detector] Starting parallel fetch of 11 tables...\");\n        const fetchStartTime = performance.now();\n        // OPTIMIZATION: Fetch all resource tables in a single parallel operation\n        const resourceData = await this.batchFetchAllResources();\n        const fetchDuration = performance.now() - fetchStartTime;\n        console.log(`[Detector] DB fetch completed in ${fetchDuration.toFixed(0)}ms`);\n        console.log(`[Detector] Resource counts:`);\n        console.log(`  - instances: ${resourceData.instances.length}`);\n        console.log(`  - rds_instances: ${resourceData.rdsInstances.length}`);\n        console.log(`  - cache_clusters: ${resourceData.cacheClusters.length}`);\n        console.log(`  - load_balancers: ${resourceData.loadBalancers.length}`);\n        console.log(`  - lambda_functions: ${resourceData.lambdaFunctions.length}`);\n        console.log(`  - volumes: ${resourceData.volumes.length}`);\n        console.log(`  - snapshots: ${resourceData.snapshots.length}`);\n        console.log(`  - elastic_ips: ${resourceData.elasticIps.length}`);\n        console.log(`  - s3_buckets: ${resourceData.s3Buckets.length}`);\n        console.log(`  - log_groups: ${resourceData.logGroups.length}`);\n        console.log(`  - autoscaling_groups: ${resourceData.autoscalingGroups.length}`);\n        // Run all detection functions on pre-fetched data (no more DB calls)\n        const detections = [];\n        const timestamp = new Date().toISOString();\n        console.log(\"[Detector] Starting in-memory detection processing...\");\n        // Process all detections in-memory using pre-fetched data\n        const idleInstances = this.detectIdleInstancesFromData(resourceData.instances);\n        console.log(`[Detector] detectIdleInstances: ${idleInstances.length} detections`);\n        detections.push(...idleInstances);\n        const orphanedEips = this.detectOrphanedEIPsFromData(resourceData.elasticIps);\n        console.log(`[Detector] detectOrphanedEIPs: ${orphanedEips.length} detections`);\n        detections.push(...orphanedEips);\n        const unattachedVolumes = this.detectUnattachedVolumesFromData(resourceData.volumes);\n        console.log(`[Detector] detectUnattachedVolumes: ${unattachedVolumes.length} detections`);\n        detections.push(...unattachedVolumes);\n        const oldSnapshots = this.detectOldSnapshotsFromData(resourceData.snapshots);\n        console.log(`[Detector] detectOldSnapshots: ${oldSnapshots.length} detections`);\n        detections.push(...oldSnapshots);\n        const idleRds = this.detectIdleRDSFromData(resourceData.rdsInstances);\n        console.log(`[Detector] detectIdleRDS: ${idleRds.length} detections`);\n        detections.push(...idleRds);\n        const idleCache = this.detectIdleCacheFromData(resourceData.cacheClusters);\n        console.log(`[Detector] detectIdleCache: ${idleCache.length} detections`);\n        detections.push(...idleCache);\n        const idleLbs = this.detectIdleLoadBalancersFromData(resourceData.loadBalancers);\n        console.log(`[Detector] detectIdleLoadBalancers: ${idleLbs.length} detections`);\n        detections.push(...idleLbs);\n        const overProvLambdas = this.detectOverProvisionedLambdasFromData(resourceData.lambdaFunctions);\n        console.log(`[Detector] detectOverProvisionedLambdas: ${overProvLambdas.length} detections`);\n        detections.push(...overProvLambdas);\n        const s3NoLifecycle = this.detectS3NoLifecycleFromData(resourceData.s3Buckets);\n        console.log(`[Detector] detectS3NoLifecycle: ${s3NoLifecycle.length} detections`);\n        detections.push(...s3NoLifecycle);\n        const logNoRetention = this.detectLogNoRetentionFromData(resourceData.logGroups);\n        console.log(`[Detector] detectLogNoRetention: ${logNoRetention.length} detections`);\n        detections.push(...logNoRetention);\n        const forgottenPreviews = this.detectForgottenPreviewsFromData(resourceData.autoscalingGroups);\n        console.log(`[Detector] detectForgottenPreviews: ${forgottenPreviews.length} detections`);\n        detections.push(...forgottenPreviews);\n        const overProvAsgs = this.detectOverProvisionedASGsFromData(resourceData.autoscalingGroups);\n        console.log(`[Detector] detectOverProvisionedASGs: ${overProvAsgs.length} detections`);\n        detections.push(...overProvAsgs);\n        const staleFeatureEnvs = this.detectStaleFeatureEnvsFromData(resourceData.autoscalingGroups);\n        console.log(`[Detector] detectStaleFeatureEnvs: ${staleFeatureEnvs.length} detections`);\n        detections.push(...staleFeatureEnvs);\n        const idleCiRunners = this.detectIdleCIRunnersFromData(resourceData.instances);\n        console.log(`[Detector] detectIdleCIRunners: ${idleCiRunners.length} detections`);\n        detections.push(...idleCiRunners);\n        const offHoursDev = this.detectOffHoursDevInstancesFromData(resourceData.instances);\n        console.log(`[Detector] detectOffHoursDevInstances: ${offHoursDev.length} detections`);\n        detections.push(...offHoursDev);\n        const overProvInstances = this.detectOverProvisionedInstancesFromData(resourceData.instances);\n        console.log(`[Detector] detectOverProvisionedInstances: ${overProvInstances.length} detections`);\n        detections.push(...overProvInstances);\n        // ==========================================================================\n        // QUICK-WIN OPTIMIZATIONS - Phase 1 (No migrations needed)\n        // ==========================================================================\n        const gp2Volumes = this.detectGp2VolumesFromData(resourceData.volumes);\n        console.log(`[Detector] detectGp2Volumes: ${gp2Volumes.length} detections`);\n        detections.push(...gp2Volumes);\n        const unusedLambdas = this.detectUnusedLambdasFromData(resourceData.lambdaFunctions);\n        console.log(`[Detector] detectUnusedLambdas: ${unusedLambdas.length} detections`);\n        detections.push(...unusedLambdas);\n        const orphanedSnapshots = this.detectOrphanedSnapshotsFromData(resourceData.snapshots, resourceData.volumes);\n        console.log(`[Detector] detectOrphanedSnapshots: ${orphanedSnapshots.length} detections`);\n        detections.push(...orphanedSnapshots);\n        const staticAsgs = this.detectStaticASGsFromData(resourceData.autoscalingGroups);\n        console.log(`[Detector] detectStaticASGs: ${staticAsgs.length} detections`);\n        detections.push(...staticAsgs);\n        // ==========================================================================\n        // QUICK-WIN OPTIMIZATIONS - Phase 2 (With migrations)\n        // ==========================================================================\n        const multiAzNonProd = this.detectMultiAzNonProdFromData(resourceData.rdsInstances);\n        console.log(`[Detector] detectMultiAzNonProd: ${multiAzNonProd.length} detections`);\n        detections.push(...multiAzNonProd);\n        const emptyLbs = this.detectEmptyLoadBalancersFromData(resourceData.loadBalancers);\n        console.log(`[Detector] detectEmptyLoadBalancers: ${emptyLbs.length} detections`);\n        detections.push(...emptyLbs);\n        const s3NoVersionExpiration = this.detectS3NoVersionExpirationFromData(resourceData.s3Buckets);\n        console.log(`[Detector] detectS3NoVersionExpiration: ${s3NoVersionExpiration.length} detections`);\n        detections.push(...s3NoVersionExpiration);\n        const overConfiguredTimeout = this.detectOverConfiguredTimeoutFromData(resourceData.lambdaFunctions);\n        console.log(`[Detector] detectOverConfiguredTimeout: ${overConfiguredTimeout.length} detections`);\n        detections.push(...overConfiguredTimeout);\n        // const processingDuration = performance.now() - processingStartTime\n        // console.log(`[Detector] Detection processing completed in ${processingDuration.toFixed(2)}ms`)\n        // Calculate summary\n        // const summaryStartTime = performance.now()\n        const summary = this.calculateSummary(detections);\n        // const summaryDuration = performance.now() - summaryStartTime\n        // console.log(`[Detector] Summary calculation completed in ${summaryDuration.toFixed(2)}ms`)\n        // Compute resource counts from already-fetched data (0 extra queries)\n        const resourceCounts = this.computeResourceCounts(resourceData);\n        const result = {\n            detections,\n            summary,\n            resourceCounts,\n            timestamp\n        };\n        // Cache the result\n        detectionCache = {\n            result,\n            timestamp: Date.now()\n        };\n        const totalDuration = performance.now() - detectAllStartTime;\n        console.log(`[Detector] ‚úÖ Complete: ${totalDuration.toFixed(0)}ms total | DB: ${fetchDuration.toFixed(0)}ms | ${detections.length} detections | $${summary.totalPotentialSavings.toFixed(0)}/mo savings`);\n        return result;\n    }\n    /**\n   * Batch fetch all resource tables in parallel\n   * This is the key optimization - single round-trip for all data\n   */ async batchFetchAllResources() {\n        const [instances, rdsInstances, cacheClusters, loadBalancers, lambdaFunctions, volumes, snapshots, elasticIps, s3Buckets, logGroups, autoscalingGroups] = await Promise.all([\n            this.supabase.from(\"instances\").select(\"*\"),\n            this.supabase.from(\"rds_instances\").select(\"*\"),\n            this.supabase.from(\"cache_clusters\").select(\"*\"),\n            this.supabase.from(\"load_balancers\").select(\"*\"),\n            this.supabase.from(\"lambda_functions\").select(\"*\"),\n            this.supabase.from(\"volumes\").select(\"*\"),\n            this.supabase.from(\"snapshots\").select(\"*\"),\n            this.supabase.from(\"elastic_ips\").select(\"*\"),\n            this.supabase.from(\"s3_buckets\").select(\"*\"),\n            this.supabase.from(\"log_groups\").select(\"*\"),\n            this.supabase.from(\"autoscaling_groups\").select(\"*\")\n        ]);\n        return {\n            instances: instances.data ?? [],\n            rdsInstances: rdsInstances.data ?? [],\n            cacheClusters: cacheClusters.data ?? [],\n            loadBalancers: loadBalancers.data ?? [],\n            lambdaFunctions: lambdaFunctions.data ?? [],\n            volumes: volumes.data ?? [],\n            snapshots: snapshots.data ?? [],\n            elasticIps: elasticIps.data ?? [],\n            s3Buckets: s3Buckets.data ?? [],\n            logGroups: logGroups.data ?? [],\n            autoscalingGroups: autoscalingGroups.data ?? []\n        };\n    }\n    /**\n   * Detect idle EC2 instances (IN-MEMORY version)\n   */ detectIdleInstancesFromData(instances) {\n        // Filter: running instances with CPU < 5% (prefer avg_cpu_7d, fallback to current_cpu)\n        const filtered = instances.filter((i)=>{\n            if (i.state !== \"running\") return false;\n            // Use avg_cpu_7d if available, otherwise fall back to current_cpu\n            const avg7dCpu = i.avg_cpu_7d;\n            const currentCpu = i.current_cpu;\n            const cpuValue = avg7dCpu ?? currentCpu;\n            // Need at least one CPU metric to determine if idle\n            if (cpuValue === null || cpuValue === undefined) return false;\n            return cpuValue < 5;\n        });\n        return filtered.map((instance)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.idle_instance;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(instance.instance_type);\n            // Use the same fallback logic\n            const avg7dCpu = instance.avg_cpu_7d;\n            const currentCpu = instance.current_cpu;\n            const cpuValue = avg7dCpu ?? currentCpu ?? 0;\n            let confidence = scenario.baseConfidence;\n            if (cpuValue < 2) confidence += 10;\n            if (instance.env === \"dev\" || instance.env === \"staging\") confidence += 5;\n            return this.createDetection({\n                scenarioId: \"idle_instance\",\n                resource: instance,\n                resourceType: \"instances\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost * 0.9,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    instanceType: instance.instance_type,\n                    avgCpu7d: cpuValue,\n                    launchTime: instance.launch_time\n                }\n            });\n        });\n    }\n    // Legacy async version (kept for backward compatibility)\n    async detectIdleInstances() {\n        const { data: instances, error } = await this.supabase.from(\"instances\").select(\"*\").eq(\"state\", \"running\").lt(\"avg_cpu_7d\", 5);\n        if (error || !instances) return [];\n        return this.detectIdleInstancesFromData(instances);\n    }\n    /**\n   * Detect orphaned Elastic IPs (IN-MEMORY version)\n   */ detectOrphanedEIPsFromData(eips) {\n        console.log(`[Detector] Orphaned EIPs: Checking ${eips.length} elastic IPs`);\n        // Filter: EIPs with no associated instance\n        const filtered = eips.filter((e)=>{\n            console.log(`[Detector] EIP: ${e.public_ip} | associated_instance_id: ${e.associated_instance_id}`);\n            if (e.associated_instance_id !== null) {\n                console.log(`[Detector]   ‚Üí SKIP: EIP is associated with ${e.associated_instance_id}`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Orphaned EIP detected`);\n            return true;\n        });\n        console.log(`[Detector] Orphaned EIPs: Found ${filtered.length} orphaned EIPs`);\n        return filtered.map((eip)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.orphaned_eip;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getUnattachedEIPMonthlyCost)();\n            return this.createDetection({\n                scenarioId: \"orphaned_eip\",\n                resource: eip,\n                resourceType: \"elastic_ips\",\n                nameField: \"public_ip\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: scenario.baseConfidence,\n                details: {\n                    publicIp: eip.public_ip,\n                    allocationId: eip.allocation_id,\n                    associatedWith: eip.associated_instance_id\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectOrphanedEIPs() {\n        const { data: eips, error } = await this.supabase.from(\"elastic_ips\").select(\"*\").is(\"associated_instance_id\", null);\n        if (error || !eips) return [];\n        return this.detectOrphanedEIPsFromData(eips);\n    }\n    /**\n   * Detect unattached EBS volumes (IN-MEMORY version)\n   */ detectUnattachedVolumesFromData(volumes) {\n        console.log(`[Detector] Unattached Volumes: Checking ${volumes.length} EBS volumes`);\n        // Filter: volumes with state = available\n        const filtered = volumes.filter((v)=>{\n            console.log(`[Detector] Volume: ${v.volume_id} | state: ${v.state} | size: ${v.size_gib}GB`);\n            if (v.state !== \"available\") {\n                console.log(`[Detector]   ‚Üí SKIP: Volume state is ${v.state}, not \"available\"`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Unattached volume detected`);\n            return true;\n        });\n        console.log(`[Detector] Unattached Volumes: Found ${filtered.length} unattached volumes`);\n        return filtered.map((volume)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.unattached_volume;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getVolumeMonthlyCost)(volume.volume_type, volume.size_gib);\n            let confidence = scenario.baseConfidence;\n            const daysSinceCreation = this.daysSince(volume.created_at);\n            if (daysSinceCreation > 30) confidence += 10;\n            return this.createDetection({\n                scenarioId: \"unattached_volume\",\n                resource: volume,\n                resourceType: \"volumes\",\n                nameField: \"volume_id\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    volumeId: volume.volume_id,\n                    volumeType: volume.volume_type,\n                    sizeGib: volume.size_gib,\n                    daysSinceCreation\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectUnattachedVolumes() {\n        const { data: volumes, error } = await this.supabase.from(\"volumes\").select(\"*\").eq(\"state\", \"available\");\n        if (error || !volumes) return [];\n        return this.detectUnattachedVolumesFromData(volumes);\n    }\n    /**\n   * Detect old EBS snapshots (IN-MEMORY version)\n   */ detectOldSnapshotsFromData(snapshots) {\n        console.log(`[Detector] Old Snapshots: Checking ${snapshots.length} EBS snapshots`);\n        // Filter: snapshots older than 90 days\n        const filtered = snapshots.filter((s)=>{\n            const daysOld = this.daysSince(s.created_at);\n            console.log(`[Detector] Snapshot: ${s.snapshot_id} | created_at: ${s.created_at} | days old: ${daysOld}`);\n            if (daysOld <= 90) {\n                console.log(`[Detector]   ‚Üí SKIP: Snapshot is only ${daysOld} days old (threshold: >90 days)`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Old snapshot detected (${daysOld} days)`);\n            return true;\n        });\n        console.log(`[Detector] Old Snapshots: Found ${filtered.length} old snapshots`);\n        return filtered.map((snapshot)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.old_snapshot;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getSnapshotMonthlyCost)(snapshot.size_gib);\n            const daysOld = this.daysSince(snapshot.created_at);\n            let confidence = scenario.baseConfidence;\n            if (daysOld > 180) confidence += 15;\n            if (daysOld > 365) confidence += 10;\n            return this.createDetection({\n                scenarioId: \"old_snapshot\",\n                resource: snapshot,\n                resourceType: \"snapshots\",\n                nameField: \"snapshot_id\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    snapshotId: snapshot.snapshot_id,\n                    sizeGib: snapshot.size_gib,\n                    daysOld,\n                    retentionPolicy: snapshot.retention_policy\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectOldSnapshots() {\n        const { data: snapshots, error } = await this.supabase.from(\"snapshots\").select(\"*\");\n        if (error || !snapshots) return [];\n        return this.detectOldSnapshotsFromData(snapshots);\n    }\n    /**\n   * Detect idle RDS instances (IN-MEMORY version)\n   *\n   * RELAXED CRITERIA: Detects RDS as idle if ANY of:\n   * - CPU < 15% (low utilization)\n   * - Connections <= 1 (almost no active connections)\n   * - Environment is preview/dev/staging with low activity\n   */ detectIdleRDSFromData(rdsInstances) {\n        console.log(`[Detector] RDS Idle: Checking ${rdsInstances.length} RDS instances`);\n        // Filter: available RDS with low CPU OR low connections OR non-prod with low activity\n        const filtered = rdsInstances.filter((r)=>{\n            // Get CPU value with null handling\n            const avgCpu = r.avg_cpu_7d;\n            const currentCpu = r.current_cpu;\n            const cpuValue = avgCpu ?? currentCpu;\n            // Get connections with null handling\n            const avgConnections = r.avg_connections_7d;\n            const currentConnections = r.current_connections;\n            const connectionsValue = avgConnections ?? currentConnections;\n            // Get environment\n            const env = (r.env || \"\").toLowerCase();\n            const isNonProd = env.includes(\"preview\") || env.includes(\"dev\") || env.includes(\"staging\") || env.includes(\"test\");\n            console.log(`[Detector] RDS: ${r.db_instance_id} | State: ${r.state} | CPU: ${cpuValue}% | Conn: ${connectionsValue} | Env: ${env}`);\n            if (r.state !== \"available\") {\n                console.log(`[Detector]   ‚Üí SKIP: State is ${r.state}, not \"available\"`);\n                return false;\n            }\n            // RELAXED: Use OR logic - detect if ANY condition is met\n            const isLowCpu = cpuValue !== null && cpuValue !== undefined && cpuValue < 15;\n            const isLowConnections = connectionsValue !== null && connectionsValue !== undefined && connectionsValue <= 1;\n            const isIdleNonProd = isNonProd && cpuValue !== null && cpuValue < 25 && (connectionsValue === null || connectionsValue < 5);\n            // If both metrics are null, consider it potentially idle\n            const hasNoMetrics = (cpuValue === null || cpuValue === undefined) && (connectionsValue === null || connectionsValue === undefined);\n            if (!isLowCpu && !isLowConnections && !isIdleNonProd && !hasNoMetrics) {\n                console.log(`[Detector]   ‚Üí SKIP: CPU ${cpuValue}% >= 15, Conn ${connectionsValue} > 1, not idle non-prod`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Idle RDS detected (lowCPU: ${isLowCpu}, lowConn: ${isLowConnections}, idleNonProd: ${isIdleNonProd})`);\n            return true;\n        });\n        console.log(`[Detector] RDS Idle: Found ${filtered.length} idle RDS instances`);\n        return filtered.map((rds)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.idle_rds;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getRDSMonthlyCost)(rds.instance_class);\n            // Use the same null handling\n            const avgCpu = rds.avg_cpu_7d;\n            const currentCpu = rds.current_cpu;\n            const cpuValue = avgCpu ?? currentCpu ?? 0;\n            const avgConnections = rds.avg_connections_7d;\n            const currentConnections = rds.current_connections;\n            const connectionsValue = avgConnections ?? currentConnections ?? 0;\n            let confidence = scenario.baseConfidence;\n            if (cpuValue < 1) confidence += 10;\n            if (connectionsValue === 0) confidence += 10;\n            return this.createDetection({\n                scenarioId: \"idle_rds\",\n                resource: rds,\n                resourceType: \"rds_instances\",\n                nameField: \"db_instance_id\",\n                monthlyCost,\n                potentialSavings: monthlyCost * 0.8,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    dbInstanceId: rds.db_instance_id,\n                    instanceClass: rds.instance_class,\n                    engine: rds.engine,\n                    avgCpu7d: cpuValue,\n                    avgConnections7d: connectionsValue\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectIdleRDS() {\n        const { data: rdsInstances, error } = await this.supabase.from(\"rds_instances\").select(\"*\").eq(\"state\", \"available\").lt(\"avg_cpu_7d\", 5).lt(\"avg_connections_7d\", 2);\n        if (error || !rdsInstances) return [];\n        return this.detectIdleRDSFromData(rdsInstances);\n    }\n    /**\n   * Detect idle ElastiCache clusters (IN-MEMORY version)\n   *\n   * RELAXED CRITERIA: Detects ElastiCache as idle if ANY of:\n   * - CPU < 15% (low utilization)\n   * - Connections <= 3 (very few active connections)\n   * - Environment is preview/dev/staging with low activity\n   */ detectIdleCacheFromData(clusters) {\n        console.log(`[Detector] ElastiCache Idle: Checking ${clusters.length} cache clusters`);\n        // Filter: clusters with low CPU OR low connections OR non-prod with low activity\n        const filtered = clusters.filter((c)=>{\n            // Get CPU value with null handling\n            const avgCpu = c.avg_cpu_7d;\n            const currentCpu = c.current_cpu;\n            const cpuValue = avgCpu ?? currentCpu;\n            // Get connections with null handling\n            const avgConnections = c.avg_connections_7d;\n            const currentConnections = c.current_connections;\n            const connectionsValue = avgConnections ?? currentConnections;\n            // Get environment\n            const env = (c.env || \"\").toLowerCase();\n            const isNonProd = env.includes(\"preview\") || env.includes(\"dev\") || env.includes(\"staging\") || env.includes(\"test\");\n            console.log(`[Detector] Cache: ${c.cluster_id} | CPU: ${cpuValue}% | Conn: ${connectionsValue} | Env: ${env}`);\n            // RELAXED: Use OR logic - detect if ANY condition is met\n            const isLowCpu = cpuValue !== null && cpuValue !== undefined && cpuValue < 15;\n            const isLowConnections = connectionsValue !== null && connectionsValue !== undefined && connectionsValue <= 3;\n            const isIdleNonProd = isNonProd && cpuValue !== null && cpuValue < 25 && (connectionsValue === null || connectionsValue < 10);\n            // If both metrics are null, consider it potentially idle\n            const hasNoMetrics = (cpuValue === null || cpuValue === undefined) && (connectionsValue === null || connectionsValue === undefined);\n            if (!isLowCpu && !isLowConnections && !isIdleNonProd && !hasNoMetrics) {\n                console.log(`[Detector]   ‚Üí SKIP: CPU ${cpuValue}% >= 15, Conn ${connectionsValue} > 3, not idle non-prod`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Idle cache cluster detected (lowCPU: ${isLowCpu}, lowConn: ${isLowConnections}, idleNonProd: ${isIdleNonProd})`);\n            return true;\n        });\n        console.log(`[Detector] ElastiCache Idle: Found ${filtered.length} idle cache clusters`);\n        return filtered.map((cluster)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.idle_cache;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getCacheMonthlyCost)(cluster.node_type, cluster.num_nodes);\n            // Use the same null handling\n            const avgCpu = cluster.avg_cpu_7d;\n            const currentCpu = cluster.current_cpu;\n            const cpuValue = avgCpu ?? currentCpu ?? 0;\n            const avgConnections = cluster.avg_connections_7d;\n            const currentConnections = cluster.current_connections;\n            const connectionsValue = avgConnections ?? currentConnections ?? 0;\n            let confidence = scenario.baseConfidence;\n            if (cpuValue < 1) confidence += 15;\n            if (connectionsValue === 0) confidence += 10;\n            return this.createDetection({\n                scenarioId: \"idle_cache\",\n                resource: cluster,\n                resourceType: \"cache_clusters\",\n                nameField: \"cluster_id\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    clusterId: cluster.cluster_id,\n                    nodeType: cluster.node_type,\n                    numNodes: cluster.num_nodes,\n                    engine: cluster.engine,\n                    avgCpu7d: cpuValue,\n                    avgConnections7d: connectionsValue\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectIdleCache() {\n        const { data: clusters, error } = await this.supabase.from(\"cache_clusters\").select(\"*\").lt(\"avg_cpu_7d\", 5).lt(\"avg_connections_7d\", 5);\n        if (error || !clusters) return [];\n        return this.detectIdleCacheFromData(clusters);\n    }\n    /**\n   * Detect idle Load Balancers (IN-MEMORY version)\n   */ detectIdleLoadBalancersFromData(lbs) {\n        console.log(`[Detector] Load Balancer Idle: Checking ${lbs.length} load balancers`);\n        // Filter: load balancers with avg_request_count_7d < 1000\n        const filtered = lbs.filter((lb)=>{\n            // Get request count with null handling\n            const avgRequestCount = lb.avg_request_count_7d;\n            const currentRequestCount = lb.current_request_count;\n            const requestCount = avgRequestCount ?? currentRequestCount;\n            console.log(`[Detector] LB: ${lb.name} | avg_request_count_7d: ${avgRequestCount} | current_request_count: ${currentRequestCount}`);\n            // If metrics are null, consider it idle (no activity data means likely unused)\n            const requestCheck = requestCount === null || requestCount === undefined ? true : requestCount < 1000;\n            if (!requestCheck) {\n                console.log(`[Detector]   ‚Üí SKIP: Request count ${requestCount ?? \"N/A\"} < 1000: ${requestCheck}`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Idle load balancer detected`);\n            return true;\n        });\n        console.log(`[Detector] Load Balancer Idle: Found ${filtered.length} idle load balancers`);\n        return filtered.map((lb)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.idle_load_balancer;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLoadBalancerMonthlyCost)(0.1);\n            // Use the same null handling\n            const avgRequestCount = lb.avg_request_count_7d;\n            const currentRequestCount = lb.current_request_count;\n            const requestCount = avgRequestCount ?? currentRequestCount ?? 0;\n            let confidence = scenario.baseConfidence;\n            if (requestCount < 100) confidence += 15;\n            return this.createDetection({\n                scenarioId: \"idle_load_balancer\",\n                resource: lb,\n                resourceType: \"load_balancers\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    name: lb.name,\n                    type: lb.type,\n                    env: lb.env,\n                    avgRequestCount7d: requestCount\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectIdleLoadBalancers() {\n        const { data: lbs, error } = await this.supabase.from(\"load_balancers\").select(\"*\").lt(\"avg_request_count_7d\", 1000);\n        if (error || !lbs) return [];\n        return this.detectIdleLoadBalancersFromData(lbs);\n    }\n    /**\n   * Detect over-provisioned Lambda functions (IN-MEMORY version)\n   */ detectOverProvisionedLambdasFromData(lambdas) {\n        console.log(`[Detector] Lambda Over-provisioned: Checking ${lambdas.length} Lambda functions`);\n        // Filter: functions with memory data and using < 50% of allocated memory\n        const filtered = lambdas.filter((fn)=>{\n            const avgMemory = fn.avg_memory_used_mb_7d;\n            const memoryMb = fn.memory_mb;\n            console.log(`[Detector] Lambda: ${fn.name} | memory_mb: ${memoryMb} | avg_memory_used_mb_7d: ${avgMemory}`);\n            if (!avgMemory || !memoryMb) {\n                console.log(`[Detector]   ‚Üí SKIP: Missing memory metrics (avg_memory: ${avgMemory}, memory_mb: ${memoryMb})`);\n                return false;\n            }\n            const utilizationPct = avgMemory / memoryMb * 100;\n            if (utilizationPct >= 50) {\n                console.log(`[Detector]   ‚Üí SKIP: Memory utilization ${utilizationPct.toFixed(1)}% >= 50%`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Over-provisioned Lambda (${utilizationPct.toFixed(1)}% utilization)`);\n            return true;\n        });\n        console.log(`[Detector] Lambda Over-provisioned: Found ${filtered.length} over-provisioned functions`);\n        return filtered.map((fn)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.over_provisioned_lambda;\n            const avgMemory = fn.avg_memory_used_mb_7d;\n            const memoryMb = fn.memory_mb;\n            const utilizationPct = avgMemory / memoryMb * 100;\n            // Calculate optimal memory (round up to nearest 64MB, with 1.5x safety margin)\n            const optimalMemory = Math.max(128, Math.ceil(avgMemory * 1.5 / 64) * 64);\n            // Get actual metrics from the function\n            const invocations7d = fn.invocations_7d || 0;\n            const avgDurationMs = fn.avg_duration_ms_7d || 0;\n            // Convert 7-day metrics to monthly (multiply by ~4.2857)\n            const monthlyInvocations = invocations7d * (30 / 7);\n            // Use estimated_monthly_cost from database if available, otherwise calculate\n            let monthlyCost;\n            if (fn.estimated_monthly_cost && fn.estimated_monthly_cost > 0) {\n                monthlyCost = fn.estimated_monthly_cost;\n            } else if (invocations7d > 0 && avgDurationMs > 0) {\n                // Calculate monthly cost using proper pricing function\n                monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLambdaMonthlyCost)(memoryMb, avgDurationMs, monthlyInvocations);\n            } else {\n                // Fallback: use a reasonable estimate based on memory allocation\n                // Lambda minimum cost for a function with average usage\n                const estimatedInvocationsPerMonth = 100000 // conservative estimate\n                ;\n                const estimatedAvgDuration = avgDurationMs || 100 // ms\n                ;\n                monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLambdaMonthlyCost)(memoryMb, estimatedAvgDuration, estimatedInvocationsPerMonth);\n            }\n            // Calculate optimized monthly cost with the recommended memory\n            let optimizedMonthlyCost;\n            if (invocations7d > 0 && avgDurationMs > 0) {\n                optimizedMonthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLambdaMonthlyCost)(optimalMemory, avgDurationMs, monthlyInvocations);\n            } else {\n                // Use the same estimated invocations as we used for current cost\n                const estimatedInvocationsPerMonth = monthlyInvocations > 0 ? monthlyInvocations : 100000;\n                const estimatedAvgDuration = avgDurationMs > 0 ? avgDurationMs : 100;\n                optimizedMonthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLambdaMonthlyCost)(optimalMemory, estimatedAvgDuration, estimatedInvocationsPerMonth);\n            }\n            // Potential savings is the difference between current and optimized costs\n            const potentialSavings = Math.max(0, monthlyCost - optimizedMonthlyCost);\n            let confidence = scenario.baseConfidence;\n            if (utilizationPct < 25) confidence += 10;\n            if (utilizationPct < 10) confidence += 5;\n            return this.createDetection({\n                scenarioId: \"over_provisioned_lambda\",\n                resource: fn,\n                resourceType: \"lambda_functions\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    functionName: fn.name,\n                    currentMemoryMb: memoryMb,\n                    avgMemoryUsedMb: avgMemory,\n                    utilizationPct: Math.round(utilizationPct),\n                    recommendedMemoryMb: optimalMemory,\n                    invocations7d,\n                    avgDurationMs,\n                    currentMonthlyCost: monthlyCost,\n                    optimizedMonthlyCost\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectOverProvisionedLambdas() {\n        const { data: lambdas, error } = await this.supabase.from(\"lambda_functions\").select(\"*\").not(\"avg_memory_used_mb_7d\", \"is\", null);\n        if (error || !lambdas) return [];\n        return this.detectOverProvisionedLambdasFromData(lambdas);\n    }\n    /**\n   * Detect S3 buckets without lifecycle policies (IN-MEMORY version)\n   */ detectS3NoLifecycleFromData(buckets) {\n        console.log(`[Detector] S3 No Lifecycle: Checking ${buckets.length} S3 buckets`);\n        // Filter: buckets with empty or no lifecycle policy/rules\n        const filtered = buckets.filter((b)=>{\n            // Check both lifecycle_policy and lifecycle_rules columns\n            const policy = b.lifecycle_policy;\n            const rules = b.lifecycle_rules;\n            console.log(`[Detector] S3: ${b.name} | lifecycle_policy: ${policy ? \"set\" : \"null\"} | lifecycle_rules: ${rules ? `${rules.length} rules` : \"null\"}`);\n            // Has rules in lifecycle_rules column? Skip\n            if (rules && Array.isArray(rules) && rules.length > 0) {\n                console.log(`[Detector]   ‚Üí SKIP: Has ${rules.length} lifecycle rules`);\n                return false;\n            }\n            // Has policy in lifecycle_policy column? Skip\n            if (policy && Object.keys(policy).length > 0) {\n                const policyRules = policy.rules;\n                if (policyRules && policyRules.length > 0) {\n                    console.log(`[Detector]   ‚Üí SKIP: Has lifecycle policy with ${policyRules.length} rules`);\n                    return false;\n                }\n            }\n            console.log(`[Detector]   ‚Üí MATCH: S3 bucket without lifecycle policy`);\n            return true;\n        });\n        console.log(`[Detector] S3 No Lifecycle: Found ${filtered.length} buckets without lifecycle`);\n        return filtered.map((bucket)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.s3_no_lifecycle;\n            const estimatedSizeGb = 100;\n            const monthlyCost = estimatedSizeGb * 0.023;\n            const potentialSavings = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getS3TieringSavings)(estimatedSizeGb);\n            return this.createDetection({\n                scenarioId: \"s3_no_lifecycle\",\n                resource: bucket,\n                resourceType: \"s3_buckets\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    bucketName: bucket.name,\n                    env: bucket.env,\n                    lifecyclePolicy: bucket.lifecycle_policy,\n                    recommendation: \"Add lifecycle policy to tier data to cheaper storage\"\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectS3NoLifecycle() {\n        const { data: buckets, error } = await this.supabase.from(\"s3_buckets\").select(\"*\");\n        if (error || !buckets) return [];\n        return this.detectS3NoLifecycleFromData(buckets);\n    }\n    /**\n   * Detect CloudWatch Log Groups without retention (IN-MEMORY version)\n   */ detectLogNoRetentionFromData(logGroups) {\n        console.log(`[Detector] Log No Retention: Checking ${logGroups.length} CloudWatch log groups`);\n        // Filter: log groups with no retention set (check both retention_days and retention_in_days)\n        const filtered = logGroups.filter((lg)=>{\n            console.log(`[Detector] Log Group: ${lg.name} | retention_days: ${lg.retention_days} | retention_in_days: ${lg.retention_in_days}`);\n            // Skip if retention_in_days is set (from executor)\n            if (lg.retention_in_days !== null && lg.retention_in_days !== undefined) {\n                console.log(`[Detector]   ‚Üí SKIP: Has retention_in_days set to ${lg.retention_in_days}`);\n                return false;\n            }\n            // Skip if retention_days is set (original column)\n            if (lg.retention_days !== null && lg.retention_days !== undefined) {\n                console.log(`[Detector]   ‚Üí SKIP: Has retention_days set to ${lg.retention_days}`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Log group without retention policy`);\n            return true;\n        });\n        console.log(`[Detector] Log No Retention: Found ${filtered.length} log groups without retention`);\n        return filtered.map((lg)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.log_no_retention;\n            const estimatedSizeGb = 10;\n            const currentMonthlyCost = estimatedSizeGb * 0.03;\n            const potentialSavings = currentMonthlyCost * 0.9;\n            return this.createDetection({\n                scenarioId: \"log_no_retention\",\n                resource: lg,\n                resourceType: \"log_groups\",\n                nameField: \"name\",\n                monthlyCost: currentMonthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    logGroupName: lg.name,\n                    env: lg.env,\n                    currentRetention: \"Never expires\",\n                    recommendedRetention: \"30 days\"\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectLogNoRetention() {\n        const { data: logGroups, error } = await this.supabase.from(\"log_groups\").select(\"*\").is(\"retention_days\", null);\n        if (error || !logGroups) return [];\n        return this.detectLogNoRetentionFromData(logGroups);\n    }\n    /**\n   * Detect forgotten preview environments (IN-MEMORY version)\n   * ASGs with 'preview' in name or env, with low utilization\n   */ detectForgottenPreviewsFromData(asgs) {\n        console.log(`[Detector] Forgotten Previews: Checking ${asgs.length} Auto Scaling Groups`);\n        // Filter for preview environments with low utilization\n        // Skip ASGs with desired_capacity = 0 (already terminated)\n        const filtered = asgs.filter((asg)=>{\n            const desiredCapacity = asg.desired_capacity;\n            const env = asg.env?.toLowerCase() || \"\";\n            const name = asg.name?.toLowerCase() || \"\";\n            console.log(`[Detector] ASG (Preview): ${asg.name} | env: ${env} | capacity: ${desiredCapacity} | utilization: ${asg.current_utilization}`);\n            // Skip already terminated ASGs (capacity = 0)\n            if (!desiredCapacity || desiredCapacity === 0) {\n                console.log(`[Detector]   ‚Üí SKIP: Capacity is 0 (already terminated)`);\n                return false;\n            }\n            const isPreview = env.includes(\"preview\") || name.includes(\"preview\") || name.includes(\"pr-\");\n            if (!isPreview) {\n                console.log(`[Detector]   ‚Üí SKIP: Not a preview environment`);\n                return false;\n            }\n            const isLowUtil = !asg.current_utilization || asg.current_utilization < 10;\n            if (!isLowUtil) {\n                console.log(`[Detector]   ‚Üí SKIP: Utilization ${asg.current_utilization}% >= 10%`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Forgotten preview environment`);\n            return true;\n        });\n        console.log(`[Detector] Forgotten Previews: Found ${filtered.length} forgotten preview environments`);\n        return filtered.map((asg)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.forgotten_preview;\n            const instanceCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(asg.instance_type);\n            const monthlyCost = instanceCost * asg.desired_capacity;\n            let confidence = scenario.baseConfidence;\n            const daysOld = this.daysSince(asg.created_at);\n            if (daysOld > 7) confidence += 10;\n            if (daysOld > 14) confidence += 5;\n            return this.createDetection({\n                scenarioId: \"forgotten_preview\",\n                resource: asg,\n                resourceType: \"autoscaling_groups\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    asgName: asg.name,\n                    instanceType: asg.instance_type,\n                    desiredCapacity: asg.desired_capacity,\n                    currentUtilization: asg.current_utilization || 0,\n                    daysOld\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectForgottenPreviews() {\n        const { data: asgs, error } = await this.supabase.from(\"autoscaling_groups\").select(\"*\");\n        if (error || !asgs) return [];\n        return this.detectForgottenPreviewsFromData(asgs);\n    }\n    /**\n   * Detect over-provisioned Auto Scaling Groups (IN-MEMORY version)\n   * ASGs with more capacity than needed based on utilization\n   */ detectOverProvisionedASGsFromData(asgs) {\n        console.log(`[Detector] Over-provisioned ASGs: Checking ${asgs.length} Auto Scaling Groups`);\n        // Filter: ASGs with desired_capacity > 1, low utilization, and more than min_size\n        const filtered = asgs.filter((asg)=>{\n            const desiredCapacity = asg.desired_capacity;\n            const utilization = asg.current_utilization || 0;\n            const minSize = asg.min_size;\n            console.log(`[Detector] ASG (Over-prov): ${asg.name} | capacity: ${desiredCapacity} | min_size: ${minSize} | utilization: ${utilization}%`);\n            if (desiredCapacity <= 1) {\n                console.log(`[Detector]   ‚Üí SKIP: Capacity ${desiredCapacity} <= 1`);\n                return false;\n            }\n            if (utilization >= 30) {\n                console.log(`[Detector]   ‚Üí SKIP: Utilization ${utilization}% >= 30%`);\n                return false;\n            }\n            if (desiredCapacity <= minSize) {\n                console.log(`[Detector]   ‚Üí SKIP: Capacity ${desiredCapacity} <= min_size ${minSize}`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Over-provisioned ASG`);\n            return true;\n        });\n        console.log(`[Detector] Over-provisioned ASGs: Found ${filtered.length} over-provisioned ASGs`);\n        return filtered.map((asg)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.over_provisioned_asg;\n            const utilization = asg.current_utilization || 0;\n            const desiredCapacity = asg.desired_capacity;\n            const minSize = asg.min_size;\n            const instanceCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(asg.instance_type);\n            const currentMonthlyCost = instanceCost * desiredCapacity;\n            const optimalCapacity = Math.max(minSize, Math.ceil(desiredCapacity * (utilization / 50)));\n            const savingsCapacity = desiredCapacity - optimalCapacity;\n            const potentialSavings = instanceCost * savingsCapacity;\n            let confidence = scenario.baseConfidence;\n            if (utilization < 20) confidence += 10;\n            if (utilization < 10) confidence += 10;\n            return this.createDetection({\n                scenarioId: \"over_provisioned_asg\",\n                resource: asg,\n                resourceType: \"autoscaling_groups\",\n                nameField: \"name\",\n                monthlyCost: currentMonthlyCost,\n                potentialSavings,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    asgName: asg.name,\n                    instanceType: asg.instance_type,\n                    currentCapacity: desiredCapacity,\n                    minSize: minSize,\n                    maxSize: asg.max_size,\n                    currentUtilization: utilization,\n                    recommendedCapacity: optimalCapacity\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectOverProvisionedASGs() {\n        const { data: asgs, error } = await this.supabase.from(\"autoscaling_groups\").select(\"*\").gt(\"desired_capacity\", 1);\n        if (error || !asgs) return [];\n        return this.detectOverProvisionedASGsFromData(asgs);\n    }\n    /**\n   * Detect stale feature branch environments (IN-MEMORY version)\n   * ASGs with 'feature' in name, older than 7 days with low usage\n   */ detectStaleFeatureEnvsFromData(asgs) {\n        console.log(`[Detector] Stale Feature Envs: Checking ${asgs.length} Auto Scaling Groups`);\n        // Filter for feature environments older than 7 days\n        // Skip ASGs with desired_capacity = 0 (already terminated)\n        const filtered = asgs.filter((asg)=>{\n            const desiredCapacity = asg.desired_capacity;\n            const env = asg.env?.toLowerCase() || \"\";\n            const name = asg.name?.toLowerCase() || \"\";\n            const daysOld = this.daysSince(asg.created_at);\n            console.log(`[Detector] ASG (Feature): ${asg.name} | env: ${env} | capacity: ${desiredCapacity} | days old: ${daysOld} | utilization: ${asg.current_utilization}`);\n            // Skip already terminated ASGs (capacity = 0)\n            if (!desiredCapacity || desiredCapacity === 0) {\n                console.log(`[Detector]   ‚Üí SKIP: Capacity is 0 (already terminated)`);\n                return false;\n            }\n            const isFeature = env.includes(\"feature\") || name.includes(\"feature\") || name.includes(\"feat-\");\n            if (!isFeature) {\n                console.log(`[Detector]   ‚Üí SKIP: Not a feature branch environment`);\n                return false;\n            }\n            if (daysOld <= 7) {\n                console.log(`[Detector]   ‚Üí SKIP: Only ${daysOld} days old (threshold: >7 days)`);\n                return false;\n            }\n            const isLowUtil = !asg.current_utilization || asg.current_utilization < 20;\n            if (!isLowUtil) {\n                console.log(`[Detector]   ‚Üí SKIP: Utilization ${asg.current_utilization}% >= 20%`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Stale feature branch environment`);\n            return true;\n        });\n        console.log(`[Detector] Stale Feature Envs: Found ${filtered.length} stale feature environments`);\n        return filtered.map((asg)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.stale_feature_env;\n            const instanceCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(asg.instance_type);\n            const monthlyCost = instanceCost * asg.desired_capacity;\n            const daysOld = this.daysSince(asg.created_at);\n            let confidence = scenario.baseConfidence;\n            if (daysOld > 14) confidence += 10;\n            if (daysOld > 30) confidence += 5;\n            return this.createDetection({\n                scenarioId: \"stale_feature_env\",\n                resource: asg,\n                resourceType: \"autoscaling_groups\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    asgName: asg.name,\n                    instanceType: asg.instance_type,\n                    desiredCapacity: asg.desired_capacity,\n                    currentUtilization: asg.current_utilization || 0,\n                    daysOld,\n                    recommendation: \"Feature branch may be abandoned - consider cleanup\"\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectStaleFeatureEnvs() {\n        const { data: asgs, error } = await this.supabase.from(\"autoscaling_groups\").select(\"*\");\n        if (error || !asgs) return [];\n        return this.detectStaleFeatureEnvsFromData(asgs);\n    }\n    /**\n   * Detect idle CI runners (IN-MEMORY version)\n   * Instances tagged as CI runners that are idle\n   */ detectIdleCIRunnersFromData(instances) {\n        // First filter: running instances with avg_cpu_7d < 5\n        const lowCpuRunning = instances.filter((i)=>i.state === \"running\" && i.avg_cpu_7d < 5);\n        // Then filter for CI runners based on tags or name\n        const filtered = lowCpuRunning.filter((instance)=>{\n            const name = (instance.name || \"\").toLowerCase();\n            const tags = instance.tags || {};\n            const tagValues = Object.values(tags).map((v)=>String(v).toLowerCase());\n            const tagKeys = Object.keys(tags).map((k)=>k.toLowerCase());\n            const isCI = name.includes(\"ci\") || name.includes(\"runner\") || name.includes(\"jenkins\") || name.includes(\"gitlab-runner\") || name.includes(\"github-actions\") || tagKeys.includes(\"ci\") || tagKeys.includes(\"runner\") || tagValues.some((v)=>v.includes(\"ci\") || v.includes(\"runner\") || v.includes(\"build\"));\n            return isCI;\n        });\n        return filtered.map((instance)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.idle_ci_runner;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(instance.instance_type);\n            let confidence = scenario.baseConfidence;\n            if (instance.avg_cpu_7d < 2) confidence += 5;\n            return this.createDetection({\n                scenarioId: \"idle_ci_runner\",\n                resource: instance,\n                resourceType: \"instances\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    instanceName: instance.name,\n                    instanceType: instance.instance_type,\n                    avgCpu7d: instance.avg_cpu_7d,\n                    tags: instance.tags,\n                    recommendation: \"CI runner appears idle - terminate if job completed\"\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectIdleCIRunners() {\n        const { data: instances, error } = await this.supabase.from(\"instances\").select(\"*\").eq(\"state\", \"running\").lt(\"avg_cpu_7d\", 5);\n        if (error || !instances) return [];\n        return this.detectIdleCIRunnersFromData(instances);\n    }\n    /**\n   * Detect dev instances running during off-hours (IN-MEMORY version)\n   * Dev instances running on weekends or late night\n   */ detectOffHoursDevInstancesFromData(instances) {\n        // Check if current time is off-hours (weekend or outside 7am-7pm)\n        const now = new Date();\n        const dayOfWeek = now.getDay();\n        const hour = now.getHours();\n        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n        const isOffHours = hour < 7 || hour > 19;\n        // Only run this detection during off-hours\n        if (!isWeekend && !isOffHours) {\n            return [];\n        }\n        // Filter: running dev instances\n        const filtered = instances.filter((i)=>i.state === \"running\" && i.env === \"dev\");\n        return filtered.map((instance)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.off_hours_dev;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(instance.instance_type);\n            const offHoursSavings = monthlyCost * 0.6;\n            let confidence = scenario.baseConfidence;\n            if (isWeekend) confidence += 10;\n            if (instance.avg_cpu_7d < 5) confidence += 5;\n            return this.createDetection({\n                scenarioId: \"off_hours_dev\",\n                resource: instance,\n                resourceType: \"instances\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: offHoursSavings,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    instanceName: instance.name,\n                    instanceType: instance.instance_type,\n                    avgCpu7d: instance.avg_cpu_7d,\n                    isWeekend,\n                    currentHour: hour,\n                    recommendation: \"Stop dev instances during off-hours to save costs\"\n                }\n            });\n        });\n    }\n    // Legacy async version\n    async detectOffHoursDevInstances() {\n        const now = new Date();\n        const dayOfWeek = now.getDay();\n        const hour = now.getHours();\n        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n        const isOffHours = hour < 7 || hour > 19;\n        if (!isWeekend && !isOffHours) {\n            return [];\n        }\n        const { data: instances, error } = await this.supabase.from(\"instances\").select(\"*\").eq(\"state\", \"running\").eq(\"env\", \"dev\");\n        if (error || !instances) return [];\n        return this.detectOffHoursDevInstancesFromData(instances);\n    }\n    /**\n   * Detect over-provisioned EC2 instances (IN-MEMORY version)\n   * Instances with low CPU and memory utilization that can be downsized\n   */ detectOverProvisionedInstancesFromData(instances) {\n        // Debug: Log all running instances and their metrics\n        const runningInstances = instances.filter((i)=>i.state === \"running\");\n        console.log(`[Detector] EC2 Rightsizing: Checking ${runningInstances.length} running instances out of ${instances.length} total`);\n        // Filter: running instances with low utilization that can be downsized\n        // - CPU < 30% (prefer avg_cpu_7d, fallback to current_cpu)\n        // - Memory < 40% (prefer current_memory, fallback to check if we have any metric)\n        // - Instance type has a smaller option available\n        // - Exclude instances already flagged as idle (CPU < 5%)\n        const filtered = instances.filter((i)=>{\n            if (i.state !== \"running\") return false;\n            // Use avg_cpu_7d if available, otherwise fall back to current_cpu\n            const avg7dCpu = i.avg_cpu_7d;\n            const currentCpu = i.current_cpu;\n            const cpuValue = avg7dCpu ?? currentCpu ?? null;\n            // Use current_memory if available\n            const currentMemory = i.current_memory;\n            const instanceType = i.instance_type;\n            const smallerType = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getRecommendedSmallerInstance)(instanceType);\n            // Debug logging for each instance with raw values\n            console.log(`[Detector] EC2 Rightsizing: ${i.name} | Type: ${instanceType} | avg_cpu_7d: ${avg7dCpu} | current_cpu: ${currentCpu} | current_memory: ${currentMemory} | Smaller: ${smallerType || \"NONE\"}`);\n            // Skip if no CPU metric available at all\n            if (cpuValue === null) {\n                console.log(`[Detector]   ‚Üí SKIP: No CPU metric available (avg_cpu_7d and current_cpu both null)`);\n                return false;\n            }\n            // Skip if already idle (will be caught by idle detection)\n            if (cpuValue < 5) {\n                console.log(`[Detector]   ‚Üí SKIP: CPU too low (${cpuValue}% < 5%), will use idle detection`);\n                return false;\n            }\n            // Check if utilization is low enough to warrant rightsizing\n            const lowCpu = cpuValue < 30;\n            // If memory is null, only check CPU (more lenient check)\n            const lowMemory = currentMemory === null || currentMemory < 40;\n            // Both CPU must be low, and memory either unavailable or low\n            if (!lowCpu || !lowMemory) {\n                console.log(`[Detector]   ‚Üí SKIP: Utilization not low enough (CPU ${cpuValue}% < 30: ${lowCpu}, Mem ${currentMemory ?? \"N/A\"}% < 40: ${lowMemory})`);\n                return false;\n            }\n            // Must have a smaller instance type available\n            if (!smallerType) {\n                console.log(`[Detector]   ‚Üí SKIP: No smaller instance type available for ${instanceType}`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Will recommend downsizing to ${smallerType}`);\n            return true;\n        });\n        console.log(`[Detector] EC2 Rightsizing: Found ${filtered.length} instances to rightsize`);\n        return filtered.map((instance)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.over_provisioned_instance;\n            const instanceType = instance.instance_type;\n            // Use the same fallback logic as filtering\n            const avg7dCpu = instance.avg_cpu_7d;\n            const currentCpu = instance.current_cpu;\n            const cpuValue = avg7dCpu ?? currentCpu ?? 0;\n            const currentMemory = instance.current_memory ?? 0;\n            // Get current and recommended instance details\n            const currentSpecs = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2InstanceSpecs)(instanceType);\n            const recommendedType = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getRecommendedSmallerInstance)(instanceType);\n            const recommendedSpecs = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2InstanceSpecs)(recommendedType);\n            // Calculate costs\n            const currentMonthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(instanceType);\n            const recommendedMonthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(recommendedType);\n            const potentialSavings = currentMonthlyCost - recommendedMonthlyCost;\n            // Adjust confidence based on how underutilized the instance is\n            let confidence = scenario.baseConfidence;\n            if (cpuValue < 15) confidence += 10;\n            if (currentMemory < 25) confidence += 5;\n            if (instance.env === \"dev\" || instance.env === \"staging\") confidence += 5;\n            return this.createDetection({\n                scenarioId: \"over_provisioned_instance\",\n                resource: instance,\n                resourceType: \"instances\",\n                nameField: \"name\",\n                monthlyCost: currentMonthlyCost,\n                potentialSavings,\n                confidence: Math.min(confidence, 100),\n                details: {\n                    instanceName: instance.name,\n                    instanceId: instance.instance_id,\n                    currentInstanceType: instanceType,\n                    recommendedInstanceType: recommendedType,\n                    currentVcpu: currentSpecs?.vcpu,\n                    currentMemoryGb: currentSpecs?.memoryGb,\n                    recommendedVcpu: recommendedSpecs?.vcpu,\n                    recommendedMemoryGb: recommendedSpecs?.memoryGb,\n                    avgCpu7d: cpuValue,\n                    currentMemoryPct: currentMemory,\n                    currentMonthlyCost,\n                    recommendedMonthlyCost,\n                    recommendation: `Downsize from ${instanceType} to ${recommendedType}`\n                }\n            });\n        });\n    }\n    // ============================================================================\n    // QUICK-WIN OPTIMIZATIONS - Phase 1 (No migrations needed)\n    // ============================================================================\n    /**\n   * Detect GP2 volumes that should be upgraded to GP3 (IN-MEMORY version)\n   * GP3 offers ~20% cost savings with better baseline performance\n   */ detectGp2VolumesFromData(volumes) {\n        console.log(`[Detector] GP2 Volumes: Checking ${volumes.length} EBS volumes`);\n        // Filter: volumes with volume_type = 'gp2' and not deleted\n        const filtered = volumes.filter((v)=>{\n            const volumeType = v.volume_type;\n            const state = v.state;\n            console.log(`[Detector] Volume: ${v.volume_id} | type: ${volumeType} | state: ${state}`);\n            if (state === \"deleted\") {\n                console.log(`[Detector]   ‚Üí SKIP: Volume is deleted`);\n                return false;\n            }\n            if (volumeType !== \"gp2\") {\n                console.log(`[Detector]   ‚Üí SKIP: Volume type is ${volumeType}, not gp2`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: GP2 volume detected`);\n            return true;\n        });\n        console.log(`[Detector] GP2 Volumes: Found ${filtered.length} gp2 volumes to upgrade`);\n        return filtered.map((volume)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.gp2_volume;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getVolumeMonthlyCost)(\"gp2\", volume.size_gib);\n            // GP3 is ~20% cheaper than GP2\n            const gp3Cost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getVolumeMonthlyCost)(\"gp3\", volume.size_gib);\n            const potentialSavings = monthlyCost - gp3Cost;\n            return this.createDetection({\n                scenarioId: \"gp2_volume\",\n                resource: volume,\n                resourceType: \"volumes\",\n                nameField: \"volume_id\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    volumeId: volume.volume_id,\n                    currentType: \"gp2\",\n                    recommendedType: \"gp3\",\n                    sizeGib: volume.size_gib,\n                    currentMonthlyCost: monthlyCost,\n                    projectedMonthlyCost: gp3Cost\n                }\n            });\n        });\n    }\n    /**\n   * Detect unused Lambda functions (IN-MEMORY version)\n   * Functions with zero invocations in the last 7 days\n   */ detectUnusedLambdasFromData(lambdas) {\n        console.log(`[Detector] Unused Lambdas: Checking ${lambdas.length} Lambda functions`);\n        // Filter: functions with invocations_7d = 0 or null\n        const filtered = lambdas.filter((fn)=>{\n            const invocations = fn.invocations_7d;\n            console.log(`[Detector] Lambda: ${fn.name} | invocations_7d: ${invocations}`);\n            if (invocations !== null && invocations !== undefined && invocations > 0) {\n                console.log(`[Detector]   ‚Üí SKIP: Has ${invocations} invocations in 7 days`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Unused Lambda detected`);\n            return true;\n        });\n        console.log(`[Detector] Unused Lambdas: Found ${filtered.length} unused Lambda functions`);\n        return filtered.map((fn)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.unused_lambda;\n            // Estimate cost based on memory allocation (even unused functions have storage costs)\n            const memoryMb = fn.memory_mb || 128;\n            const estimatedMonitoringCost = 0.50 // CloudWatch Logs/metrics overhead\n            ;\n            const monthlyCost = estimatedMonitoringCost;\n            return this.createDetection({\n                scenarioId: \"unused_lambda\",\n                resource: fn,\n                resourceType: \"lambda_functions\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: scenario.baseConfidence,\n                details: {\n                    functionName: fn.name,\n                    memoryMb,\n                    invocations7d: 0,\n                    runtime: fn.runtime,\n                    lastModified: fn.updated_at\n                }\n            });\n        });\n    }\n    /**\n   * Detect orphaned snapshots (IN-MEMORY version)\n   * Snapshots whose source volume no longer exists\n   */ detectOrphanedSnapshotsFromData(snapshots, volumes) {\n        console.log(`[Detector] Orphaned Snapshots: Checking ${snapshots.length} snapshots against ${volumes.length} volumes`);\n        // Build a set of all existing volume IDs (not deleted)\n        const existingVolumeIds = new Set(volumes.filter((v)=>v.state !== \"deleted\").map((v)=>v.volume_id));\n        console.log(`[Detector] Orphaned Snapshots: ${existingVolumeIds.size} active volumes found`);\n        // Filter: snapshots whose source_volume_id doesn't exist\n        const filtered = snapshots.filter((s)=>{\n            const sourceVolumeId = s.source_volume_id;\n            console.log(`[Detector] Snapshot: ${s.snapshot_id} | source_volume_id: ${sourceVolumeId}`);\n            // If no source volume ID, can't determine if orphaned\n            if (!sourceVolumeId) {\n                console.log(`[Detector]   ‚Üí SKIP: No source volume ID`);\n                return false;\n            }\n            // Check if the source volume still exists\n            if (existingVolumeIds.has(sourceVolumeId)) {\n                console.log(`[Detector]   ‚Üí SKIP: Source volume ${sourceVolumeId} still exists`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Orphaned snapshot (volume ${sourceVolumeId} no longer exists)`);\n            return true;\n        });\n        console.log(`[Detector] Orphaned Snapshots: Found ${filtered.length} orphaned snapshots`);\n        return filtered.map((snapshot)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.orphaned_snapshot;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getSnapshotMonthlyCost)(snapshot.size_gib);\n            return this.createDetection({\n                scenarioId: \"orphaned_snapshot\",\n                resource: snapshot,\n                resourceType: \"snapshots\",\n                nameField: \"snapshot_id\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: scenario.baseConfidence,\n                details: {\n                    snapshotId: snapshot.snapshot_id,\n                    sourceVolumeId: snapshot.source_volume_id,\n                    sizeGib: snapshot.size_gib,\n                    createdAt: snapshot.created_at,\n                    daysOld: this.daysSince(snapshot.created_at)\n                }\n            });\n        });\n    }\n    /**\n   * Detect static ASGs (IN-MEMORY version)\n   * ASGs with min_size = max_size = desired_capacity > 1 (not actually scaling)\n   */ detectStaticASGsFromData(asgs) {\n        console.log(`[Detector] Static ASGs: Checking ${asgs.length} Auto Scaling Groups`);\n        // Filter: ASGs where min = max = desired and desired > 1\n        const filtered = asgs.filter((asg)=>{\n            const minSize = asg.min_size;\n            const maxSize = asg.max_size;\n            const desiredCapacity = asg.desired_capacity;\n            console.log(`[Detector] ASG: ${asg.name} | min: ${minSize} | max: ${maxSize} | desired: ${desiredCapacity}`);\n            // Skip terminated ASGs\n            if (desiredCapacity === 0) {\n                console.log(`[Detector]   ‚Üí SKIP: ASG is terminated (capacity = 0)`);\n                return false;\n            }\n            // Check if static (all values equal)\n            if (minSize !== maxSize || maxSize !== desiredCapacity) {\n                console.log(`[Detector]   ‚Üí SKIP: ASG has dynamic scaling (min ‚â† max or max ‚â† desired)`);\n                return false;\n            }\n            // Only flag if desired > 1 (single instance ASGs might be intentional)\n            if (desiredCapacity <= 1) {\n                console.log(`[Detector]   ‚Üí SKIP: Single instance ASG (may be intentional)`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Static ASG detected (min = max = desired = ${desiredCapacity})`);\n            return true;\n        });\n        console.log(`[Detector] Static ASGs: Found ${filtered.length} static ASGs`);\n        return filtered.map((asg)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.static_asg;\n            const instanceCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getEC2MonthlyCost)(asg.instance_type);\n            const desiredCapacity = asg.desired_capacity;\n            const monthlyCost = instanceCost * desiredCapacity;\n            // Potential savings from enabling scaling (estimate 30% reduction)\n            const potentialSavings = monthlyCost * 0.3;\n            return this.createDetection({\n                scenarioId: \"static_asg\",\n                resource: asg,\n                resourceType: \"autoscaling_groups\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    asgName: asg.name,\n                    instanceType: asg.instance_type,\n                    currentCapacity: desiredCapacity,\n                    minSize: asg.min_size,\n                    maxSize: asg.max_size,\n                    recommendedMinSize: 1,\n                    recommendedMaxSize: desiredCapacity * 2,\n                    recommendation: \"Enable dynamic scaling to optimize costs based on demand\"\n                }\n            });\n        });\n    }\n    // ============================================================================\n    // QUICK-WIN OPTIMIZATIONS - Phase 2 (With migrations)\n    // ============================================================================\n    /**\n   * Detect Multi-AZ enabled on non-production RDS instances (IN-MEMORY version)\n   * Multi-AZ doubles the cost and is unnecessary for dev/staging/test environments\n   */ detectMultiAzNonProdFromData(rdsInstances) {\n        console.log(`[Detector] Multi-AZ Non-Prod: Checking ${rdsInstances.length} RDS instances`);\n        const nonProdEnvs = [\n            \"dev\",\n            \"staging\",\n            \"test\",\n            \"preview\",\n            \"development\",\n            \"qa\"\n        ];\n        // Filter: RDS with multi_az = true and env in non-prod list\n        const filtered = rdsInstances.filter((r)=>{\n            const multiAz = r.multi_az;\n            const env = (r.env || \"\").toLowerCase();\n            console.log(`[Detector] RDS: ${r.db_instance_id} | multi_az: ${multiAz} | env: ${env}`);\n            // If multi_az column doesn't exist or is false, skip\n            if (multiAz !== true) {\n                console.log(`[Detector]   ‚Üí SKIP: Multi-AZ not enabled`);\n                return false;\n            }\n            // Check if non-production environment\n            const isNonProd = nonProdEnvs.some((e)=>env.includes(e));\n            if (!isNonProd) {\n                console.log(`[Detector]   ‚Üí SKIP: Production environment (${env})`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Multi-AZ on non-prod RDS detected`);\n            return true;\n        });\n        console.log(`[Detector] Multi-AZ Non-Prod: Found ${filtered.length} instances`);\n        return filtered.map((rds)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.multi_az_non_prod;\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getRDSMonthlyCost)(rds.instance_class);\n            // Multi-AZ roughly doubles the cost\n            const potentialSavings = monthlyCost * 0.5;\n            return this.createDetection({\n                scenarioId: \"multi_az_non_prod\",\n                resource: rds,\n                resourceType: \"rds_instances\",\n                nameField: \"db_instance_id\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    dbInstanceId: rds.db_instance_id,\n                    instanceClass: rds.instance_class,\n                    engine: rds.engine,\n                    env: rds.env,\n                    multiAz: true,\n                    recommendation: \"Disable Multi-AZ for non-production workloads\"\n                }\n            });\n        });\n    }\n    /**\n   * Detect empty Load Balancers (IN-MEMORY version)\n   * Load balancers with target_count = 0 or healthy_target_count = 0\n   */ detectEmptyLoadBalancersFromData(lbs) {\n        console.log(`[Detector] Empty Load Balancers: Checking ${lbs.length} load balancers`);\n        // Filter: LBs with target_count = 0\n        const filtered = lbs.filter((lb)=>{\n            const targetCount = lb.target_count;\n            const healthyTargetCount = lb.healthy_target_count;\n            console.log(`[Detector] LB: ${lb.name} | target_count: ${targetCount} | healthy_target_count: ${healthyTargetCount}`);\n            // If target_count column exists and is 0, it's empty\n            if (targetCount !== null && targetCount !== undefined && targetCount === 0) {\n                console.log(`[Detector]   ‚Üí MATCH: Empty LB (target_count = 0)`);\n                return true;\n            }\n            // If healthy_target_count exists and is 0 (but target_count might be > 0)\n            if (healthyTargetCount !== null && healthyTargetCount !== undefined && healthyTargetCount === 0 && targetCount !== null && targetCount > 0) {\n                console.log(`[Detector]   ‚Üí MATCH: LB with no healthy targets`);\n                return true;\n            }\n            console.log(`[Detector]   ‚Üí SKIP: LB has targets`);\n            return false;\n        });\n        console.log(`[Detector] Empty Load Balancers: Found ${filtered.length} empty LBs`);\n        return filtered.map((lb)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.empty_load_balancer;\n            // Base ALB cost is ~$16/mo + LCU charges\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLoadBalancerMonthlyCost)(0);\n            return this.createDetection({\n                scenarioId: \"empty_load_balancer\",\n                resource: lb,\n                resourceType: \"load_balancers\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings: monthlyCost,\n                confidence: scenario.baseConfidence,\n                details: {\n                    name: lb.name,\n                    type: lb.type,\n                    targetCount: lb.target_count ?? \"unknown\",\n                    healthyTargetCount: lb.healthy_target_count ?? \"unknown\",\n                    recommendation: \"Delete load balancer or register healthy targets\"\n                }\n            });\n        });\n    }\n    /**\n   * Detect S3 buckets with versioning but no noncurrent version expiration (IN-MEMORY version)\n   * Versioned buckets without expiration accumulate old versions indefinitely\n   */ detectS3NoVersionExpirationFromData(buckets) {\n        console.log(`[Detector] S3 No Version Expiration: Checking ${buckets.length} S3 buckets`);\n        // Filter: versioned buckets without noncurrent version expiration\n        const filtered = buckets.filter((b)=>{\n            const versioningEnabled = b.versioning_enabled;\n            const lifecycleRules = b.lifecycle_rules;\n            console.log(`[Detector] S3: ${b.name} | versioning_enabled: ${versioningEnabled} | lifecycle_rules: ${lifecycleRules?.length ?? 0}`);\n            // If versioning not enabled, skip (nothing to expire)\n            if (versioningEnabled !== true) {\n                console.log(`[Detector]   ‚Üí SKIP: Versioning not enabled`);\n                return false;\n            }\n            // Check if any lifecycle rule has noncurrent_version_expiration\n            if (lifecycleRules && Array.isArray(lifecycleRules)) {\n                const hasNoncurrentExpiration = lifecycleRules.some((rule)=>{\n                    const r = rule;\n                    return r.noncurrent_version_expiration || r.NoncurrentVersionExpiration;\n                });\n                if (hasNoncurrentExpiration) {\n                    console.log(`[Detector]   ‚Üí SKIP: Has noncurrent version expiration rule`);\n                    return false;\n                }\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Versioned bucket without noncurrent version expiration`);\n            return true;\n        });\n        console.log(`[Detector] S3 No Version Expiration: Found ${filtered.length} buckets`);\n        return filtered.map((bucket)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.s3_no_version_expiration;\n            // Estimate based on typical version accumulation\n            const estimatedVersionStorageGb = 50;\n            const monthlyCost = estimatedVersionStorageGb * 0.023;\n            const potentialSavings = monthlyCost * 0.7 // 70% savings from expiring old versions\n            ;\n            return this.createDetection({\n                scenarioId: \"s3_no_version_expiration\",\n                resource: bucket,\n                resourceType: \"s3_buckets\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    bucketName: bucket.name,\n                    versioningEnabled: true,\n                    hasNoncurrentExpiration: false,\n                    recommendation: \"Add lifecycle rule to expire noncurrent versions after 30 days\"\n                }\n            });\n        });\n    }\n    /**\n   * Detect Lambda functions with over-configured timeout (IN-MEMORY version)\n   * Functions with timeout >> actual duration\n   */ detectOverConfiguredTimeoutFromData(lambdas) {\n        console.log(`[Detector] Over-Configured Timeout: Checking ${lambdas.length} Lambda functions`);\n        // Filter: functions where timeout is 3x+ the actual avg duration\n        const filtered = lambdas.filter((fn)=>{\n            const timeoutSeconds = fn.timeout_seconds || 30;\n            const avgDurationMs = fn.avg_duration_ms_7d;\n            console.log(`[Detector] Lambda: ${fn.name} | timeout: ${timeoutSeconds}s | avg_duration_ms_7d: ${avgDurationMs}`);\n            // Need duration data to compare\n            if (avgDurationMs === null || avgDurationMs === undefined || avgDurationMs === 0) {\n                console.log(`[Detector]   ‚Üí SKIP: No duration data`);\n                return false;\n            }\n            // Convert to same units (seconds)\n            const avgDurationSeconds = avgDurationMs / 1000;\n            // Flag if timeout is 3x or more the actual duration\n            if (timeoutSeconds < avgDurationSeconds * 3) {\n                console.log(`[Detector]   ‚Üí SKIP: Timeout ${timeoutSeconds}s is reasonable for ${avgDurationSeconds.toFixed(1)}s avg duration`);\n                return false;\n            }\n            // Also skip if timeout is already small (< 10s)\n            if (timeoutSeconds < 10) {\n                console.log(`[Detector]   ‚Üí SKIP: Timeout already optimized (< 10s)`);\n                return false;\n            }\n            console.log(`[Detector]   ‚Üí MATCH: Timeout ${timeoutSeconds}s >> avg duration ${avgDurationSeconds.toFixed(1)}s`);\n            return true;\n        });\n        console.log(`[Detector] Over-Configured Timeout: Found ${filtered.length} functions`);\n        return filtered.map((fn)=>{\n            const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS.over_configured_lambda_timeout;\n            const memoryMb = fn.memory_mb || 128;\n            const timeoutSeconds = fn.timeout_seconds || 30;\n            const avgDurationMs = fn.avg_duration_ms_7d || 0;\n            const invocations7d = fn.invocations_7d || 0;\n            // Calculate recommended timeout (2x avg duration, rounded up, min 3s)\n            const recommendedTimeout = Math.max(3, Math.ceil(avgDurationMs / 1000 * 2));\n            // Lambda billing is per 1ms of execution, but timeout itself doesn't directly cost\n            // However, over-configured timeout can lead to runaway costs if functions hang\n            const monthlyCost = (0,_lib_utils_pricing__WEBPACK_IMPORTED_MODULE_1__.getLambdaMonthlyCost)(memoryMb, avgDurationMs, invocations7d * (30 / 7));\n            const potentialSavings = monthlyCost * 0.1 // Indirect savings from better resource management\n            ;\n            return this.createDetection({\n                scenarioId: \"over_configured_lambda_timeout\",\n                resource: fn,\n                resourceType: \"lambda_functions\",\n                nameField: \"name\",\n                monthlyCost,\n                potentialSavings,\n                confidence: scenario.baseConfidence,\n                details: {\n                    functionName: fn.name,\n                    currentTimeout: timeoutSeconds,\n                    avgDurationMs: avgDurationMs,\n                    recommendedTimeout,\n                    invocations7d,\n                    recommendation: `Reduce timeout from ${timeoutSeconds}s to ${recommendedTimeout}s`\n                }\n            });\n        });\n    }\n    /**\n   * Helper to create a detection object\n   */ createDetection({ scenarioId, resource, resourceType, nameField, monthlyCost, potentialSavings, confidence, details }) {\n        const scenario = _scenarios__WEBPACK_IMPORTED_MODULE_0__.WASTE_SCENARIOS[scenarioId];\n        const canAutoOptimize = scenario.mode === 2 && !resource.optimization_policy_locked;\n        return {\n            id: `${scenarioId}-${resource.id}`,\n            scenarioId,\n            scenario,\n            // Flattened scenario properties for hooks compatibility\n            scenarioName: scenario.name,\n            mode: scenario.mode,\n            action: scenario.action,\n            resourceId: String(resource.id),\n            resourceType,\n            resourceName: String(resource[nameField] || resource.id),\n            accountId: String(resource.account_id || \"\"),\n            region: String(resource.region || \"\"),\n            env: String(resource.env || \"unknown\"),\n            confidence,\n            monthlyCost,\n            potentialSavings,\n            details,\n            canAutoOptimize,\n            optimizationPolicyLocked: Boolean(resource.optimization_policy_locked),\n            createdAt: new Date().toISOString()\n        };\n    }\n    /**\n   * Compute resource counts from pre-fetched data (0 extra queries)\n   */ computeResourceCounts(resourceData) {\n        const counts = {\n            instances: resourceData.instances.length,\n            rdsInstances: resourceData.rdsInstances.length,\n            cacheClusters: resourceData.cacheClusters.length,\n            loadBalancers: resourceData.loadBalancers.length,\n            lambdaFunctions: resourceData.lambdaFunctions.length,\n            volumes: resourceData.volumes.length,\n            snapshots: resourceData.snapshots.length,\n            elasticIps: resourceData.elasticIps.length,\n            s3Buckets: resourceData.s3Buckets.length,\n            logGroups: resourceData.logGroups.length,\n            autoscalingGroups: resourceData.autoscalingGroups.length,\n            total: 0\n        };\n        counts.total = Object.values(counts).reduce((sum, val)=>sum + val, 0);\n        return counts;\n    }\n    /**\n   * Calculate summary statistics\n   */ calculateSummary(detections) {\n        const summary = {\n            totalResources: 0,\n            wasteDetected: detections.length,\n            totalMonthlyCost: 0,\n            totalPotentialSavings: 0,\n            autoOptimizableSavings: 0,\n            byScenario: {},\n            bySeverity: {\n                high: 0,\n                medium: 0,\n                low: 0\n            }\n        };\n        for (const detection of detections){\n            summary.totalMonthlyCost += detection.monthlyCost;\n            summary.totalPotentialSavings += detection.potentialSavings;\n            if (detection.canAutoOptimize) {\n                summary.autoOptimizableSavings += detection.potentialSavings;\n            }\n            // Count by scenario\n            summary.byScenario[detection.scenarioId] = (summary.byScenario[detection.scenarioId] || 0) + 1;\n            // Count by severity\n            summary.bySeverity[detection.scenario.severity]++;\n        }\n        return summary;\n    }\n    /**\n   * Calculate days since a date\n   */ daysSince(dateString) {\n        const date = new Date(dateString);\n        const now = new Date();\n        const diffMs = now.getTime() - date.getTime();\n        return Math.floor(diffMs / (1000 * 60 * 60 * 24));\n    }\n}\n/**\n * Create a detector instance from connection details\n */ function createDetector(supabaseUrl, supabaseKey) {\n    return new WasteDetector(supabaseUrl, supabaseKey);\n}\n/**\n * Clear the detection cache (useful for forcing a fresh detection)\n */ function clearDetectionCache() {\n    detectionCache = null;\n// console.log(\"[Detector] Cache cleared\")\n}\n/**\n * Get cache status for debugging\n */ function getCacheStatus() {\n    if (!detectionCache) {\n        return {\n            cached: false,\n            ageMs: null\n        };\n    }\n    return {\n        cached: true,\n        ageMs: Date.now() - detectionCache.timestamp\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cyI6WyJ3ZWJwYWNrOi8vYWdlbnRpYy1haS1wbGF0Zm9ybS8uL2xpYi9hZ2VudC9kZXRlY3Rvci50cz8zYWJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2FzdGUgRGV0ZWN0aW9uIEVuZ2luZVxuICpcbiAqIENvcmUgZGV0ZWN0aW9uIGxvZ2ljIHRoYXQgYW5hbHl6ZXMgcmVzb3VyY2VzIGZyb20gU3VwYWJhc2VcbiAqIGFuZCBpZGVudGlmaWVzIHdhc3RlIHNjZW5hcmlvcyB3aXRoIGNvbmZpZGVuY2Ugc2NvcmluZy5cbiAqXG4gKiBPUFRJTUlaRUQ6IFVzZXMgYmF0Y2ggZmV0Y2hpbmcgYW5kIGluLW1lbW9yeSBwcm9jZXNzaW5nXG4gKiB0byByZWR1Y2UgZGF0YWJhc2UgcXVlcmllcyBmcm9tIDE1KyB0byAxMSBwYXJhbGxlbCBxdWVyaWVzLlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCJcbmltcG9ydCB7XG4gIFdhc3RlU2NlbmFyaW8sXG4gIFdhc3RlU2NlbmFyaW9JZCxcbiAgV0FTVEVfU0NFTkFSSU9TLFxuICBSZXNvdXJjZVR5cGUsXG59IGZyb20gXCIuL3NjZW5hcmlvc1wiXG5pbXBvcnQge1xuICBnZXRFQzJNb250aGx5Q29zdCxcbiAgZ2V0UkRTTW9udGhseUNvc3QsXG4gIGdldENhY2hlTW9udGhseUNvc3QsXG4gIGdldExvYWRCYWxhbmNlck1vbnRobHlDb3N0LFxuICBnZXRWb2x1bWVNb250aGx5Q29zdCxcbiAgZ2V0U25hcHNob3RNb250aGx5Q29zdCxcbiAgZ2V0VW5hdHRhY2hlZEVJUE1vbnRobHlDb3N0LFxuICBnZXRTM1RpZXJpbmdTYXZpbmdzLFxuICBnZXRMYW1iZGFNb250aGx5Q29zdCxcbiAgZ2V0UmVjb21tZW5kZWRTbWFsbGVySW5zdGFuY2UsXG4gIGdldEVDMkluc3RhbmNlU3BlY3MsXG4gIEhPVVJTX1BFUl9NT05USCxcbn0gZnJvbSBcIkAvbGliL3V0aWxzL3ByaWNpbmdcIlxuXG4vLyBDYWNoZSBmb3IgZGV0ZWN0aW9uIHJlc3VsdHMgKDMwLXNlY29uZCBUVEwpXG5pbnRlcmZhY2UgQ2FjaGVFbnRyeSB7XG4gIHJlc3VsdDogRGV0ZWN0aW9uUmVzdWx0XG4gIHRpbWVzdGFtcDogbnVtYmVyXG59XG5cbmxldCBkZXRlY3Rpb25DYWNoZTogQ2FjaGVFbnRyeSB8IG51bGwgPSBudWxsXG5jb25zdCBDQUNIRV9UVExfTVMgPSAzMDAwMCAvLyAzMCBzZWNvbmRzXG5cbi8vIFByZS1mZXRjaGVkIHJlc291cmNlIGRhdGEgc3RydWN0dXJlXG5pbnRlcmZhY2UgUmVzb3VyY2VEYXRhIHtcbiAgaW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gIHJkc0luc3RhbmNlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXVxuICBjYWNoZUNsdXN0ZXJzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gIGxvYWRCYWxhbmNlcnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W11cbiAgbGFtYmRhRnVuY3Rpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gIHZvbHVtZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W11cbiAgc25hcHNob3RzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gIGVsYXN0aWNJcHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W11cbiAgczNCdWNrZXRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gIGxvZ0dyb3VwczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXVxuICBhdXRvc2NhbGluZ0dyb3VwczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXVxufVxuXG4vLyBEZXRlY3Rpb24gcmVzdWx0IGZvciBhIHNpbmdsZSByZXNvdXJjZVxuZXhwb3J0IGludGVyZmFjZSBXYXN0ZURldGVjdGlvbiB7XG4gIGlkOiBzdHJpbmdcbiAgc2NlbmFyaW9JZDogV2FzdGVTY2VuYXJpb0lkXG4gIHNjZW5hcmlvOiBXYXN0ZVNjZW5hcmlvXG4gIC8vIEZsYXR0ZW5lZCBzY2VuYXJpbyBwcm9wZXJ0aWVzIGZvciBob29rcyBjb21wYXRpYmlsaXR5XG4gIHNjZW5hcmlvTmFtZTogc3RyaW5nXG4gIG1vZGU6IDIgfCAzXG4gIGFjdGlvbjogc3RyaW5nXG4gIHJlc291cmNlSWQ6IHN0cmluZ1xuICByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZVxuICByZXNvdXJjZU5hbWU6IHN0cmluZ1xuICBhY2NvdW50SWQ6IHN0cmluZ1xuICByZWdpb246IHN0cmluZ1xuICBlbnY6IHN0cmluZ1xuICBjb25maWRlbmNlOiBudW1iZXJcbiAgbW9udGhseUNvc3Q6IG51bWJlclxuICBwb3RlbnRpYWxTYXZpbmdzOiBudW1iZXJcbiAgZGV0YWlsczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgY2FuQXV0b09wdGltaXplOiBib29sZWFuXG4gIG9wdGltaXphdGlvblBvbGljeUxvY2tlZDogYm9vbGVhblxuICBjcmVhdGVkQXQ6IHN0cmluZ1xufVxuXG4vLyBTdW1tYXJ5IG9mIGRldGVjdGlvbiByZXN1bHRzXG5leHBvcnQgaW50ZXJmYWNlIERldGVjdGlvblN1bW1hcnkge1xuICB0b3RhbFJlc291cmNlczogbnVtYmVyXG4gIHdhc3RlRGV0ZWN0ZWQ6IG51bWJlclxuICB0b3RhbE1vbnRobHlDb3N0OiBudW1iZXJcbiAgdG90YWxQb3RlbnRpYWxTYXZpbmdzOiBudW1iZXJcbiAgYXV0b09wdGltaXphYmxlU2F2aW5nczogbnVtYmVyXG4gIGJ5U2NlbmFyaW86IFJlY29yZDxXYXN0ZVNjZW5hcmlvSWQsIG51bWJlcj5cbiAgYnlTZXZlcml0eToge1xuICAgIGhpZ2g6IG51bWJlclxuICAgIG1lZGl1bTogbnVtYmVyXG4gICAgbG93OiBudW1iZXJcbiAgfVxufVxuXG4vLyBSZXNvdXJjZSBjb3VudHMgY29tcHV0ZWQgZnJvbSBmZXRjaGVkIGRhdGFcbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VDb3VudHMge1xuICBpbnN0YW5jZXM6IG51bWJlclxuICByZHNJbnN0YW5jZXM6IG51bWJlclxuICBjYWNoZUNsdXN0ZXJzOiBudW1iZXJcbiAgbG9hZEJhbGFuY2VyczogbnVtYmVyXG4gIGxhbWJkYUZ1bmN0aW9uczogbnVtYmVyXG4gIHZvbHVtZXM6IG51bWJlclxuICBzbmFwc2hvdHM6IG51bWJlclxuICBlbGFzdGljSXBzOiBudW1iZXJcbiAgczNCdWNrZXRzOiBudW1iZXJcbiAgbG9nR3JvdXBzOiBudW1iZXJcbiAgYXV0b3NjYWxpbmdHcm91cHM6IG51bWJlclxuICB0b3RhbDogbnVtYmVyXG59XG5cbi8vIERldGVjdGlvbiByZXN1bHRcbmV4cG9ydCBpbnRlcmZhY2UgRGV0ZWN0aW9uUmVzdWx0IHtcbiAgZGV0ZWN0aW9uczogV2FzdGVEZXRlY3Rpb25bXVxuICBzdW1tYXJ5OiBEZXRlY3Rpb25TdW1tYXJ5XG4gIHJlc291cmNlQ291bnRzOiBSZXNvdXJjZUNvdW50c1xuICB0aW1lc3RhbXA6IHN0cmluZ1xufVxuXG4vKipcbiAqIE1haW4gd2FzdGUgZGV0ZWN0b3IgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFdhc3RlRGV0ZWN0b3Ige1xuICBwcml2YXRlIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudFxuXG4gIGNvbnN0cnVjdG9yKHN1cGFiYXNlVXJsOiBzdHJpbmcsIHN1cGFiYXNlS2V5OiBzdHJpbmcpIHtcbiAgICB0aGlzLnN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gZnVsbCBkZXRlY3Rpb24gYWNyb3NzIGFsbCByZXNvdXJjZXNcbiAgICogT1BUSU1JWkVEOiBVc2VzIGJhdGNoIGZldGNoaW5nIGFuZCBjYWNoaW5nXG4gICAqL1xuICBhc3luYyBkZXRlY3RBbGwoKTogUHJvbWlzZTxEZXRlY3Rpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBkZXRlY3RBbGxTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnNvbGUubG9nKFwiW0RldGVjdG9yXSBkZXRlY3RBbGwoKSBzdGFydGVkXCIpXG5cbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGlmIChkZXRlY3Rpb25DYWNoZSkge1xuICAgICAgY29uc3QgYWdlID0gRGF0ZS5ub3coKSAtIGRldGVjdGlvbkNhY2hlLnRpbWVzdGFtcFxuICAgICAgaWYgKGFnZSA8IENBQ0hFX1RUTF9NUykge1xuICAgICAgICBjb25zdCBjYWNoZUhpdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIGRldGVjdEFsbFN0YXJ0VGltZVxuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBDQUNIRSBISVQgLSBhZ2U6ICR7TWF0aC5yb3VuZChhZ2UgLyAxMDAwKX1zLCBsb29rdXA6ICR7Y2FjaGVIaXRUaW1lLnRvRml4ZWQoMCl9bXNgKVxuICAgICAgICByZXR1cm4gZGV0ZWN0aW9uQ2FjaGUucmVzdWx0XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBDQUNIRSBFWFBJUkVEIC0gQWdlOiAke01hdGgucm91bmQoYWdlIC8gMTAwMCl9cyBleGNlZWRzIFRUTDogJHtDQUNIRV9UVExfTVMgLyAxMDAwfXNgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltEZXRlY3Rvcl0gQ0FDSEUgTUlTUyAtIE5vIGNhY2hlZCByZXN1bHRzXCIpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJbRGV0ZWN0b3JdIFN0YXJ0aW5nIHBhcmFsbGVsIGZldGNoIG9mIDExIHRhYmxlcy4uLlwiKVxuICAgIGNvbnN0IGZldGNoU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIE9QVElNSVpBVElPTjogRmV0Y2ggYWxsIHJlc291cmNlIHRhYmxlcyBpbiBhIHNpbmdsZSBwYXJhbGxlbCBvcGVyYXRpb25cbiAgICBjb25zdCByZXNvdXJjZURhdGEgPSBhd2FpdCB0aGlzLmJhdGNoRmV0Y2hBbGxSZXNvdXJjZXMoKVxuXG4gICAgY29uc3QgZmV0Y2hEdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gZmV0Y2hTdGFydFRpbWVcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBEQiBmZXRjaCBjb21wbGV0ZWQgaW4gJHtmZXRjaER1cmF0aW9uLnRvRml4ZWQoMCl9bXNgKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFJlc291cmNlIGNvdW50czpgKVxuICAgIGNvbnNvbGUubG9nKGAgIC0gaW5zdGFuY2VzOiAke3Jlc291cmNlRGF0YS5pbnN0YW5jZXMubGVuZ3RofWApXG4gICAgY29uc29sZS5sb2coYCAgLSByZHNfaW5zdGFuY2VzOiAke3Jlc291cmNlRGF0YS5yZHNJbnN0YW5jZXMubGVuZ3RofWApXG4gICAgY29uc29sZS5sb2coYCAgLSBjYWNoZV9jbHVzdGVyczogJHtyZXNvdXJjZURhdGEuY2FjaGVDbHVzdGVycy5sZW5ndGh9YClcbiAgICBjb25zb2xlLmxvZyhgICAtIGxvYWRfYmFsYW5jZXJzOiAke3Jlc291cmNlRGF0YS5sb2FkQmFsYW5jZXJzLmxlbmd0aH1gKVxuICAgIGNvbnNvbGUubG9nKGAgIC0gbGFtYmRhX2Z1bmN0aW9uczogJHtyZXNvdXJjZURhdGEubGFtYmRhRnVuY3Rpb25zLmxlbmd0aH1gKVxuICAgIGNvbnNvbGUubG9nKGAgIC0gdm9sdW1lczogJHtyZXNvdXJjZURhdGEudm9sdW1lcy5sZW5ndGh9YClcbiAgICBjb25zb2xlLmxvZyhgICAtIHNuYXBzaG90czogJHtyZXNvdXJjZURhdGEuc25hcHNob3RzLmxlbmd0aH1gKVxuICAgIGNvbnNvbGUubG9nKGAgIC0gZWxhc3RpY19pcHM6ICR7cmVzb3VyY2VEYXRhLmVsYXN0aWNJcHMubGVuZ3RofWApXG4gICAgY29uc29sZS5sb2coYCAgLSBzM19idWNrZXRzOiAke3Jlc291cmNlRGF0YS5zM0J1Y2tldHMubGVuZ3RofWApXG4gICAgY29uc29sZS5sb2coYCAgLSBsb2dfZ3JvdXBzOiAke3Jlc291cmNlRGF0YS5sb2dHcm91cHMubGVuZ3RofWApXG4gICAgY29uc29sZS5sb2coYCAgLSBhdXRvc2NhbGluZ19ncm91cHM6ICR7cmVzb3VyY2VEYXRhLmF1dG9zY2FsaW5nR3JvdXBzLmxlbmd0aH1gKVxuXG4gICAgLy8gUnVuIGFsbCBkZXRlY3Rpb24gZnVuY3Rpb25zIG9uIHByZS1mZXRjaGVkIGRhdGEgKG5vIG1vcmUgREIgY2FsbHMpXG4gICAgY29uc3QgZGV0ZWN0aW9uczogV2FzdGVEZXRlY3Rpb25bXSA9IFtdXG4gICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cbiAgICBjb25zb2xlLmxvZyhcIltEZXRlY3Rvcl0gU3RhcnRpbmcgaW4tbWVtb3J5IGRldGVjdGlvbiBwcm9jZXNzaW5nLi4uXCIpXG5cbiAgICAvLyBQcm9jZXNzIGFsbCBkZXRlY3Rpb25zIGluLW1lbW9yeSB1c2luZyBwcmUtZmV0Y2hlZCBkYXRhXG4gICAgY29uc3QgaWRsZUluc3RhbmNlcyA9IHRoaXMuZGV0ZWN0SWRsZUluc3RhbmNlc0Zyb21EYXRhKHJlc291cmNlRGF0YS5pbnN0YW5jZXMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0SWRsZUluc3RhbmNlczogJHtpZGxlSW5zdGFuY2VzLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLmlkbGVJbnN0YW5jZXMpXG5cbiAgICBjb25zdCBvcnBoYW5lZEVpcHMgPSB0aGlzLmRldGVjdE9ycGhhbmVkRUlQc0Zyb21EYXRhKHJlc291cmNlRGF0YS5lbGFzdGljSXBzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdE9ycGhhbmVkRUlQczogJHtvcnBoYW5lZEVpcHMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4ub3JwaGFuZWRFaXBzKVxuXG4gICAgY29uc3QgdW5hdHRhY2hlZFZvbHVtZXMgPSB0aGlzLmRldGVjdFVuYXR0YWNoZWRWb2x1bWVzRnJvbURhdGEocmVzb3VyY2VEYXRhLnZvbHVtZXMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0VW5hdHRhY2hlZFZvbHVtZXM6ICR7dW5hdHRhY2hlZFZvbHVtZXMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4udW5hdHRhY2hlZFZvbHVtZXMpXG5cbiAgICBjb25zdCBvbGRTbmFwc2hvdHMgPSB0aGlzLmRldGVjdE9sZFNuYXBzaG90c0Zyb21EYXRhKHJlc291cmNlRGF0YS5zbmFwc2hvdHMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0T2xkU25hcHNob3RzOiAke29sZFNuYXBzaG90cy5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5vbGRTbmFwc2hvdHMpXG5cbiAgICBjb25zdCBpZGxlUmRzID0gdGhpcy5kZXRlY3RJZGxlUkRTRnJvbURhdGEocmVzb3VyY2VEYXRhLnJkc0luc3RhbmNlcylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RJZGxlUkRTOiAke2lkbGVSZHMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4uaWRsZVJkcylcblxuICAgIGNvbnN0IGlkbGVDYWNoZSA9IHRoaXMuZGV0ZWN0SWRsZUNhY2hlRnJvbURhdGEocmVzb3VyY2VEYXRhLmNhY2hlQ2x1c3RlcnMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0SWRsZUNhY2hlOiAke2lkbGVDYWNoZS5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5pZGxlQ2FjaGUpXG5cbiAgICBjb25zdCBpZGxlTGJzID0gdGhpcy5kZXRlY3RJZGxlTG9hZEJhbGFuY2Vyc0Zyb21EYXRhKHJlc291cmNlRGF0YS5sb2FkQmFsYW5jZXJzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdElkbGVMb2FkQmFsYW5jZXJzOiAke2lkbGVMYnMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4uaWRsZUxicylcblxuICAgIGNvbnN0IG92ZXJQcm92TGFtYmRhcyA9IHRoaXMuZGV0ZWN0T3ZlclByb3Zpc2lvbmVkTGFtYmRhc0Zyb21EYXRhKHJlc291cmNlRGF0YS5sYW1iZGFGdW5jdGlvbnMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0T3ZlclByb3Zpc2lvbmVkTGFtYmRhczogJHtvdmVyUHJvdkxhbWJkYXMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4ub3ZlclByb3ZMYW1iZGFzKVxuXG4gICAgY29uc3QgczNOb0xpZmVjeWNsZSA9IHRoaXMuZGV0ZWN0UzNOb0xpZmVjeWNsZUZyb21EYXRhKHJlc291cmNlRGF0YS5zM0J1Y2tldHMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0UzNOb0xpZmVjeWNsZTogJHtzM05vTGlmZWN5Y2xlLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLnMzTm9MaWZlY3ljbGUpXG5cbiAgICBjb25zdCBsb2dOb1JldGVudGlvbiA9IHRoaXMuZGV0ZWN0TG9nTm9SZXRlbnRpb25Gcm9tRGF0YShyZXNvdXJjZURhdGEubG9nR3JvdXBzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdExvZ05vUmV0ZW50aW9uOiAke2xvZ05vUmV0ZW50aW9uLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLmxvZ05vUmV0ZW50aW9uKVxuXG4gICAgY29uc3QgZm9yZ290dGVuUHJldmlld3MgPSB0aGlzLmRldGVjdEZvcmdvdHRlblByZXZpZXdzRnJvbURhdGEocmVzb3VyY2VEYXRhLmF1dG9zY2FsaW5nR3JvdXBzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdEZvcmdvdHRlblByZXZpZXdzOiAke2ZvcmdvdHRlblByZXZpZXdzLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLmZvcmdvdHRlblByZXZpZXdzKVxuXG4gICAgY29uc3Qgb3ZlclByb3ZBc2dzID0gdGhpcy5kZXRlY3RPdmVyUHJvdmlzaW9uZWRBU0dzRnJvbURhdGEocmVzb3VyY2VEYXRhLmF1dG9zY2FsaW5nR3JvdXBzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdE92ZXJQcm92aXNpb25lZEFTR3M6ICR7b3ZlclByb3ZBc2dzLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLm92ZXJQcm92QXNncylcblxuICAgIGNvbnN0IHN0YWxlRmVhdHVyZUVudnMgPSB0aGlzLmRldGVjdFN0YWxlRmVhdHVyZUVudnNGcm9tRGF0YShyZXNvdXJjZURhdGEuYXV0b3NjYWxpbmdHcm91cHMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0U3RhbGVGZWF0dXJlRW52czogJHtzdGFsZUZlYXR1cmVFbnZzLmxlbmd0aH0gZGV0ZWN0aW9uc2ApXG4gICAgZGV0ZWN0aW9ucy5wdXNoKC4uLnN0YWxlRmVhdHVyZUVudnMpXG5cbiAgICBjb25zdCBpZGxlQ2lSdW5uZXJzID0gdGhpcy5kZXRlY3RJZGxlQ0lSdW5uZXJzRnJvbURhdGEocmVzb3VyY2VEYXRhLmluc3RhbmNlcylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RJZGxlQ0lSdW5uZXJzOiAke2lkbGVDaVJ1bm5lcnMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4uaWRsZUNpUnVubmVycylcblxuICAgIGNvbnN0IG9mZkhvdXJzRGV2ID0gdGhpcy5kZXRlY3RPZmZIb3Vyc0Rldkluc3RhbmNlc0Zyb21EYXRhKHJlc291cmNlRGF0YS5pbnN0YW5jZXMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0T2ZmSG91cnNEZXZJbnN0YW5jZXM6ICR7b2ZmSG91cnNEZXYubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4ub2ZmSG91cnNEZXYpXG5cbiAgICBjb25zdCBvdmVyUHJvdkluc3RhbmNlcyA9IHRoaXMuZGV0ZWN0T3ZlclByb3Zpc2lvbmVkSW5zdGFuY2VzRnJvbURhdGEocmVzb3VyY2VEYXRhLmluc3RhbmNlcylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RPdmVyUHJvdmlzaW9uZWRJbnN0YW5jZXM6ICR7b3ZlclByb3ZJbnN0YW5jZXMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4ub3ZlclByb3ZJbnN0YW5jZXMpXG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFFVSUNLLVdJTiBPUFRJTUlaQVRJT05TIC0gUGhhc2UgMSAoTm8gbWlncmF0aW9ucyBuZWVkZWQpXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGNvbnN0IGdwMlZvbHVtZXMgPSB0aGlzLmRldGVjdEdwMlZvbHVtZXNGcm9tRGF0YShyZXNvdXJjZURhdGEudm9sdW1lcylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RHcDJWb2x1bWVzOiAke2dwMlZvbHVtZXMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4uZ3AyVm9sdW1lcylcblxuICAgIGNvbnN0IHVudXNlZExhbWJkYXMgPSB0aGlzLmRldGVjdFVudXNlZExhbWJkYXNGcm9tRGF0YShyZXNvdXJjZURhdGEubGFtYmRhRnVuY3Rpb25zKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdFVudXNlZExhbWJkYXM6ICR7dW51c2VkTGFtYmRhcy5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi51bnVzZWRMYW1iZGFzKVxuXG4gICAgY29uc3Qgb3JwaGFuZWRTbmFwc2hvdHMgPSB0aGlzLmRldGVjdE9ycGhhbmVkU25hcHNob3RzRnJvbURhdGEocmVzb3VyY2VEYXRhLnNuYXBzaG90cywgcmVzb3VyY2VEYXRhLnZvbHVtZXMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0T3JwaGFuZWRTbmFwc2hvdHM6ICR7b3JwaGFuZWRTbmFwc2hvdHMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4ub3JwaGFuZWRTbmFwc2hvdHMpXG5cbiAgICBjb25zdCBzdGF0aWNBc2dzID0gdGhpcy5kZXRlY3RTdGF0aWNBU0dzRnJvbURhdGEocmVzb3VyY2VEYXRhLmF1dG9zY2FsaW5nR3JvdXBzKVxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIGRldGVjdFN0YXRpY0FTR3M6ICR7c3RhdGljQXNncy5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5zdGF0aWNBc2dzKVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBRVUlDSy1XSU4gT1BUSU1JWkFUSU9OUyAtIFBoYXNlIDIgKFdpdGggbWlncmF0aW9ucylcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgY29uc3QgbXVsdGlBek5vblByb2QgPSB0aGlzLmRldGVjdE11bHRpQXpOb25Qcm9kRnJvbURhdGEocmVzb3VyY2VEYXRhLnJkc0luc3RhbmNlcylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RNdWx0aUF6Tm9uUHJvZDogJHttdWx0aUF6Tm9uUHJvZC5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5tdWx0aUF6Tm9uUHJvZClcblxuICAgIGNvbnN0IGVtcHR5TGJzID0gdGhpcy5kZXRlY3RFbXB0eUxvYWRCYWxhbmNlcnNGcm9tRGF0YShyZXNvdXJjZURhdGEubG9hZEJhbGFuY2VycylcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBkZXRlY3RFbXB0eUxvYWRCYWxhbmNlcnM6ICR7ZW1wdHlMYnMubGVuZ3RofSBkZXRlY3Rpb25zYClcbiAgICBkZXRlY3Rpb25zLnB1c2goLi4uZW1wdHlMYnMpXG5cbiAgICBjb25zdCBzM05vVmVyc2lvbkV4cGlyYXRpb24gPSB0aGlzLmRldGVjdFMzTm9WZXJzaW9uRXhwaXJhdGlvbkZyb21EYXRhKHJlc291cmNlRGF0YS5zM0J1Y2tldHMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0UzNOb1ZlcnNpb25FeHBpcmF0aW9uOiAke3MzTm9WZXJzaW9uRXhwaXJhdGlvbi5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5zM05vVmVyc2lvbkV4cGlyYXRpb24pXG5cbiAgICBjb25zdCBvdmVyQ29uZmlndXJlZFRpbWVvdXQgPSB0aGlzLmRldGVjdE92ZXJDb25maWd1cmVkVGltZW91dEZyb21EYXRhKHJlc291cmNlRGF0YS5sYW1iZGFGdW5jdGlvbnMpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gZGV0ZWN0T3ZlckNvbmZpZ3VyZWRUaW1lb3V0OiAke292ZXJDb25maWd1cmVkVGltZW91dC5sZW5ndGh9IGRldGVjdGlvbnNgKVxuICAgIGRldGVjdGlvbnMucHVzaCguLi5vdmVyQ29uZmlndXJlZFRpbWVvdXQpXG5cbiAgICAvLyBjb25zdCBwcm9jZXNzaW5nRHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2Nlc3NpbmdTdGFydFRpbWVcbiAgICAvLyBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBEZXRlY3Rpb24gcHJvY2Vzc2luZyBjb21wbGV0ZWQgaW4gJHtwcm9jZXNzaW5nRHVyYXRpb24udG9GaXhlZCgyKX1tc2ApXG5cbiAgICAvLyBDYWxjdWxhdGUgc3VtbWFyeVxuICAgIC8vIGNvbnN0IHN1bW1hcnlTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHN1bW1hcnkgPSB0aGlzLmNhbGN1bGF0ZVN1bW1hcnkoZGV0ZWN0aW9ucylcbiAgICAvLyBjb25zdCBzdW1tYXJ5RHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN1bW1hcnlTdGFydFRpbWVcbiAgICAvLyBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBTdW1tYXJ5IGNhbGN1bGF0aW9uIGNvbXBsZXRlZCBpbiAke3N1bW1hcnlEdXJhdGlvbi50b0ZpeGVkKDIpfW1zYClcblxuICAgIC8vIENvbXB1dGUgcmVzb3VyY2UgY291bnRzIGZyb20gYWxyZWFkeS1mZXRjaGVkIGRhdGEgKDAgZXh0cmEgcXVlcmllcylcbiAgICBjb25zdCByZXNvdXJjZUNvdW50cyA9IHRoaXMuY29tcHV0ZVJlc291cmNlQ291bnRzKHJlc291cmNlRGF0YSlcblxuICAgIGNvbnN0IHJlc3VsdDogRGV0ZWN0aW9uUmVzdWx0ID0ge1xuICAgICAgZGV0ZWN0aW9ucyxcbiAgICAgIHN1bW1hcnksXG4gICAgICByZXNvdXJjZUNvdW50cyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICB9XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgZGV0ZWN0aW9uQ2FjaGUgPSB7XG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gZGV0ZWN0QWxsU3RhcnRUaW1lXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0g4pyFIENvbXBsZXRlOiAke3RvdGFsRHVyYXRpb24udG9GaXhlZCgwKX1tcyB0b3RhbCB8IERCOiAke2ZldGNoRHVyYXRpb24udG9GaXhlZCgwKX1tcyB8ICR7ZGV0ZWN0aW9ucy5sZW5ndGh9IGRldGVjdGlvbnMgfCAkJHtzdW1tYXJ5LnRvdGFsUG90ZW50aWFsU2F2aW5ncy50b0ZpeGVkKDApfS9tbyBzYXZpbmdzYClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXRjaCBmZXRjaCBhbGwgcmVzb3VyY2UgdGFibGVzIGluIHBhcmFsbGVsXG4gICAqIFRoaXMgaXMgdGhlIGtleSBvcHRpbWl6YXRpb24gLSBzaW5nbGUgcm91bmQtdHJpcCBmb3IgYWxsIGRhdGFcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgYmF0Y2hGZXRjaEFsbFJlc291cmNlcygpOiBQcm9taXNlPFJlc291cmNlRGF0YT4ge1xuICAgIGNvbnN0IFtcbiAgICAgIGluc3RhbmNlcyxcbiAgICAgIHJkc0luc3RhbmNlcyxcbiAgICAgIGNhY2hlQ2x1c3RlcnMsXG4gICAgICBsb2FkQmFsYW5jZXJzLFxuICAgICAgbGFtYmRhRnVuY3Rpb25zLFxuICAgICAgdm9sdW1lcyxcbiAgICAgIHNuYXBzaG90cyxcbiAgICAgIGVsYXN0aWNJcHMsXG4gICAgICBzM0J1Y2tldHMsXG4gICAgICBsb2dHcm91cHMsXG4gICAgICBhdXRvc2NhbGluZ0dyb3VwcyxcbiAgICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5zdXBhYmFzZS5mcm9tKFwiaW5zdGFuY2VzXCIpLnNlbGVjdChcIipcIiksXG4gICAgICB0aGlzLnN1cGFiYXNlLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpLnNlbGVjdChcIipcIiksXG4gICAgICB0aGlzLnN1cGFiYXNlLmZyb20oXCJjYWNoZV9jbHVzdGVyc1wiKS5zZWxlY3QoXCIqXCIpLFxuICAgICAgdGhpcy5zdXBhYmFzZS5mcm9tKFwibG9hZF9iYWxhbmNlcnNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcImxhbWJkYV9mdW5jdGlvbnNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcInZvbHVtZXNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcInNuYXBzaG90c1wiKS5zZWxlY3QoXCIqXCIpLFxuICAgICAgdGhpcy5zdXBhYmFzZS5mcm9tKFwiZWxhc3RpY19pcHNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcInMzX2J1Y2tldHNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcImxvZ19ncm91cHNcIikuc2VsZWN0KFwiKlwiKSxcbiAgICAgIHRoaXMuc3VwYWJhc2UuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKS5zZWxlY3QoXCIqXCIpLFxuICAgIF0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZXMuZGF0YSA/PyBbXSxcbiAgICAgIHJkc0luc3RhbmNlczogcmRzSW5zdGFuY2VzLmRhdGEgPz8gW10sXG4gICAgICBjYWNoZUNsdXN0ZXJzOiBjYWNoZUNsdXN0ZXJzLmRhdGEgPz8gW10sXG4gICAgICBsb2FkQmFsYW5jZXJzOiBsb2FkQmFsYW5jZXJzLmRhdGEgPz8gW10sXG4gICAgICBsYW1iZGFGdW5jdGlvbnM6IGxhbWJkYUZ1bmN0aW9ucy5kYXRhID8/IFtdLFxuICAgICAgdm9sdW1lczogdm9sdW1lcy5kYXRhID8/IFtdLFxuICAgICAgc25hcHNob3RzOiBzbmFwc2hvdHMuZGF0YSA/PyBbXSxcbiAgICAgIGVsYXN0aWNJcHM6IGVsYXN0aWNJcHMuZGF0YSA/PyBbXSxcbiAgICAgIHMzQnVja2V0czogczNCdWNrZXRzLmRhdGEgPz8gW10sXG4gICAgICBsb2dHcm91cHM6IGxvZ0dyb3Vwcy5kYXRhID8/IFtdLFxuICAgICAgYXV0b3NjYWxpbmdHcm91cHM6IGF1dG9zY2FsaW5nR3JvdXBzLmRhdGEgPz8gW10sXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZGxlIEVDMiBpbnN0YW5jZXMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RJZGxlSW5zdGFuY2VzRnJvbURhdGEoaW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgLy8gRmlsdGVyOiBydW5uaW5nIGluc3RhbmNlcyB3aXRoIENQVSA8IDUlIChwcmVmZXIgYXZnX2NwdV83ZCwgZmFsbGJhY2sgdG8gY3VycmVudF9jcHUpXG4gICAgY29uc3QgZmlsdGVyZWQgPSBpbnN0YW5jZXMuZmlsdGVyKChpKSA9PiB7XG4gICAgICBpZiAoaS5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHJldHVybiBmYWxzZVxuXG4gICAgICAvLyBVc2UgYXZnX2NwdV83ZCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gY3VycmVudF9jcHVcbiAgICAgIGNvbnN0IGF2ZzdkQ3B1ID0gaS5hdmdfY3B1XzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDcHUgPSBpLmN1cnJlbnRfY3B1IGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGNwdVZhbHVlID0gYXZnN2RDcHUgPz8gY3VycmVudENwdVxuXG4gICAgICAvLyBOZWVkIGF0IGxlYXN0IG9uZSBDUFUgbWV0cmljIHRvIGRldGVybWluZSBpZiBpZGxlXG4gICAgICBpZiAoY3B1VmFsdWUgPT09IG51bGwgfHwgY3B1VmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBjcHVWYWx1ZSA8IDVcbiAgICB9KVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLmlkbGVfaW5zdGFuY2VcbiAgICAgIGNvbnN0IG1vbnRobHlDb3N0ID0gZ2V0RUMyTW9udGhseUNvc3QoaW5zdGFuY2UuaW5zdGFuY2VfdHlwZSBhcyBzdHJpbmcpXG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBmYWxsYmFjayBsb2dpY1xuICAgICAgY29uc3QgYXZnN2RDcHUgPSBpbnN0YW5jZS5hdmdfY3B1XzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDcHUgPSBpbnN0YW5jZS5jdXJyZW50X2NwdSBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjcHVWYWx1ZSA9IGF2ZzdkQ3B1ID8/IGN1cnJlbnRDcHUgPz8gMFxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoY3B1VmFsdWUgPCAyKSBjb25maWRlbmNlICs9IDEwXG4gICAgICBpZiAoaW5zdGFuY2UuZW52ID09PSBcImRldlwiIHx8IGluc3RhbmNlLmVudiA9PT0gXCJzdGFnaW5nXCIpIGNvbmZpZGVuY2UgKz0gNVxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcImlkbGVfaW5zdGFuY2VcIixcbiAgICAgICAgcmVzb3VyY2U6IGluc3RhbmNlLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwiaW5zdGFuY2VzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCAqIDAuOSxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGluc3RhbmNlVHlwZTogaW5zdGFuY2UuaW5zdGFuY2VfdHlwZSxcbiAgICAgICAgICBhdmdDcHU3ZDogY3B1VmFsdWUsXG4gICAgICAgICAgbGF1bmNoVGltZTogaW5zdGFuY2UubGF1bmNoX3RpbWUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvbiAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RJZGxlSW5zdGFuY2VzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogaW5zdGFuY2VzLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxuICAgICAgLmZyb20oXCJpbnN0YW5jZXNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJzdGF0ZVwiLCBcInJ1bm5pbmdcIilcbiAgICAgIC5sdChcImF2Z19jcHVfN2RcIiwgNSlcblxuICAgIGlmIChlcnJvciB8fCAhaW5zdGFuY2VzKSByZXR1cm4gW11cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RJZGxlSW5zdGFuY2VzRnJvbURhdGEoaW5zdGFuY2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBvcnBoYW5lZCBFbGFzdGljIElQcyAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqL1xuICBwcml2YXRlIGRldGVjdE9ycGhhbmVkRUlQc0Zyb21EYXRhKGVpcHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10pOiBXYXN0ZURldGVjdGlvbltdIHtcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBPcnBoYW5lZCBFSVBzOiBDaGVja2luZyAke2VpcHMubGVuZ3RofSBlbGFzdGljIElQc2ApXG5cbiAgICAvLyBGaWx0ZXI6IEVJUHMgd2l0aCBubyBhc3NvY2lhdGVkIGluc3RhbmNlXG4gICAgY29uc3QgZmlsdGVyZWQgPSBlaXBzLmZpbHRlcigoZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRUlQOiAke2UucHVibGljX2lwfSB8IGFzc29jaWF0ZWRfaW5zdGFuY2VfaWQ6ICR7ZS5hc3NvY2lhdGVkX2luc3RhbmNlX2lkfWApXG4gICAgICBpZiAoZS5hc3NvY2lhdGVkX2luc3RhbmNlX2lkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IEVJUCBpcyBhc3NvY2lhdGVkIHdpdGggJHtlLmFzc29jaWF0ZWRfaW5zdGFuY2VfaWR9YClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogT3JwaGFuZWQgRUlQIGRldGVjdGVkYClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIE9ycGhhbmVkIEVJUHM6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBvcnBoYW5lZCBFSVBzYClcblxuICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoKGVpcCkgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub3JwaGFuZWRfZWlwXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFVuYXR0YWNoZWRFSVBNb250aGx5Q29zdCgpXG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwib3JwaGFuZWRfZWlwXCIsXG4gICAgICAgIHJlc291cmNlOiBlaXAsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJlbGFzdGljX2lwc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwicHVibGljX2lwXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCxcbiAgICAgICAgY29uZmlkZW5jZTogc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2UsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBwdWJsaWNJcDogZWlwLnB1YmxpY19pcCxcbiAgICAgICAgICBhbGxvY2F0aW9uSWQ6IGVpcC5hbGxvY2F0aW9uX2lkLFxuICAgICAgICAgIGFzc29jaWF0ZWRXaXRoOiBlaXAuYXNzb2NpYXRlZF9pbnN0YW5jZV9pZCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIExlZ2FjeSBhc3luYyB2ZXJzaW9uXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0T3JwaGFuZWRFSVBzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogZWlwcywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiZWxhc3RpY19pcHNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuaXMoXCJhc3NvY2lhdGVkX2luc3RhbmNlX2lkXCIsIG51bGwpXG5cbiAgICBpZiAoZXJyb3IgfHwgIWVpcHMpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdE9ycGhhbmVkRUlQc0Zyb21EYXRhKGVpcHMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHVuYXR0YWNoZWQgRUJTIHZvbHVtZXMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RVbmF0dGFjaGVkVm9sdW1lc0Zyb21EYXRhKHZvbHVtZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10pOiBXYXN0ZURldGVjdGlvbltdIHtcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBVbmF0dGFjaGVkIFZvbHVtZXM6IENoZWNraW5nICR7dm9sdW1lcy5sZW5ndGh9IEVCUyB2b2x1bWVzYClcblxuICAgIC8vIEZpbHRlcjogdm9sdW1lcyB3aXRoIHN0YXRlID0gYXZhaWxhYmxlXG4gICAgY29uc3QgZmlsdGVyZWQgPSB2b2x1bWVzLmZpbHRlcigodikgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gVm9sdW1lOiAke3Yudm9sdW1lX2lkfSB8IHN0YXRlOiAke3Yuc3RhdGV9IHwgc2l6ZTogJHt2LnNpemVfZ2lifUdCYClcbiAgICAgIGlmICh2LnN0YXRlICE9PSBcImF2YWlsYWJsZVwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IFZvbHVtZSBzdGF0ZSBpcyAke3Yuc3RhdGV9LCBub3QgXCJhdmFpbGFibGVcImApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IFVuYXR0YWNoZWQgdm9sdW1lIGRldGVjdGVkYClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFVuYXR0YWNoZWQgVm9sdW1lczogRm91bmQgJHtmaWx0ZXJlZC5sZW5ndGh9IHVuYXR0YWNoZWQgdm9sdW1lc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKCh2b2x1bWUpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLnVuYXR0YWNoZWRfdm9sdW1lXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFZvbHVtZU1vbnRobHlDb3N0KHZvbHVtZS52b2x1bWVfdHlwZSBhcyBzdHJpbmcsIHZvbHVtZS5zaXplX2dpYiBhcyBudW1iZXIpXG5cbiAgICAgIGxldCBjb25maWRlbmNlID0gc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2VcbiAgICAgIGNvbnN0IGRheXNTaW5jZUNyZWF0aW9uID0gdGhpcy5kYXlzU2luY2Uodm9sdW1lLmNyZWF0ZWRfYXQgYXMgc3RyaW5nKVxuICAgICAgaWYgKGRheXNTaW5jZUNyZWF0aW9uID4gMzApIGNvbmZpZGVuY2UgKz0gMTBcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJ1bmF0dGFjaGVkX3ZvbHVtZVwiLFxuICAgICAgICByZXNvdXJjZTogdm9sdW1lLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwidm9sdW1lc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwidm9sdW1lX2lkXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHZvbHVtZUlkOiB2b2x1bWUudm9sdW1lX2lkLFxuICAgICAgICAgIHZvbHVtZVR5cGU6IHZvbHVtZS52b2x1bWVfdHlwZSxcbiAgICAgICAgICBzaXplR2liOiB2b2x1bWUuc2l6ZV9naWIsXG4gICAgICAgICAgZGF5c1NpbmNlQ3JlYXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvblxuICBwcml2YXRlIGFzeW5jIGRldGVjdFVuYXR0YWNoZWRWb2x1bWVzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogdm9sdW1lcywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwidm9sdW1lc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInN0YXRlXCIsIFwiYXZhaWxhYmxlXCIpXG5cbiAgICBpZiAoZXJyb3IgfHwgIXZvbHVtZXMpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdFVuYXR0YWNoZWRWb2x1bWVzRnJvbURhdGEodm9sdW1lcylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3Qgb2xkIEVCUyBzbmFwc2hvdHMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RPbGRTbmFwc2hvdHNGcm9tRGF0YShzbmFwc2hvdHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10pOiBXYXN0ZURldGVjdGlvbltdIHtcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBPbGQgU25hcHNob3RzOiBDaGVja2luZyAke3NuYXBzaG90cy5sZW5ndGh9IEVCUyBzbmFwc2hvdHNgKVxuXG4gICAgLy8gRmlsdGVyOiBzbmFwc2hvdHMgb2xkZXIgdGhhbiA5MCBkYXlzXG4gICAgY29uc3QgZmlsdGVyZWQgPSBzbmFwc2hvdHMuZmlsdGVyKChzKSA9PiB7XG4gICAgICBjb25zdCBkYXlzT2xkID0gdGhpcy5kYXlzU2luY2Uocy5jcmVhdGVkX2F0IGFzIHN0cmluZylcbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFNuYXBzaG90OiAke3Muc25hcHNob3RfaWR9IHwgY3JlYXRlZF9hdDogJHtzLmNyZWF0ZWRfYXR9IHwgZGF5cyBvbGQ6ICR7ZGF5c09sZH1gKVxuICAgICAgaWYgKGRheXNPbGQgPD0gOTApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogU25hcHNob3QgaXMgb25seSAke2RheXNPbGR9IGRheXMgb2xkICh0aHJlc2hvbGQ6ID45MCBkYXlzKWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IE9sZCBzbmFwc2hvdCBkZXRlY3RlZCAoJHtkYXlzT2xkfSBkYXlzKWApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBPbGQgU25hcHNob3RzOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gb2xkIHNuYXBzaG90c2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChzbmFwc2hvdCkgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub2xkX3NuYXBzaG90XG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFNuYXBzaG90TW9udGhseUNvc3Qoc25hcHNob3Quc2l6ZV9naWIgYXMgbnVtYmVyKVxuXG4gICAgICBjb25zdCBkYXlzT2xkID0gdGhpcy5kYXlzU2luY2Uoc25hcHNob3QuY3JlYXRlZF9hdCBhcyBzdHJpbmcpXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoZGF5c09sZCA+IDE4MCkgY29uZmlkZW5jZSArPSAxNVxuICAgICAgaWYgKGRheXNPbGQgPiAzNjUpIGNvbmZpZGVuY2UgKz0gMTBcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJvbGRfc25hcHNob3RcIixcbiAgICAgICAgcmVzb3VyY2U6IHNuYXBzaG90LFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwic25hcHNob3RzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJzbmFwc2hvdF9pZFwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBzbmFwc2hvdElkOiBzbmFwc2hvdC5zbmFwc2hvdF9pZCxcbiAgICAgICAgICBzaXplR2liOiBzbmFwc2hvdC5zaXplX2dpYixcbiAgICAgICAgICBkYXlzT2xkLFxuICAgICAgICAgIHJldGVudGlvblBvbGljeTogc25hcHNob3QucmV0ZW50aW9uX3BvbGljeSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIExlZ2FjeSBhc3luYyB2ZXJzaW9uXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0T2xkU25hcHNob3RzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogc25hcHNob3RzLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxuICAgICAgLmZyb20oXCJzbmFwc2hvdHNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG5cbiAgICBpZiAoZXJyb3IgfHwgIXNuYXBzaG90cykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0T2xkU25hcHNob3RzRnJvbURhdGEoc25hcHNob3RzKVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZGxlIFJEUyBpbnN0YW5jZXMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKlxuICAgKiBSRUxBWEVEIENSSVRFUklBOiBEZXRlY3RzIFJEUyBhcyBpZGxlIGlmIEFOWSBvZjpcbiAgICogLSBDUFUgPCAxNSUgKGxvdyB1dGlsaXphdGlvbilcbiAgICogLSBDb25uZWN0aW9ucyA8PSAxIChhbG1vc3Qgbm8gYWN0aXZlIGNvbm5lY3Rpb25zKVxuICAgKiAtIEVudmlyb25tZW50IGlzIHByZXZpZXcvZGV2L3N0YWdpbmcgd2l0aCBsb3cgYWN0aXZpdHlcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0SWRsZVJEU0Zyb21EYXRhKHJkc0luc3RhbmNlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFJEUyBJZGxlOiBDaGVja2luZyAke3Jkc0luc3RhbmNlcy5sZW5ndGh9IFJEUyBpbnN0YW5jZXNgKVxuXG4gICAgLy8gRmlsdGVyOiBhdmFpbGFibGUgUkRTIHdpdGggbG93IENQVSBPUiBsb3cgY29ubmVjdGlvbnMgT1Igbm9uLXByb2Qgd2l0aCBsb3cgYWN0aXZpdHlcbiAgICBjb25zdCBmaWx0ZXJlZCA9IHJkc0luc3RhbmNlcy5maWx0ZXIoKHIpID0+IHtcbiAgICAgIC8vIEdldCBDUFUgdmFsdWUgd2l0aCBudWxsIGhhbmRsaW5nXG4gICAgICBjb25zdCBhdmdDcHUgPSByLmF2Z19jcHVfN2QgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY3VycmVudENwdSA9IHIuY3VycmVudF9jcHUgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY3B1VmFsdWUgPSBhdmdDcHUgPz8gY3VycmVudENwdVxuXG4gICAgICAvLyBHZXQgY29ubmVjdGlvbnMgd2l0aCBudWxsIGhhbmRsaW5nXG4gICAgICBjb25zdCBhdmdDb25uZWN0aW9ucyA9IHIuYXZnX2Nvbm5lY3Rpb25zXzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9ucyA9IHIuY3VycmVudF9jb25uZWN0aW9ucyBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjb25uZWN0aW9uc1ZhbHVlID0gYXZnQ29ubmVjdGlvbnMgPz8gY3VycmVudENvbm5lY3Rpb25zXG5cbiAgICAgIC8vIEdldCBlbnZpcm9ubWVudFxuICAgICAgY29uc3QgZW52ID0gKChyLmVudiBhcyBzdHJpbmcpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKClcbiAgICAgIGNvbnN0IGlzTm9uUHJvZCA9IGVudi5pbmNsdWRlcyhcInByZXZpZXdcIikgfHwgZW52LmluY2x1ZGVzKFwiZGV2XCIpIHx8IGVudi5pbmNsdWRlcyhcInN0YWdpbmdcIikgfHwgZW52LmluY2x1ZGVzKFwidGVzdFwiKVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBSRFM6ICR7ci5kYl9pbnN0YW5jZV9pZH0gfCBTdGF0ZTogJHtyLnN0YXRlfSB8IENQVTogJHtjcHVWYWx1ZX0lIHwgQ29ubjogJHtjb25uZWN0aW9uc1ZhbHVlfSB8IEVudjogJHtlbnZ9YClcblxuICAgICAgaWYgKHIuc3RhdGUgIT09IFwiYXZhaWxhYmxlXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogU3RhdGUgaXMgJHtyLnN0YXRlfSwgbm90IFwiYXZhaWxhYmxlXCJgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gUkVMQVhFRDogVXNlIE9SIGxvZ2ljIC0gZGV0ZWN0IGlmIEFOWSBjb25kaXRpb24gaXMgbWV0XG4gICAgICBjb25zdCBpc0xvd0NwdSA9IGNwdVZhbHVlICE9PSBudWxsICYmIGNwdVZhbHVlICE9PSB1bmRlZmluZWQgJiYgY3B1VmFsdWUgPCAxNVxuICAgICAgY29uc3QgaXNMb3dDb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zVmFsdWUgIT09IG51bGwgJiYgY29ubmVjdGlvbnNWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNvbm5lY3Rpb25zVmFsdWUgPD0gMVxuICAgICAgY29uc3QgaXNJZGxlTm9uUHJvZCA9IGlzTm9uUHJvZCAmJiBjcHVWYWx1ZSAhPT0gbnVsbCAmJiBjcHVWYWx1ZSA8IDI1ICYmIChjb25uZWN0aW9uc1ZhbHVlID09PSBudWxsIHx8IGNvbm5lY3Rpb25zVmFsdWUgPCA1KVxuXG4gICAgICAvLyBJZiBib3RoIG1ldHJpY3MgYXJlIG51bGwsIGNvbnNpZGVyIGl0IHBvdGVudGlhbGx5IGlkbGVcbiAgICAgIGNvbnN0IGhhc05vTWV0cmljcyA9IChjcHVWYWx1ZSA9PT0gbnVsbCB8fCBjcHVWYWx1ZSA9PT0gdW5kZWZpbmVkKSAmJiAoY29ubmVjdGlvbnNWYWx1ZSA9PT0gbnVsbCB8fCBjb25uZWN0aW9uc1ZhbHVlID09PSB1bmRlZmluZWQpXG5cbiAgICAgIGlmICghaXNMb3dDcHUgJiYgIWlzTG93Q29ubmVjdGlvbnMgJiYgIWlzSWRsZU5vblByb2QgJiYgIWhhc05vTWV0cmljcykge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBDUFUgJHtjcHVWYWx1ZX0lID49IDE1LCBDb25uICR7Y29ubmVjdGlvbnNWYWx1ZX0gPiAxLCBub3QgaWRsZSBub24tcHJvZGApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogSWRsZSBSRFMgZGV0ZWN0ZWQgKGxvd0NQVTogJHtpc0xvd0NwdX0sIGxvd0Nvbm46ICR7aXNMb3dDb25uZWN0aW9uc30sIGlkbGVOb25Qcm9kOiAke2lzSWRsZU5vblByb2R9KWApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBSRFMgSWRsZTogRm91bmQgJHtmaWx0ZXJlZC5sZW5ndGh9IGlkbGUgUkRTIGluc3RhbmNlc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChyZHMpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLmlkbGVfcmRzXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFJEU01vbnRobHlDb3N0KHJkcy5pbnN0YW5jZV9jbGFzcyBhcyBzdHJpbmcpXG5cbiAgICAgIC8vIFVzZSB0aGUgc2FtZSBudWxsIGhhbmRsaW5nXG4gICAgICBjb25zdCBhdmdDcHUgPSByZHMuYXZnX2NwdV83ZCBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjdXJyZW50Q3B1ID0gcmRzLmN1cnJlbnRfY3B1IGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGNwdVZhbHVlID0gYXZnQ3B1ID8/IGN1cnJlbnRDcHUgPz8gMFxuICAgICAgY29uc3QgYXZnQ29ubmVjdGlvbnMgPSByZHMuYXZnX2Nvbm5lY3Rpb25zXzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9ucyA9IHJkcy5jdXJyZW50X2Nvbm5lY3Rpb25zIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25zVmFsdWUgPSBhdmdDb25uZWN0aW9ucyA/PyBjdXJyZW50Q29ubmVjdGlvbnMgPz8gMFxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoY3B1VmFsdWUgPCAxKSBjb25maWRlbmNlICs9IDEwXG4gICAgICBpZiAoY29ubmVjdGlvbnNWYWx1ZSA9PT0gMCkgY29uZmlkZW5jZSArPSAxMFxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcImlkbGVfcmRzXCIsXG4gICAgICAgIHJlc291cmNlOiByZHMsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJyZHNfaW5zdGFuY2VzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJkYl9pbnN0YW5jZV9pZFwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QgKiAwLjgsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBkYkluc3RhbmNlSWQ6IHJkcy5kYl9pbnN0YW5jZV9pZCxcbiAgICAgICAgICBpbnN0YW5jZUNsYXNzOiByZHMuaW5zdGFuY2VfY2xhc3MsXG4gICAgICAgICAgZW5naW5lOiByZHMuZW5naW5lLFxuICAgICAgICAgIGF2Z0NwdTdkOiBjcHVWYWx1ZSxcbiAgICAgICAgICBhdmdDb25uZWN0aW9uczdkOiBjb25uZWN0aW9uc1ZhbHVlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gTGVnYWN5IGFzeW5jIHZlcnNpb25cbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RJZGxlUkRTKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogcmRzSW5zdGFuY2VzLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxuICAgICAgLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwic3RhdGVcIiwgXCJhdmFpbGFibGVcIilcbiAgICAgIC5sdChcImF2Z19jcHVfN2RcIiwgNSlcbiAgICAgIC5sdChcImF2Z19jb25uZWN0aW9uc183ZFwiLCAyKVxuXG4gICAgaWYgKGVycm9yIHx8ICFyZHNJbnN0YW5jZXMpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdElkbGVSRFNGcm9tRGF0YShyZHNJbnN0YW5jZXMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlkbGUgRWxhc3RpQ2FjaGUgY2x1c3RlcnMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKlxuICAgKiBSRUxBWEVEIENSSVRFUklBOiBEZXRlY3RzIEVsYXN0aUNhY2hlIGFzIGlkbGUgaWYgQU5ZIG9mOlxuICAgKiAtIENQVSA8IDE1JSAobG93IHV0aWxpemF0aW9uKVxuICAgKiAtIENvbm5lY3Rpb25zIDw9IDMgKHZlcnkgZmV3IGFjdGl2ZSBjb25uZWN0aW9ucylcbiAgICogLSBFbnZpcm9ubWVudCBpcyBwcmV2aWV3L2Rldi9zdGFnaW5nIHdpdGggbG93IGFjdGl2aXR5XG4gICAqL1xuICBwcml2YXRlIGRldGVjdElkbGVDYWNoZUZyb21EYXRhKGNsdXN0ZXJzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRWxhc3RpQ2FjaGUgSWRsZTogQ2hlY2tpbmcgJHtjbHVzdGVycy5sZW5ndGh9IGNhY2hlIGNsdXN0ZXJzYClcblxuICAgIC8vIEZpbHRlcjogY2x1c3RlcnMgd2l0aCBsb3cgQ1BVIE9SIGxvdyBjb25uZWN0aW9ucyBPUiBub24tcHJvZCB3aXRoIGxvdyBhY3Rpdml0eVxuICAgIGNvbnN0IGZpbHRlcmVkID0gY2x1c3RlcnMuZmlsdGVyKChjKSA9PiB7XG4gICAgICAvLyBHZXQgQ1BVIHZhbHVlIHdpdGggbnVsbCBoYW5kbGluZ1xuICAgICAgY29uc3QgYXZnQ3B1ID0gYy5hdmdfY3B1XzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDcHUgPSBjLmN1cnJlbnRfY3B1IGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGNwdVZhbHVlID0gYXZnQ3B1ID8/IGN1cnJlbnRDcHVcblxuICAgICAgLy8gR2V0IGNvbm5lY3Rpb25zIHdpdGggbnVsbCBoYW5kbGluZ1xuICAgICAgY29uc3QgYXZnQ29ubmVjdGlvbnMgPSBjLmF2Z19jb25uZWN0aW9uc183ZCBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjdXJyZW50Q29ubmVjdGlvbnMgPSBjLmN1cnJlbnRfY29ubmVjdGlvbnMgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY29ubmVjdGlvbnNWYWx1ZSA9IGF2Z0Nvbm5lY3Rpb25zID8/IGN1cnJlbnRDb25uZWN0aW9uc1xuXG4gICAgICAvLyBHZXQgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGVudiA9ICgoYy5lbnYgYXMgc3RyaW5nKSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXG4gICAgICBjb25zdCBpc05vblByb2QgPSBlbnYuaW5jbHVkZXMoXCJwcmV2aWV3XCIpIHx8IGVudi5pbmNsdWRlcyhcImRldlwiKSB8fCBlbnYuaW5jbHVkZXMoXCJzdGFnaW5nXCIpIHx8IGVudi5pbmNsdWRlcyhcInRlc3RcIilcblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gQ2FjaGU6ICR7Yy5jbHVzdGVyX2lkfSB8IENQVTogJHtjcHVWYWx1ZX0lIHwgQ29ubjogJHtjb25uZWN0aW9uc1ZhbHVlfSB8IEVudjogJHtlbnZ9YClcblxuICAgICAgLy8gUkVMQVhFRDogVXNlIE9SIGxvZ2ljIC0gZGV0ZWN0IGlmIEFOWSBjb25kaXRpb24gaXMgbWV0XG4gICAgICBjb25zdCBpc0xvd0NwdSA9IGNwdVZhbHVlICE9PSBudWxsICYmIGNwdVZhbHVlICE9PSB1bmRlZmluZWQgJiYgY3B1VmFsdWUgPCAxNVxuICAgICAgY29uc3QgaXNMb3dDb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zVmFsdWUgIT09IG51bGwgJiYgY29ubmVjdGlvbnNWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNvbm5lY3Rpb25zVmFsdWUgPD0gM1xuICAgICAgY29uc3QgaXNJZGxlTm9uUHJvZCA9IGlzTm9uUHJvZCAmJiBjcHVWYWx1ZSAhPT0gbnVsbCAmJiBjcHVWYWx1ZSA8IDI1ICYmIChjb25uZWN0aW9uc1ZhbHVlID09PSBudWxsIHx8IGNvbm5lY3Rpb25zVmFsdWUgPCAxMClcblxuICAgICAgLy8gSWYgYm90aCBtZXRyaWNzIGFyZSBudWxsLCBjb25zaWRlciBpdCBwb3RlbnRpYWxseSBpZGxlXG4gICAgICBjb25zdCBoYXNOb01ldHJpY3MgPSAoY3B1VmFsdWUgPT09IG51bGwgfHwgY3B1VmFsdWUgPT09IHVuZGVmaW5lZCkgJiYgKGNvbm5lY3Rpb25zVmFsdWUgPT09IG51bGwgfHwgY29ubmVjdGlvbnNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuXG4gICAgICBpZiAoIWlzTG93Q3B1ICYmICFpc0xvd0Nvbm5lY3Rpb25zICYmICFpc0lkbGVOb25Qcm9kICYmICFoYXNOb01ldHJpY3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogQ1BVICR7Y3B1VmFsdWV9JSA+PSAxNSwgQ29ubiAke2Nvbm5lY3Rpb25zVmFsdWV9ID4gMywgbm90IGlkbGUgbm9uLXByb2RgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IElkbGUgY2FjaGUgY2x1c3RlciBkZXRlY3RlZCAobG93Q1BVOiAke2lzTG93Q3B1fSwgbG93Q29ubjogJHtpc0xvd0Nvbm5lY3Rpb25zfSwgaWRsZU5vblByb2Q6ICR7aXNJZGxlTm9uUHJvZH0pYClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIEVsYXN0aUNhY2hlIElkbGU6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBpZGxlIGNhY2hlIGNsdXN0ZXJzYClcblxuICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoKGNsdXN0ZXIpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLmlkbGVfY2FjaGVcbiAgICAgIGNvbnN0IG1vbnRobHlDb3N0ID0gZ2V0Q2FjaGVNb250aGx5Q29zdChjbHVzdGVyLm5vZGVfdHlwZSBhcyBzdHJpbmcsIGNsdXN0ZXIubnVtX25vZGVzIGFzIG51bWJlcilcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIG51bGwgaGFuZGxpbmdcbiAgICAgIGNvbnN0IGF2Z0NwdSA9IGNsdXN0ZXIuYXZnX2NwdV83ZCBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjdXJyZW50Q3B1ID0gY2x1c3Rlci5jdXJyZW50X2NwdSBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjcHVWYWx1ZSA9IGF2Z0NwdSA/PyBjdXJyZW50Q3B1ID8/IDBcbiAgICAgIGNvbnN0IGF2Z0Nvbm5lY3Rpb25zID0gY2x1c3Rlci5hdmdfY29ubmVjdGlvbnNfN2QgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25zID0gY2x1c3Rlci5jdXJyZW50X2Nvbm5lY3Rpb25zIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25zVmFsdWUgPSBhdmdDb25uZWN0aW9ucyA/PyBjdXJyZW50Q29ubmVjdGlvbnMgPz8gMFxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoY3B1VmFsdWUgPCAxKSBjb25maWRlbmNlICs9IDE1XG4gICAgICBpZiAoY29ubmVjdGlvbnNWYWx1ZSA9PT0gMCkgY29uZmlkZW5jZSArPSAxMFxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcImlkbGVfY2FjaGVcIixcbiAgICAgICAgcmVzb3VyY2U6IGNsdXN0ZXIsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJjYWNoZV9jbHVzdGVyc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwiY2x1c3Rlcl9pZFwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjbHVzdGVySWQ6IGNsdXN0ZXIuY2x1c3Rlcl9pZCxcbiAgICAgICAgICBub2RlVHlwZTogY2x1c3Rlci5ub2RlX3R5cGUsXG4gICAgICAgICAgbnVtTm9kZXM6IGNsdXN0ZXIubnVtX25vZGVzLFxuICAgICAgICAgIGVuZ2luZTogY2x1c3Rlci5lbmdpbmUsXG4gICAgICAgICAgYXZnQ3B1N2Q6IGNwdVZhbHVlLFxuICAgICAgICAgIGF2Z0Nvbm5lY3Rpb25zN2Q6IGNvbm5lY3Rpb25zVmFsdWUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvblxuICBwcml2YXRlIGFzeW5jIGRldGVjdElkbGVDYWNoZSgpOiBQcm9taXNlPFdhc3RlRGV0ZWN0aW9uW10+IHtcbiAgICBjb25zdCB7IGRhdGE6IGNsdXN0ZXJzLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxuICAgICAgLmZyb20oXCJjYWNoZV9jbHVzdGVyc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5sdChcImF2Z19jcHVfN2RcIiwgNSlcbiAgICAgIC5sdChcImF2Z19jb25uZWN0aW9uc183ZFwiLCA1KVxuXG4gICAgaWYgKGVycm9yIHx8ICFjbHVzdGVycykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0SWRsZUNhY2hlRnJvbURhdGEoY2x1c3RlcnMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlkbGUgTG9hZCBCYWxhbmNlcnMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RJZGxlTG9hZEJhbGFuY2Vyc0Zyb21EYXRhKGxiczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIExvYWQgQmFsYW5jZXIgSWRsZTogQ2hlY2tpbmcgJHtsYnMubGVuZ3RofSBsb2FkIGJhbGFuY2Vyc2ApXG5cbiAgICAvLyBGaWx0ZXI6IGxvYWQgYmFsYW5jZXJzIHdpdGggYXZnX3JlcXVlc3RfY291bnRfN2QgPCAxMDAwXG4gICAgY29uc3QgZmlsdGVyZWQgPSBsYnMuZmlsdGVyKChsYikgPT4ge1xuICAgICAgLy8gR2V0IHJlcXVlc3QgY291bnQgd2l0aCBudWxsIGhhbmRsaW5nXG4gICAgICBjb25zdCBhdmdSZXF1ZXN0Q291bnQgPSBsYi5hdmdfcmVxdWVzdF9jb3VudF83ZCBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjdXJyZW50UmVxdWVzdENvdW50ID0gbGIuY3VycmVudF9yZXF1ZXN0X2NvdW50IGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IHJlcXVlc3RDb3VudCA9IGF2Z1JlcXVlc3RDb3VudCA/PyBjdXJyZW50UmVxdWVzdENvdW50XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIExCOiAke2xiLm5hbWV9IHwgYXZnX3JlcXVlc3RfY291bnRfN2Q6ICR7YXZnUmVxdWVzdENvdW50fSB8IGN1cnJlbnRfcmVxdWVzdF9jb3VudDogJHtjdXJyZW50UmVxdWVzdENvdW50fWApXG5cbiAgICAgIC8vIElmIG1ldHJpY3MgYXJlIG51bGwsIGNvbnNpZGVyIGl0IGlkbGUgKG5vIGFjdGl2aXR5IGRhdGEgbWVhbnMgbGlrZWx5IHVudXNlZClcbiAgICAgIGNvbnN0IHJlcXVlc3RDaGVjayA9IHJlcXVlc3RDb3VudCA9PT0gbnVsbCB8fCByZXF1ZXN0Q291bnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiByZXF1ZXN0Q291bnQgPCAxMDAwXG5cbiAgICAgIGlmICghcmVxdWVzdENoZWNrKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IFJlcXVlc3QgY291bnQgJHtyZXF1ZXN0Q291bnQgPz8gJ04vQSd9IDwgMTAwMDogJHtyZXF1ZXN0Q2hlY2t9YClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIE1BVENIOiBJZGxlIGxvYWQgYmFsYW5jZXIgZGV0ZWN0ZWRgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTG9hZCBCYWxhbmNlciBJZGxlOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gaWRsZSBsb2FkIGJhbGFuY2Vyc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChsYikgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1MuaWRsZV9sb2FkX2JhbGFuY2VyXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldExvYWRCYWxhbmNlck1vbnRobHlDb3N0KDAuMSlcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIG51bGwgaGFuZGxpbmdcbiAgICAgIGNvbnN0IGF2Z1JlcXVlc3RDb3VudCA9IGxiLmF2Z19yZXF1ZXN0X2NvdW50XzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0Q291bnQgPSBsYi5jdXJyZW50X3JlcXVlc3RfY291bnQgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgcmVxdWVzdENvdW50ID0gYXZnUmVxdWVzdENvdW50ID8/IGN1cnJlbnRSZXF1ZXN0Q291bnQgPz8gMFxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAocmVxdWVzdENvdW50IDwgMTAwKSBjb25maWRlbmNlICs9IDE1XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwiaWRsZV9sb2FkX2JhbGFuY2VyXCIsXG4gICAgICAgIHJlc291cmNlOiBsYixcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcImxvYWRfYmFsYW5jZXJzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIG5hbWU6IGxiLm5hbWUsXG4gICAgICAgICAgdHlwZTogbGIudHlwZSxcbiAgICAgICAgICBlbnY6IGxiLmVudixcbiAgICAgICAgICBhdmdSZXF1ZXN0Q291bnQ3ZDogcmVxdWVzdENvdW50LFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gTGVnYWN5IGFzeW5jIHZlcnNpb25cbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RJZGxlTG9hZEJhbGFuY2VycygpOiBQcm9taXNlPFdhc3RlRGV0ZWN0aW9uW10+IHtcbiAgICBjb25zdCB7IGRhdGE6IGxicywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwibG9hZF9iYWxhbmNlcnNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAubHQoXCJhdmdfcmVxdWVzdF9jb3VudF83ZFwiLCAxMDAwKVxuXG4gICAgaWYgKGVycm9yIHx8ICFsYnMpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdElkbGVMb2FkQmFsYW5jZXJzRnJvbURhdGEobGJzKVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBvdmVyLXByb3Zpc2lvbmVkIExhbWJkYSBmdW5jdGlvbnMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RPdmVyUHJvdmlzaW9uZWRMYW1iZGFzRnJvbURhdGEobGFtYmRhczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIExhbWJkYSBPdmVyLXByb3Zpc2lvbmVkOiBDaGVja2luZyAke2xhbWJkYXMubGVuZ3RofSBMYW1iZGEgZnVuY3Rpb25zYClcblxuICAgIC8vIEZpbHRlcjogZnVuY3Rpb25zIHdpdGggbWVtb3J5IGRhdGEgYW5kIHVzaW5nIDwgNTAlIG9mIGFsbG9jYXRlZCBtZW1vcnlcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGxhbWJkYXMuZmlsdGVyKChmbikgPT4ge1xuICAgICAgY29uc3QgYXZnTWVtb3J5ID0gZm4uYXZnX21lbW9yeV91c2VkX21iXzdkIGFzIG51bWJlclxuICAgICAgY29uc3QgbWVtb3J5TWIgPSBmbi5tZW1vcnlfbWIgYXMgbnVtYmVyXG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIExhbWJkYTogJHtmbi5uYW1lfSB8IG1lbW9yeV9tYjogJHttZW1vcnlNYn0gfCBhdmdfbWVtb3J5X3VzZWRfbWJfN2Q6ICR7YXZnTWVtb3J5fWApXG5cbiAgICAgIGlmICghYXZnTWVtb3J5IHx8ICFtZW1vcnlNYikge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBNaXNzaW5nIG1lbW9yeSBtZXRyaWNzIChhdmdfbWVtb3J5OiAke2F2Z01lbW9yeX0sIG1lbW9yeV9tYjogJHttZW1vcnlNYn0pYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHV0aWxpemF0aW9uUGN0ID0gKGF2Z01lbW9yeSAvIG1lbW9yeU1iKSAqIDEwMFxuICAgICAgaWYgKHV0aWxpemF0aW9uUGN0ID49IDUwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IE1lbW9yeSB1dGlsaXphdGlvbiAke3V0aWxpemF0aW9uUGN0LnRvRml4ZWQoMSl9JSA+PSA1MCVgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IE92ZXItcHJvdmlzaW9uZWQgTGFtYmRhICgke3V0aWxpemF0aW9uUGN0LnRvRml4ZWQoMSl9JSB1dGlsaXphdGlvbilgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTGFtYmRhIE92ZXItcHJvdmlzaW9uZWQ6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBvdmVyLXByb3Zpc2lvbmVkIGZ1bmN0aW9uc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChmbikgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub3Zlcl9wcm92aXNpb25lZF9sYW1iZGFcbiAgICAgIGNvbnN0IGF2Z01lbW9yeSA9IGZuLmF2Z19tZW1vcnlfdXNlZF9tYl83ZCBhcyBudW1iZXJcbiAgICAgIGNvbnN0IG1lbW9yeU1iID0gZm4ubWVtb3J5X21iIGFzIG51bWJlclxuICAgICAgY29uc3QgdXRpbGl6YXRpb25QY3QgPSAoYXZnTWVtb3J5IC8gbWVtb3J5TWIpICogMTAwXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBvcHRpbWFsIG1lbW9yeSAocm91bmQgdXAgdG8gbmVhcmVzdCA2NE1CLCB3aXRoIDEuNXggc2FmZXR5IG1hcmdpbilcbiAgICAgIGNvbnN0IG9wdGltYWxNZW1vcnkgPSBNYXRoLm1heCgxMjgsIE1hdGguY2VpbCgoYXZnTWVtb3J5ICogMS41KSAvIDY0KSAqIDY0KVxuXG4gICAgICAvLyBHZXQgYWN0dWFsIG1ldHJpY3MgZnJvbSB0aGUgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGludm9jYXRpb25zN2QgPSAoZm4uaW52b2NhdGlvbnNfN2QgYXMgbnVtYmVyKSB8fCAwXG4gICAgICBjb25zdCBhdmdEdXJhdGlvbk1zID0gKGZuLmF2Z19kdXJhdGlvbl9tc183ZCBhcyBudW1iZXIpIHx8IDBcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCA3LWRheSBtZXRyaWNzIHRvIG1vbnRobHkgKG11bHRpcGx5IGJ5IH40LjI4NTcpXG4gICAgICBjb25zdCBtb250aGx5SW52b2NhdGlvbnMgPSBpbnZvY2F0aW9uczdkICogKDMwIC8gNylcbiAgICAgIFxuICAgICAgLy8gVXNlIGVzdGltYXRlZF9tb250aGx5X2Nvc3QgZnJvbSBkYXRhYmFzZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBjYWxjdWxhdGVcbiAgICAgIGxldCBtb250aGx5Q29zdDogbnVtYmVyXG4gICAgICBpZiAoZm4uZXN0aW1hdGVkX21vbnRobHlfY29zdCAmJiAoZm4uZXN0aW1hdGVkX21vbnRobHlfY29zdCBhcyBudW1iZXIpID4gMCkge1xuICAgICAgICBtb250aGx5Q29zdCA9IGZuLmVzdGltYXRlZF9tb250aGx5X2Nvc3QgYXMgbnVtYmVyXG4gICAgICB9IGVsc2UgaWYgKGludm9jYXRpb25zN2QgPiAwICYmIGF2Z0R1cmF0aW9uTXMgPiAwKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtb250aGx5IGNvc3QgdXNpbmcgcHJvcGVyIHByaWNpbmcgZnVuY3Rpb25cbiAgICAgICAgbW9udGhseUNvc3QgPSBnZXRMYW1iZGFNb250aGx5Q29zdChtZW1vcnlNYiwgYXZnRHVyYXRpb25NcywgbW9udGhseUludm9jYXRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBhIHJlYXNvbmFibGUgZXN0aW1hdGUgYmFzZWQgb24gbWVtb3J5IGFsbG9jYXRpb25cbiAgICAgICAgLy8gTGFtYmRhIG1pbmltdW0gY29zdCBmb3IgYSBmdW5jdGlvbiB3aXRoIGF2ZXJhZ2UgdXNhZ2VcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkSW52b2NhdGlvbnNQZXJNb250aCA9IDEwMDAwMCAvLyBjb25zZXJ2YXRpdmUgZXN0aW1hdGVcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkQXZnRHVyYXRpb24gPSBhdmdEdXJhdGlvbk1zIHx8IDEwMCAvLyBtc1xuICAgICAgICBtb250aGx5Q29zdCA9IGdldExhbWJkYU1vbnRobHlDb3N0KG1lbW9yeU1iLCBlc3RpbWF0ZWRBdmdEdXJhdGlvbiwgZXN0aW1hdGVkSW52b2NhdGlvbnNQZXJNb250aClcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIG9wdGltaXplZCBtb250aGx5IGNvc3Qgd2l0aCB0aGUgcmVjb21tZW5kZWQgbWVtb3J5XG4gICAgICBsZXQgb3B0aW1pemVkTW9udGhseUNvc3Q6IG51bWJlclxuICAgICAgaWYgKGludm9jYXRpb25zN2QgPiAwICYmIGF2Z0R1cmF0aW9uTXMgPiAwKSB7XG4gICAgICAgIG9wdGltaXplZE1vbnRobHlDb3N0ID0gZ2V0TGFtYmRhTW9udGhseUNvc3Qob3B0aW1hbE1lbW9yeSwgYXZnRHVyYXRpb25NcywgbW9udGhseUludm9jYXRpb25zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGVzdGltYXRlZCBpbnZvY2F0aW9ucyBhcyB3ZSB1c2VkIGZvciBjdXJyZW50IGNvc3RcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkSW52b2NhdGlvbnNQZXJNb250aCA9IG1vbnRobHlJbnZvY2F0aW9ucyA+IDAgPyBtb250aGx5SW52b2NhdGlvbnMgOiAxMDAwMDBcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkQXZnRHVyYXRpb24gPSBhdmdEdXJhdGlvbk1zID4gMCA/IGF2Z0R1cmF0aW9uTXMgOiAxMDBcbiAgICAgICAgb3B0aW1pemVkTW9udGhseUNvc3QgPSBnZXRMYW1iZGFNb250aGx5Q29zdChvcHRpbWFsTWVtb3J5LCBlc3RpbWF0ZWRBdmdEdXJhdGlvbiwgZXN0aW1hdGVkSW52b2NhdGlvbnNQZXJNb250aClcbiAgICAgIH1cblxuICAgICAgLy8gUG90ZW50aWFsIHNhdmluZ3MgaXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcHRpbWl6ZWQgY29zdHNcbiAgICAgIGNvbnN0IHBvdGVudGlhbFNhdmluZ3MgPSBNYXRoLm1heCgwLCBtb250aGx5Q29zdCAtIG9wdGltaXplZE1vbnRobHlDb3N0KVxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAodXRpbGl6YXRpb25QY3QgPCAyNSkgY29uZmlkZW5jZSArPSAxMFxuICAgICAgaWYgKHV0aWxpemF0aW9uUGN0IDwgMTApIGNvbmZpZGVuY2UgKz0gNVxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcIm92ZXJfcHJvdmlzaW9uZWRfbGFtYmRhXCIsXG4gICAgICAgIHJlc291cmNlOiBmbixcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcImxhbWJkYV9mdW5jdGlvbnNcIixcbiAgICAgICAgbmFtZUZpZWxkOiBcIm5hbWVcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZuLm5hbWUsXG4gICAgICAgICAgY3VycmVudE1lbW9yeU1iOiBtZW1vcnlNYixcbiAgICAgICAgICBhdmdNZW1vcnlVc2VkTWI6IGF2Z01lbW9yeSxcbiAgICAgICAgICB1dGlsaXphdGlvblBjdDogTWF0aC5yb3VuZCh1dGlsaXphdGlvblBjdCksXG4gICAgICAgICAgcmVjb21tZW5kZWRNZW1vcnlNYjogb3B0aW1hbE1lbW9yeSxcbiAgICAgICAgICBpbnZvY2F0aW9uczdkLFxuICAgICAgICAgIGF2Z0R1cmF0aW9uTXMsXG4gICAgICAgICAgY3VycmVudE1vbnRobHlDb3N0OiBtb250aGx5Q29zdCxcbiAgICAgICAgICBvcHRpbWl6ZWRNb250aGx5Q29zdCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIExlZ2FjeSBhc3luYyB2ZXJzaW9uXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0T3ZlclByb3Zpc2lvbmVkTGFtYmRhcygpOiBQcm9taXNlPFdhc3RlRGV0ZWN0aW9uW10+IHtcbiAgICBjb25zdCB7IGRhdGE6IGxhbWJkYXMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXG4gICAgICAuZnJvbShcImxhbWJkYV9mdW5jdGlvbnNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAubm90KFwiYXZnX21lbW9yeV91c2VkX21iXzdkXCIsIFwiaXNcIiwgbnVsbClcblxuICAgIGlmIChlcnJvciB8fCAhbGFtYmRhcykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0T3ZlclByb3Zpc2lvbmVkTGFtYmRhc0Zyb21EYXRhKGxhbWJkYXMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IFMzIGJ1Y2tldHMgd2l0aG91dCBsaWZlY3ljbGUgcG9saWNpZXMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RTM05vTGlmZWN5Y2xlRnJvbURhdGEoYnVja2V0czogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFMzIE5vIExpZmVjeWNsZTogQ2hlY2tpbmcgJHtidWNrZXRzLmxlbmd0aH0gUzMgYnVja2V0c2ApXG5cbiAgICAvLyBGaWx0ZXI6IGJ1Y2tldHMgd2l0aCBlbXB0eSBvciBubyBsaWZlY3ljbGUgcG9saWN5L3J1bGVzXG4gICAgY29uc3QgZmlsdGVyZWQgPSBidWNrZXRzLmZpbHRlcigoYikgPT4ge1xuICAgICAgLy8gQ2hlY2sgYm90aCBsaWZlY3ljbGVfcG9saWN5IGFuZCBsaWZlY3ljbGVfcnVsZXMgY29sdW1uc1xuICAgICAgY29uc3QgcG9saWN5ID0gYi5saWZlY3ljbGVfcG9saWN5IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbFxuICAgICAgY29uc3QgcnVsZXMgPSBiLmxpZmVjeWNsZV9ydWxlcyBhcyB1bmtub3duW10gfCBudWxsXG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFMzOiAke2IubmFtZX0gfCBsaWZlY3ljbGVfcG9saWN5OiAke3BvbGljeSA/ICdzZXQnIDogJ251bGwnfSB8IGxpZmVjeWNsZV9ydWxlczogJHtydWxlcyA/IGAke3J1bGVzLmxlbmd0aH0gcnVsZXNgIDogJ251bGwnfWApXG5cbiAgICAgIC8vIEhhcyBydWxlcyBpbiBsaWZlY3ljbGVfcnVsZXMgY29sdW1uPyBTa2lwXG4gICAgICBpZiAocnVsZXMgJiYgQXJyYXkuaXNBcnJheShydWxlcykgJiYgcnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBIYXMgJHtydWxlcy5sZW5ndGh9IGxpZmVjeWNsZSBydWxlc2ApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBIYXMgcG9saWN5IGluIGxpZmVjeWNsZV9wb2xpY3kgY29sdW1uPyBTa2lwXG4gICAgICBpZiAocG9saWN5ICYmIE9iamVjdC5rZXlzKHBvbGljeSkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwb2xpY3lSdWxlcyA9IChwb2xpY3kgYXMgeyBydWxlcz86IHVua25vd25bXSB9KS5ydWxlc1xuICAgICAgICBpZiAocG9saWN5UnVsZXMgJiYgcG9saWN5UnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IEhhcyBsaWZlY3ljbGUgcG9saWN5IHdpdGggJHtwb2xpY3lSdWxlcy5sZW5ndGh9IHJ1bGVzYClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogUzMgYnVja2V0IHdpdGhvdXQgbGlmZWN5Y2xlIHBvbGljeWApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBTMyBObyBMaWZlY3ljbGU6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBidWNrZXRzIHdpdGhvdXQgbGlmZWN5Y2xlYClcblxuICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoKGJ1Y2tldCkgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1MuczNfbm9fbGlmZWN5Y2xlXG4gICAgICBjb25zdCBlc3RpbWF0ZWRTaXplR2IgPSAxMDBcbiAgICAgIGNvbnN0IG1vbnRobHlDb3N0ID0gZXN0aW1hdGVkU2l6ZUdiICogMC4wMjNcbiAgICAgIGNvbnN0IHBvdGVudGlhbFNhdmluZ3MgPSBnZXRTM1RpZXJpbmdTYXZpbmdzKGVzdGltYXRlZFNpemVHYilcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJzM19ub19saWZlY3ljbGVcIixcbiAgICAgICAgcmVzb3VyY2U6IGJ1Y2tldCxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcInMzX2J1Y2tldHNcIixcbiAgICAgICAgbmFtZUZpZWxkOiBcIm5hbWVcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgICAgIGNvbmZpZGVuY2U6IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgYnVja2V0TmFtZTogYnVja2V0Lm5hbWUsXG4gICAgICAgICAgZW52OiBidWNrZXQuZW52LFxuICAgICAgICAgIGxpZmVjeWNsZVBvbGljeTogYnVja2V0LmxpZmVjeWNsZV9wb2xpY3ksXG4gICAgICAgICAgcmVjb21tZW5kYXRpb246IFwiQWRkIGxpZmVjeWNsZSBwb2xpY3kgdG8gdGllciBkYXRhIHRvIGNoZWFwZXIgc3RvcmFnZVwiLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gTGVnYWN5IGFzeW5jIHZlcnNpb25cbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RTM05vTGlmZWN5Y2xlKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogYnVja2V0cywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiczNfYnVja2V0c1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcblxuICAgIGlmIChlcnJvciB8fCAhYnVja2V0cykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0UzNOb0xpZmVjeWNsZUZyb21EYXRhKGJ1Y2tldHMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IENsb3VkV2F0Y2ggTG9nIEdyb3VwcyB3aXRob3V0IHJldGVudGlvbiAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqL1xuICBwcml2YXRlIGRldGVjdExvZ05vUmV0ZW50aW9uRnJvbURhdGEobG9nR3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTG9nIE5vIFJldGVudGlvbjogQ2hlY2tpbmcgJHtsb2dHcm91cHMubGVuZ3RofSBDbG91ZFdhdGNoIGxvZyBncm91cHNgKVxuXG4gICAgLy8gRmlsdGVyOiBsb2cgZ3JvdXBzIHdpdGggbm8gcmV0ZW50aW9uIHNldCAoY2hlY2sgYm90aCByZXRlbnRpb25fZGF5cyBhbmQgcmV0ZW50aW9uX2luX2RheXMpXG4gICAgY29uc3QgZmlsdGVyZWQgPSBsb2dHcm91cHMuZmlsdGVyKChsZykgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTG9nIEdyb3VwOiAke2xnLm5hbWV9IHwgcmV0ZW50aW9uX2RheXM6ICR7bGcucmV0ZW50aW9uX2RheXN9IHwgcmV0ZW50aW9uX2luX2RheXM6ICR7bGcucmV0ZW50aW9uX2luX2RheXN9YClcblxuICAgICAgLy8gU2tpcCBpZiByZXRlbnRpb25faW5fZGF5cyBpcyBzZXQgKGZyb20gZXhlY3V0b3IpXG4gICAgICBpZiAobGcucmV0ZW50aW9uX2luX2RheXMgIT09IG51bGwgJiYgbGcucmV0ZW50aW9uX2luX2RheXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBIYXMgcmV0ZW50aW9uX2luX2RheXMgc2V0IHRvICR7bGcucmV0ZW50aW9uX2luX2RheXN9YClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBTa2lwIGlmIHJldGVudGlvbl9kYXlzIGlzIHNldCAob3JpZ2luYWwgY29sdW1uKVxuICAgICAgaWYgKGxnLnJldGVudGlvbl9kYXlzICE9PSBudWxsICYmIGxnLnJldGVudGlvbl9kYXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogSGFzIHJldGVudGlvbl9kYXlzIHNldCB0byAke2xnLnJldGVudGlvbl9kYXlzfWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogTG9nIGdyb3VwIHdpdGhvdXQgcmV0ZW50aW9uIHBvbGljeWApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBMb2cgTm8gUmV0ZW50aW9uOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gbG9nIGdyb3VwcyB3aXRob3V0IHJldGVudGlvbmApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChsZykgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1MubG9nX25vX3JldGVudGlvblxuICAgICAgY29uc3QgZXN0aW1hdGVkU2l6ZUdiID0gMTBcbiAgICAgIGNvbnN0IGN1cnJlbnRNb250aGx5Q29zdCA9IGVzdGltYXRlZFNpemVHYiAqIDAuMDNcbiAgICAgIGNvbnN0IHBvdGVudGlhbFNhdmluZ3MgPSBjdXJyZW50TW9udGhseUNvc3QgKiAwLjlcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJsb2dfbm9fcmV0ZW50aW9uXCIsXG4gICAgICAgIHJlc291cmNlOiBsZyxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcImxvZ19ncm91cHNcIixcbiAgICAgICAgbmFtZUZpZWxkOiBcIm5hbWVcIixcbiAgICAgICAgbW9udGhseUNvc3Q6IGN1cnJlbnRNb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5ncyxcbiAgICAgICAgY29uZmlkZW5jZTogc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2UsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBsb2dHcm91cE5hbWU6IGxnLm5hbWUsXG4gICAgICAgICAgZW52OiBsZy5lbnYsXG4gICAgICAgICAgY3VycmVudFJldGVudGlvbjogXCJOZXZlciBleHBpcmVzXCIsXG4gICAgICAgICAgcmVjb21tZW5kZWRSZXRlbnRpb246IFwiMzAgZGF5c1wiLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gTGVnYWN5IGFzeW5jIHZlcnNpb25cbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RMb2dOb1JldGVudGlvbigpOiBQcm9taXNlPFdhc3RlRGV0ZWN0aW9uW10+IHtcbiAgICBjb25zdCB7IGRhdGE6IGxvZ0dyb3VwcywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwibG9nX2dyb3Vwc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5pcyhcInJldGVudGlvbl9kYXlzXCIsIG51bGwpXG5cbiAgICBpZiAoZXJyb3IgfHwgIWxvZ0dyb3VwcykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0TG9nTm9SZXRlbnRpb25Gcm9tRGF0YShsb2dHcm91cHMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGZvcmdvdHRlbiBwcmV2aWV3IGVudmlyb25tZW50cyAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqIEFTR3Mgd2l0aCAncHJldmlldycgaW4gbmFtZSBvciBlbnYsIHdpdGggbG93IHV0aWxpemF0aW9uXG4gICAqL1xuICBwcml2YXRlIGRldGVjdEZvcmdvdHRlblByZXZpZXdzRnJvbURhdGEoYXNnczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIEZvcmdvdHRlbiBQcmV2aWV3czogQ2hlY2tpbmcgJHthc2dzLmxlbmd0aH0gQXV0byBTY2FsaW5nIEdyb3Vwc2ApXG5cbiAgICAvLyBGaWx0ZXIgZm9yIHByZXZpZXcgZW52aXJvbm1lbnRzIHdpdGggbG93IHV0aWxpemF0aW9uXG4gICAgLy8gU2tpcCBBU0dzIHdpdGggZGVzaXJlZF9jYXBhY2l0eSA9IDAgKGFscmVhZHkgdGVybWluYXRlZClcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGFzZ3MuZmlsdGVyKChhc2cpID0+IHtcbiAgICAgIGNvbnN0IGRlc2lyZWRDYXBhY2l0eSA9IGFzZy5kZXNpcmVkX2NhcGFjaXR5IGFzIG51bWJlclxuICAgICAgY29uc3QgZW52ID0gKGFzZy5lbnYgYXMgc3RyaW5nKT8udG9Mb3dlckNhc2UoKSB8fCBcIlwiXG4gICAgICBjb25zdCBuYW1lID0gKGFzZy5uYW1lIGFzIHN0cmluZyk/LnRvTG93ZXJDYXNlKCkgfHwgXCJcIlxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBBU0cgKFByZXZpZXcpOiAke2FzZy5uYW1lfSB8IGVudjogJHtlbnZ9IHwgY2FwYWNpdHk6ICR7ZGVzaXJlZENhcGFjaXR5fSB8IHV0aWxpemF0aW9uOiAke2FzZy5jdXJyZW50X3V0aWxpemF0aW9ufWApXG5cbiAgICAgIC8vIFNraXAgYWxyZWFkeSB0ZXJtaW5hdGVkIEFTR3MgKGNhcGFjaXR5ID0gMClcbiAgICAgIGlmICghZGVzaXJlZENhcGFjaXR5IHx8IGRlc2lyZWRDYXBhY2l0eSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBDYXBhY2l0eSBpcyAwIChhbHJlYWR5IHRlcm1pbmF0ZWQpYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzUHJldmlldyA9IGVudi5pbmNsdWRlcyhcInByZXZpZXdcIikgfHwgbmFtZS5pbmNsdWRlcyhcInByZXZpZXdcIikgfHwgbmFtZS5pbmNsdWRlcyhcInByLVwiKVxuICAgICAgaWYgKCFpc1ByZXZpZXcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogTm90IGEgcHJldmlldyBlbnZpcm9ubWVudGApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0xvd1V0aWwgPSAhYXNnLmN1cnJlbnRfdXRpbGl6YXRpb24gfHwgKGFzZy5jdXJyZW50X3V0aWxpemF0aW9uIGFzIG51bWJlcikgPCAxMFxuICAgICAgaWYgKCFpc0xvd1V0aWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogVXRpbGl6YXRpb24gJHthc2cuY3VycmVudF91dGlsaXphdGlvbn0lID49IDEwJWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogRm9yZ290dGVuIHByZXZpZXcgZW52aXJvbm1lbnRgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRm9yZ290dGVuIFByZXZpZXdzOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gZm9yZ290dGVuIHByZXZpZXcgZW52aXJvbm1lbnRzYClcblxuICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoKGFzZykgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1MuZm9yZ290dGVuX3ByZXZpZXdcbiAgICAgIGNvbnN0IGluc3RhbmNlQ29zdCA9IGdldEVDMk1vbnRobHlDb3N0KGFzZy5pbnN0YW5jZV90eXBlIGFzIHN0cmluZylcbiAgICAgIGNvbnN0IG1vbnRobHlDb3N0ID0gaW5zdGFuY2VDb3N0ICogKGFzZy5kZXNpcmVkX2NhcGFjaXR5IGFzIG51bWJlcilcblxuICAgICAgbGV0IGNvbmZpZGVuY2UgPSBzY2VuYXJpby5iYXNlQ29uZmlkZW5jZVxuICAgICAgY29uc3QgZGF5c09sZCA9IHRoaXMuZGF5c1NpbmNlKGFzZy5jcmVhdGVkX2F0IGFzIHN0cmluZylcbiAgICAgIGlmIChkYXlzT2xkID4gNykgY29uZmlkZW5jZSArPSAxMFxuICAgICAgaWYgKGRheXNPbGQgPiAxNCkgY29uZmlkZW5jZSArPSA1XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwiZm9yZ290dGVuX3ByZXZpZXdcIixcbiAgICAgICAgcmVzb3VyY2U6IGFzZyxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcImF1dG9zY2FsaW5nX2dyb3Vwc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwibmFtZVwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBhc2dOYW1lOiBhc2cubmFtZSxcbiAgICAgICAgICBpbnN0YW5jZVR5cGU6IGFzZy5pbnN0YW5jZV90eXBlLFxuICAgICAgICAgIGRlc2lyZWRDYXBhY2l0eTogYXNnLmRlc2lyZWRfY2FwYWNpdHksXG4gICAgICAgICAgY3VycmVudFV0aWxpemF0aW9uOiBhc2cuY3VycmVudF91dGlsaXphdGlvbiB8fCAwLFxuICAgICAgICAgIGRheXNPbGQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvblxuICBwcml2YXRlIGFzeW5jIGRldGVjdEZvcmdvdHRlblByZXZpZXdzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogYXNncywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuXG4gICAgaWYgKGVycm9yIHx8ICFhc2dzKSByZXR1cm4gW11cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RGb3Jnb3R0ZW5QcmV2aWV3c0Zyb21EYXRhKGFzZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IG92ZXItcHJvdmlzaW9uZWQgQXV0byBTY2FsaW5nIEdyb3VwcyAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqIEFTR3Mgd2l0aCBtb3JlIGNhcGFjaXR5IHRoYW4gbmVlZGVkIGJhc2VkIG9uIHV0aWxpemF0aW9uXG4gICAqL1xuICBwcml2YXRlIGRldGVjdE92ZXJQcm92aXNpb25lZEFTR3NGcm9tRGF0YShhc2dzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gT3Zlci1wcm92aXNpb25lZCBBU0dzOiBDaGVja2luZyAke2FzZ3MubGVuZ3RofSBBdXRvIFNjYWxpbmcgR3JvdXBzYClcblxuICAgIC8vIEZpbHRlcjogQVNHcyB3aXRoIGRlc2lyZWRfY2FwYWNpdHkgPiAxLCBsb3cgdXRpbGl6YXRpb24sIGFuZCBtb3JlIHRoYW4gbWluX3NpemVcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGFzZ3MuZmlsdGVyKChhc2cpID0+IHtcbiAgICAgIGNvbnN0IGRlc2lyZWRDYXBhY2l0eSA9IGFzZy5kZXNpcmVkX2NhcGFjaXR5IGFzIG51bWJlclxuICAgICAgY29uc3QgdXRpbGl6YXRpb24gPSAoYXNnLmN1cnJlbnRfdXRpbGl6YXRpb24gYXMgbnVtYmVyKSB8fCAwXG4gICAgICBjb25zdCBtaW5TaXplID0gYXNnLm1pbl9zaXplIGFzIG51bWJlclxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBBU0cgKE92ZXItcHJvdik6ICR7YXNnLm5hbWV9IHwgY2FwYWNpdHk6ICR7ZGVzaXJlZENhcGFjaXR5fSB8IG1pbl9zaXplOiAke21pblNpemV9IHwgdXRpbGl6YXRpb246ICR7dXRpbGl6YXRpb259JWApXG5cbiAgICAgIGlmIChkZXNpcmVkQ2FwYWNpdHkgPD0gMSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBDYXBhY2l0eSAke2Rlc2lyZWRDYXBhY2l0eX0gPD0gMWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHV0aWxpemF0aW9uID49IDMwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IFV0aWxpemF0aW9uICR7dXRpbGl6YXRpb259JSA+PSAzMCVgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChkZXNpcmVkQ2FwYWNpdHkgPD0gbWluU2l6ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBDYXBhY2l0eSAke2Rlc2lyZWRDYXBhY2l0eX0gPD0gbWluX3NpemUgJHttaW5TaXplfWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogT3Zlci1wcm92aXNpb25lZCBBU0dgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gT3Zlci1wcm92aXNpb25lZCBBU0dzOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gb3Zlci1wcm92aXNpb25lZCBBU0dzYClcblxuICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoKGFzZykgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub3Zlcl9wcm92aXNpb25lZF9hc2dcbiAgICAgIGNvbnN0IHV0aWxpemF0aW9uID0gKGFzZy5jdXJyZW50X3V0aWxpemF0aW9uIGFzIG51bWJlcikgfHwgMFxuICAgICAgY29uc3QgZGVzaXJlZENhcGFjaXR5ID0gYXNnLmRlc2lyZWRfY2FwYWNpdHkgYXMgbnVtYmVyXG4gICAgICBjb25zdCBtaW5TaXplID0gYXNnLm1pbl9zaXplIGFzIG51bWJlclxuICAgICAgY29uc3QgaW5zdGFuY2VDb3N0ID0gZ2V0RUMyTW9udGhseUNvc3QoYXNnLmluc3RhbmNlX3R5cGUgYXMgc3RyaW5nKVxuICAgICAgY29uc3QgY3VycmVudE1vbnRobHlDb3N0ID0gaW5zdGFuY2VDb3N0ICogZGVzaXJlZENhcGFjaXR5XG5cbiAgICAgIGNvbnN0IG9wdGltYWxDYXBhY2l0eSA9IE1hdGgubWF4KFxuICAgICAgICBtaW5TaXplLFxuICAgICAgICBNYXRoLmNlaWwoZGVzaXJlZENhcGFjaXR5ICogKHV0aWxpemF0aW9uIC8gNTApKVxuICAgICAgKVxuICAgICAgY29uc3Qgc2F2aW5nc0NhcGFjaXR5ID0gZGVzaXJlZENhcGFjaXR5IC0gb3B0aW1hbENhcGFjaXR5XG4gICAgICBjb25zdCBwb3RlbnRpYWxTYXZpbmdzID0gaW5zdGFuY2VDb3N0ICogc2F2aW5nc0NhcGFjaXR5XG5cbiAgICAgIGxldCBjb25maWRlbmNlID0gc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2VcbiAgICAgIGlmICh1dGlsaXphdGlvbiA8IDIwKSBjb25maWRlbmNlICs9IDEwXG4gICAgICBpZiAodXRpbGl6YXRpb24gPCAxMCkgY29uZmlkZW5jZSArPSAxMFxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcIm92ZXJfcHJvdmlzaW9uZWRfYXNnXCIsXG4gICAgICAgIHJlc291cmNlOiBhc2csXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJhdXRvc2NhbGluZ19ncm91cHNcIixcbiAgICAgICAgbmFtZUZpZWxkOiBcIm5hbWVcIixcbiAgICAgICAgbW9udGhseUNvc3Q6IGN1cnJlbnRNb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5ncyxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGFzZ05hbWU6IGFzZy5uYW1lLFxuICAgICAgICAgIGluc3RhbmNlVHlwZTogYXNnLmluc3RhbmNlX3R5cGUsXG4gICAgICAgICAgY3VycmVudENhcGFjaXR5OiBkZXNpcmVkQ2FwYWNpdHksXG4gICAgICAgICAgbWluU2l6ZTogbWluU2l6ZSxcbiAgICAgICAgICBtYXhTaXplOiBhc2cubWF4X3NpemUsXG4gICAgICAgICAgY3VycmVudFV0aWxpemF0aW9uOiB1dGlsaXphdGlvbixcbiAgICAgICAgICByZWNvbW1lbmRlZENhcGFjaXR5OiBvcHRpbWFsQ2FwYWNpdHksXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvblxuICBwcml2YXRlIGFzeW5jIGRldGVjdE92ZXJQcm92aXNpb25lZEFTR3MoKTogUHJvbWlzZTxXYXN0ZURldGVjdGlvbltdPiB7XG4gICAgY29uc3QgeyBkYXRhOiBhc2dzLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZVxuICAgICAgLmZyb20oXCJhdXRvc2NhbGluZ19ncm91cHNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZ3QoXCJkZXNpcmVkX2NhcGFjaXR5XCIsIDEpXG5cbiAgICBpZiAoZXJyb3IgfHwgIWFzZ3MpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdE92ZXJQcm92aXNpb25lZEFTR3NGcm9tRGF0YShhc2dzKVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzdGFsZSBmZWF0dXJlIGJyYW5jaCBlbnZpcm9ubWVudHMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKiBBU0dzIHdpdGggJ2ZlYXR1cmUnIGluIG5hbWUsIG9sZGVyIHRoYW4gNyBkYXlzIHdpdGggbG93IHVzYWdlXG4gICAqL1xuICBwcml2YXRlIGRldGVjdFN0YWxlRmVhdHVyZUVudnNGcm9tRGF0YShhc2dzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gU3RhbGUgRmVhdHVyZSBFbnZzOiBDaGVja2luZyAke2FzZ3MubGVuZ3RofSBBdXRvIFNjYWxpbmcgR3JvdXBzYClcblxuICAgIC8vIEZpbHRlciBmb3IgZmVhdHVyZSBlbnZpcm9ubWVudHMgb2xkZXIgdGhhbiA3IGRheXNcbiAgICAvLyBTa2lwIEFTR3Mgd2l0aCBkZXNpcmVkX2NhcGFjaXR5ID0gMCAoYWxyZWFkeSB0ZXJtaW5hdGVkKVxuICAgIGNvbnN0IGZpbHRlcmVkID0gYXNncy5maWx0ZXIoKGFzZykgPT4ge1xuICAgICAgY29uc3QgZGVzaXJlZENhcGFjaXR5ID0gYXNnLmRlc2lyZWRfY2FwYWNpdHkgYXMgbnVtYmVyXG4gICAgICBjb25zdCBlbnYgPSAoYXNnLmVudiBhcyBzdHJpbmcpPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCJcbiAgICAgIGNvbnN0IG5hbWUgPSAoYXNnLm5hbWUgYXMgc3RyaW5nKT8udG9Mb3dlckNhc2UoKSB8fCBcIlwiXG4gICAgICBjb25zdCBkYXlzT2xkID0gdGhpcy5kYXlzU2luY2UoYXNnLmNyZWF0ZWRfYXQgYXMgc3RyaW5nKVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBBU0cgKEZlYXR1cmUpOiAke2FzZy5uYW1lfSB8IGVudjogJHtlbnZ9IHwgY2FwYWNpdHk6ICR7ZGVzaXJlZENhcGFjaXR5fSB8IGRheXMgb2xkOiAke2RheXNPbGR9IHwgdXRpbGl6YXRpb246ICR7YXNnLmN1cnJlbnRfdXRpbGl6YXRpb259YClcblxuICAgICAgLy8gU2tpcCBhbHJlYWR5IHRlcm1pbmF0ZWQgQVNHcyAoY2FwYWNpdHkgPSAwKVxuICAgICAgaWYgKCFkZXNpcmVkQ2FwYWNpdHkgfHwgZGVzaXJlZENhcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IENhcGFjaXR5IGlzIDAgKGFscmVhZHkgdGVybWluYXRlZClgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNGZWF0dXJlID0gZW52LmluY2x1ZGVzKFwiZmVhdHVyZVwiKSB8fCBuYW1lLmluY2x1ZGVzKFwiZmVhdHVyZVwiKSB8fCBuYW1lLmluY2x1ZGVzKFwiZmVhdC1cIilcbiAgICAgIGlmICghaXNGZWF0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IE5vdCBhIGZlYXR1cmUgYnJhbmNoIGVudmlyb25tZW50YClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChkYXlzT2xkIDw9IDcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogT25seSAke2RheXNPbGR9IGRheXMgb2xkICh0aHJlc2hvbGQ6ID43IGRheXMpYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTG93VXRpbCA9ICFhc2cuY3VycmVudF91dGlsaXphdGlvbiB8fCAoYXNnLmN1cnJlbnRfdXRpbGl6YXRpb24gYXMgbnVtYmVyKSA8IDIwXG4gICAgICBpZiAoIWlzTG93VXRpbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBVdGlsaXphdGlvbiAke2FzZy5jdXJyZW50X3V0aWxpemF0aW9ufSUgPj0gMjAlYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIE1BVENIOiBTdGFsZSBmZWF0dXJlIGJyYW5jaCBlbnZpcm9ubWVudGApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBTdGFsZSBGZWF0dXJlIEVudnM6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBzdGFsZSBmZWF0dXJlIGVudmlyb25tZW50c2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChhc2cpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLnN0YWxlX2ZlYXR1cmVfZW52XG4gICAgICBjb25zdCBpbnN0YW5jZUNvc3QgPSBnZXRFQzJNb250aGx5Q29zdChhc2cuaW5zdGFuY2VfdHlwZSBhcyBzdHJpbmcpXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGluc3RhbmNlQ29zdCAqIChhc2cuZGVzaXJlZF9jYXBhY2l0eSBhcyBudW1iZXIpXG4gICAgICBjb25zdCBkYXlzT2xkID0gdGhpcy5kYXlzU2luY2UoYXNnLmNyZWF0ZWRfYXQgYXMgc3RyaW5nKVxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoZGF5c09sZCA+IDE0KSBjb25maWRlbmNlICs9IDEwXG4gICAgICBpZiAoZGF5c09sZCA+IDMwKSBjb25maWRlbmNlICs9IDVcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJzdGFsZV9mZWF0dXJlX2VudlwiLFxuICAgICAgICByZXNvdXJjZTogYXNnLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGFzZ05hbWU6IGFzZy5uYW1lLFxuICAgICAgICAgIGluc3RhbmNlVHlwZTogYXNnLmluc3RhbmNlX3R5cGUsXG4gICAgICAgICAgZGVzaXJlZENhcGFjaXR5OiBhc2cuZGVzaXJlZF9jYXBhY2l0eSxcbiAgICAgICAgICBjdXJyZW50VXRpbGl6YXRpb246IGFzZy5jdXJyZW50X3V0aWxpemF0aW9uIHx8IDAsXG4gICAgICAgICAgZGF5c09sZCxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbjogXCJGZWF0dXJlIGJyYW5jaCBtYXkgYmUgYWJhbmRvbmVkIC0gY29uc2lkZXIgY2xlYW51cFwiLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gTGVnYWN5IGFzeW5jIHZlcnNpb25cbiAgcHJpdmF0ZSBhc3luYyBkZXRlY3RTdGFsZUZlYXR1cmVFbnZzKCk6IFByb21pc2U8V2FzdGVEZXRlY3Rpb25bXT4ge1xuICAgIGNvbnN0IHsgZGF0YTogYXNncywgZXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuXG4gICAgaWYgKGVycm9yIHx8ICFhc2dzKSByZXR1cm4gW11cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdGFsZUZlYXR1cmVFbnZzRnJvbURhdGEoYXNncylcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWRsZSBDSSBydW5uZXJzIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogSW5zdGFuY2VzIHRhZ2dlZCBhcyBDSSBydW5uZXJzIHRoYXQgYXJlIGlkbGVcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0SWRsZUNJUnVubmVyc0Zyb21EYXRhKGluc3RhbmNlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIC8vIEZpcnN0IGZpbHRlcjogcnVubmluZyBpbnN0YW5jZXMgd2l0aCBhdmdfY3B1XzdkIDwgNVxuICAgIGNvbnN0IGxvd0NwdVJ1bm5pbmcgPSBpbnN0YW5jZXMuZmlsdGVyKFxuICAgICAgKGkpID0+IGkuc3RhdGUgPT09IFwicnVubmluZ1wiICYmIChpLmF2Z19jcHVfN2QgYXMgbnVtYmVyKSA8IDVcbiAgICApXG5cbiAgICAvLyBUaGVuIGZpbHRlciBmb3IgQ0kgcnVubmVycyBiYXNlZCBvbiB0YWdzIG9yIG5hbWVcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGxvd0NwdVJ1bm5pbmcuZmlsdGVyKChpbnN0YW5jZSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9ICgoaW5zdGFuY2UubmFtZSBhcyBzdHJpbmcpIHx8IFwiXCIpLnRvTG93ZXJDYXNlKClcbiAgICAgIGNvbnN0IHRhZ3MgPSAoaW5zdGFuY2UudGFncyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgfHwge31cbiAgICAgIGNvbnN0IHRhZ1ZhbHVlcyA9IE9iamVjdC52YWx1ZXModGFncykubWFwKCh2KSA9PiBTdHJpbmcodikudG9Mb3dlckNhc2UoKSlcbiAgICAgIGNvbnN0IHRhZ0tleXMgPSBPYmplY3Qua2V5cyh0YWdzKS5tYXAoKGspID0+IGsudG9Mb3dlckNhc2UoKSlcblxuICAgICAgY29uc3QgaXNDSSA9XG4gICAgICAgIG5hbWUuaW5jbHVkZXMoXCJjaVwiKSB8fFxuICAgICAgICBuYW1lLmluY2x1ZGVzKFwicnVubmVyXCIpIHx8XG4gICAgICAgIG5hbWUuaW5jbHVkZXMoXCJqZW5raW5zXCIpIHx8XG4gICAgICAgIG5hbWUuaW5jbHVkZXMoXCJnaXRsYWItcnVubmVyXCIpIHx8XG4gICAgICAgIG5hbWUuaW5jbHVkZXMoXCJnaXRodWItYWN0aW9uc1wiKSB8fFxuICAgICAgICB0YWdLZXlzLmluY2x1ZGVzKFwiY2lcIikgfHxcbiAgICAgICAgdGFnS2V5cy5pbmNsdWRlcyhcInJ1bm5lclwiKSB8fFxuICAgICAgICB0YWdWYWx1ZXMuc29tZShcbiAgICAgICAgICAodikgPT4gdi5pbmNsdWRlcyhcImNpXCIpIHx8IHYuaW5jbHVkZXMoXCJydW5uZXJcIikgfHwgdi5pbmNsdWRlcyhcImJ1aWxkXCIpXG4gICAgICAgIClcblxuICAgICAgcmV0dXJuIGlzQ0lcbiAgICB9KVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLmlkbGVfY2lfcnVubmVyXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldEVDMk1vbnRobHlDb3N0KGluc3RhbmNlLmluc3RhbmNlX3R5cGUgYXMgc3RyaW5nKVxuXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoKGluc3RhbmNlLmF2Z19jcHVfN2QgYXMgbnVtYmVyKSA8IDIpIGNvbmZpZGVuY2UgKz0gNVxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcImlkbGVfY2lfcnVubmVyXCIsXG4gICAgICAgIHJlc291cmNlOiBpbnN0YW5jZSxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcImluc3RhbmNlc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwibmFtZVwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBpbnN0YW5jZU5hbWU6IGluc3RhbmNlLm5hbWUsXG4gICAgICAgICAgaW5zdGFuY2VUeXBlOiBpbnN0YW5jZS5pbnN0YW5jZV90eXBlLFxuICAgICAgICAgIGF2Z0NwdTdkOiBpbnN0YW5jZS5hdmdfY3B1XzdkLFxuICAgICAgICAgIHRhZ3M6IGluc3RhbmNlLnRhZ3MsXG4gICAgICAgICAgcmVjb21tZW5kYXRpb246IFwiQ0kgcnVubmVyIGFwcGVhcnMgaWRsZSAtIHRlcm1pbmF0ZSBpZiBqb2IgY29tcGxldGVkXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyBMZWdhY3kgYXN5bmMgdmVyc2lvblxuICBwcml2YXRlIGFzeW5jIGRldGVjdElkbGVDSVJ1bm5lcnMoKTogUHJvbWlzZTxXYXN0ZURldGVjdGlvbltdPiB7XG4gICAgY29uc3QgeyBkYXRhOiBpbnN0YW5jZXMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXG4gICAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInN0YXRlXCIsIFwicnVubmluZ1wiKVxuICAgICAgLmx0KFwiYXZnX2NwdV83ZFwiLCA1KVxuXG4gICAgaWYgKGVycm9yIHx8ICFpbnN0YW5jZXMpIHJldHVybiBbXVxuICAgIHJldHVybiB0aGlzLmRldGVjdElkbGVDSVJ1bm5lcnNGcm9tRGF0YShpbnN0YW5jZXMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGRldiBpbnN0YW5jZXMgcnVubmluZyBkdXJpbmcgb2ZmLWhvdXJzIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogRGV2IGluc3RhbmNlcyBydW5uaW5nIG9uIHdlZWtlbmRzIG9yIGxhdGUgbmlnaHRcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0T2ZmSG91cnNEZXZJbnN0YW5jZXNGcm9tRGF0YShpbnN0YW5jZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10pOiBXYXN0ZURldGVjdGlvbltdIHtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHRpbWUgaXMgb2ZmLWhvdXJzICh3ZWVrZW5kIG9yIG91dHNpZGUgN2FtLTdwbSlcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgZGF5T2ZXZWVrID0gbm93LmdldERheSgpXG4gICAgY29uc3QgaG91ciA9IG5vdy5nZXRIb3VycygpXG4gICAgY29uc3QgaXNXZWVrZW5kID0gZGF5T2ZXZWVrID09PSAwIHx8IGRheU9mV2VlayA9PT0gNlxuICAgIGNvbnN0IGlzT2ZmSG91cnMgPSBob3VyIDwgNyB8fCBob3VyID4gMTlcblxuICAgIC8vIE9ubHkgcnVuIHRoaXMgZGV0ZWN0aW9uIGR1cmluZyBvZmYtaG91cnNcbiAgICBpZiAoIWlzV2Vla2VuZCAmJiAhaXNPZmZIb3Vycykge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgLy8gRmlsdGVyOiBydW5uaW5nIGRldiBpbnN0YW5jZXNcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGluc3RhbmNlcy5maWx0ZXIoXG4gICAgICAoaSkgPT4gaS5zdGF0ZSA9PT0gXCJydW5uaW5nXCIgJiYgaS5lbnYgPT09IFwiZGV2XCJcbiAgICApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub2ZmX2hvdXJzX2RldlxuICAgICAgY29uc3QgbW9udGhseUNvc3QgPSBnZXRFQzJNb250aGx5Q29zdChpbnN0YW5jZS5pbnN0YW5jZV90eXBlIGFzIHN0cmluZylcbiAgICAgIGNvbnN0IG9mZkhvdXJzU2F2aW5ncyA9IG1vbnRobHlDb3N0ICogMC42XG5cbiAgICAgIGxldCBjb25maWRlbmNlID0gc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2VcbiAgICAgIGlmIChpc1dlZWtlbmQpIGNvbmZpZGVuY2UgKz0gMTBcbiAgICAgIGlmICgoaW5zdGFuY2UuYXZnX2NwdV83ZCBhcyBudW1iZXIpIDwgNSkgY29uZmlkZW5jZSArPSA1XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwib2ZmX2hvdXJzX2RldlwiLFxuICAgICAgICByZXNvdXJjZTogaW5zdGFuY2UsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJpbnN0YW5jZXNcIixcbiAgICAgICAgbmFtZUZpZWxkOiBcIm5hbWVcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3M6IG9mZkhvdXJzU2F2aW5ncyxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oY29uZmlkZW5jZSwgMTAwKSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGluc3RhbmNlTmFtZTogaW5zdGFuY2UubmFtZSxcbiAgICAgICAgICBpbnN0YW5jZVR5cGU6IGluc3RhbmNlLmluc3RhbmNlX3R5cGUsXG4gICAgICAgICAgYXZnQ3B1N2Q6IGluc3RhbmNlLmF2Z19jcHVfN2QsXG4gICAgICAgICAgaXNXZWVrZW5kLFxuICAgICAgICAgIGN1cnJlbnRIb3VyOiBob3VyLFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBcIlN0b3AgZGV2IGluc3RhbmNlcyBkdXJpbmcgb2ZmLWhvdXJzIHRvIHNhdmUgY29zdHNcIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIExlZ2FjeSBhc3luYyB2ZXJzaW9uXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0T2ZmSG91cnNEZXZJbnN0YW5jZXMoKTogUHJvbWlzZTxXYXN0ZURldGVjdGlvbltdPiB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIGNvbnN0IGRheU9mV2VlayA9IG5vdy5nZXREYXkoKVxuICAgIGNvbnN0IGhvdXIgPSBub3cuZ2V0SG91cnMoKVxuICAgIGNvbnN0IGlzV2Vla2VuZCA9IGRheU9mV2VlayA9PT0gMCB8fCBkYXlPZldlZWsgPT09IDZcbiAgICBjb25zdCBpc09mZkhvdXJzID0gaG91ciA8IDcgfHwgaG91ciA+IDE5XG5cbiAgICBpZiAoIWlzV2Vla2VuZCAmJiAhaXNPZmZIb3Vycykge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhOiBpbnN0YW5jZXMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlXG4gICAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInN0YXRlXCIsIFwicnVubmluZ1wiKVxuICAgICAgLmVxKFwiZW52XCIsIFwiZGV2XCIpXG5cbiAgICBpZiAoZXJyb3IgfHwgIWluc3RhbmNlcykgcmV0dXJuIFtdXG4gICAgcmV0dXJuIHRoaXMuZGV0ZWN0T2ZmSG91cnNEZXZJbnN0YW5jZXNGcm9tRGF0YShpbnN0YW5jZXMpXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IG92ZXItcHJvdmlzaW9uZWQgRUMyIGluc3RhbmNlcyAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqIEluc3RhbmNlcyB3aXRoIGxvdyBDUFUgYW5kIG1lbW9yeSB1dGlsaXphdGlvbiB0aGF0IGNhbiBiZSBkb3duc2l6ZWRcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0T3ZlclByb3Zpc2lvbmVkSW5zdGFuY2VzRnJvbURhdGEoaW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgLy8gRGVidWc6IExvZyBhbGwgcnVubmluZyBpbnN0YW5jZXMgYW5kIHRoZWlyIG1ldHJpY3NcbiAgICBjb25zdCBydW5uaW5nSW5zdGFuY2VzID0gaW5zdGFuY2VzLmZpbHRlcigoaSkgPT4gaS5zdGF0ZSA9PT0gXCJydW5uaW5nXCIpXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRUMyIFJpZ2h0c2l6aW5nOiBDaGVja2luZyAke3J1bm5pbmdJbnN0YW5jZXMubGVuZ3RofSBydW5uaW5nIGluc3RhbmNlcyBvdXQgb2YgJHtpbnN0YW5jZXMubGVuZ3RofSB0b3RhbGApXG5cbiAgICAvLyBGaWx0ZXI6IHJ1bm5pbmcgaW5zdGFuY2VzIHdpdGggbG93IHV0aWxpemF0aW9uIHRoYXQgY2FuIGJlIGRvd25zaXplZFxuICAgIC8vIC0gQ1BVIDwgMzAlIChwcmVmZXIgYXZnX2NwdV83ZCwgZmFsbGJhY2sgdG8gY3VycmVudF9jcHUpXG4gICAgLy8gLSBNZW1vcnkgPCA0MCUgKHByZWZlciBjdXJyZW50X21lbW9yeSwgZmFsbGJhY2sgdG8gY2hlY2sgaWYgd2UgaGF2ZSBhbnkgbWV0cmljKVxuICAgIC8vIC0gSW5zdGFuY2UgdHlwZSBoYXMgYSBzbWFsbGVyIG9wdGlvbiBhdmFpbGFibGVcbiAgICAvLyAtIEV4Y2x1ZGUgaW5zdGFuY2VzIGFscmVhZHkgZmxhZ2dlZCBhcyBpZGxlIChDUFUgPCA1JSlcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGluc3RhbmNlcy5maWx0ZXIoKGkpID0+IHtcbiAgICAgIGlmIChpLnN0YXRlICE9PSBcInJ1bm5pbmdcIikgcmV0dXJuIGZhbHNlXG5cbiAgICAgIC8vIFVzZSBhdmdfY3B1XzdkIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBjdXJyZW50X2NwdVxuICAgICAgY29uc3QgYXZnN2RDcHUgPSBpLmF2Z19jcHVfN2QgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY3VycmVudENwdSA9IGkuY3VycmVudF9jcHUgYXMgbnVtYmVyIHwgbnVsbFxuICAgICAgY29uc3QgY3B1VmFsdWUgPSBhdmc3ZENwdSA/PyBjdXJyZW50Q3B1ID8/IG51bGxcblxuICAgICAgLy8gVXNlIGN1cnJlbnRfbWVtb3J5IGlmIGF2YWlsYWJsZVxuICAgICAgY29uc3QgY3VycmVudE1lbW9yeSA9IGkuY3VycmVudF9tZW1vcnkgYXMgbnVtYmVyIHwgbnVsbFxuXG4gICAgICBjb25zdCBpbnN0YW5jZVR5cGUgPSBpLmluc3RhbmNlX3R5cGUgYXMgc3RyaW5nXG4gICAgICBjb25zdCBzbWFsbGVyVHlwZSA9IGdldFJlY29tbWVuZGVkU21hbGxlckluc3RhbmNlKGluc3RhbmNlVHlwZSlcblxuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgZWFjaCBpbnN0YW5jZSB3aXRoIHJhdyB2YWx1ZXNcbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIEVDMiBSaWdodHNpemluZzogJHtpLm5hbWV9IHwgVHlwZTogJHtpbnN0YW5jZVR5cGV9IHwgYXZnX2NwdV83ZDogJHthdmc3ZENwdX0gfCBjdXJyZW50X2NwdTogJHtjdXJyZW50Q3B1fSB8IGN1cnJlbnRfbWVtb3J5OiAke2N1cnJlbnRNZW1vcnl9IHwgU21hbGxlcjogJHtzbWFsbGVyVHlwZSB8fCAnTk9ORSd9YClcblxuICAgICAgLy8gU2tpcCBpZiBubyBDUFUgbWV0cmljIGF2YWlsYWJsZSBhdCBhbGxcbiAgICAgIGlmIChjcHVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBObyBDUFUgbWV0cmljIGF2YWlsYWJsZSAoYXZnX2NwdV83ZCBhbmQgY3VycmVudF9jcHUgYm90aCBudWxsKWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGlmIGFscmVhZHkgaWRsZSAod2lsbCBiZSBjYXVnaHQgYnkgaWRsZSBkZXRlY3Rpb24pXG4gICAgICBpZiAoY3B1VmFsdWUgPCA1KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IENQVSB0b28gbG93ICgke2NwdVZhbHVlfSUgPCA1JSksIHdpbGwgdXNlIGlkbGUgZGV0ZWN0aW9uYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHV0aWxpemF0aW9uIGlzIGxvdyBlbm91Z2ggdG8gd2FycmFudCByaWdodHNpemluZ1xuICAgICAgY29uc3QgbG93Q3B1ID0gY3B1VmFsdWUgPCAzMFxuICAgICAgLy8gSWYgbWVtb3J5IGlzIG51bGwsIG9ubHkgY2hlY2sgQ1BVIChtb3JlIGxlbmllbnQgY2hlY2spXG4gICAgICBjb25zdCBsb3dNZW1vcnkgPSBjdXJyZW50TWVtb3J5ID09PSBudWxsIHx8IGN1cnJlbnRNZW1vcnkgPCA0MFxuXG4gICAgICAvLyBCb3RoIENQVSBtdXN0IGJlIGxvdywgYW5kIG1lbW9yeSBlaXRoZXIgdW5hdmFpbGFibGUgb3IgbG93XG4gICAgICBpZiAoIWxvd0NwdSB8fCAhbG93TWVtb3J5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IFV0aWxpemF0aW9uIG5vdCBsb3cgZW5vdWdoIChDUFUgJHtjcHVWYWx1ZX0lIDwgMzA6ICR7bG93Q3B1fSwgTWVtICR7Y3VycmVudE1lbW9yeSA/PyAnTi9BJ30lIDwgNDA6ICR7bG93TWVtb3J5fSlgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gTXVzdCBoYXZlIGEgc21hbGxlciBpbnN0YW5jZSB0eXBlIGF2YWlsYWJsZVxuICAgICAgaWYgKCFzbWFsbGVyVHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBObyBzbWFsbGVyIGluc3RhbmNlIHR5cGUgYXZhaWxhYmxlIGZvciAke2luc3RhbmNlVHlwZX1gKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IFdpbGwgcmVjb21tZW5kIGRvd25zaXppbmcgdG8gJHtzbWFsbGVyVHlwZX1gKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRUMyIFJpZ2h0c2l6aW5nOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gaW5zdGFuY2VzIHRvIHJpZ2h0c2l6ZWApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1Mub3Zlcl9wcm92aXNpb25lZF9pbnN0YW5jZVxuICAgICAgY29uc3QgaW5zdGFuY2VUeXBlID0gaW5zdGFuY2UuaW5zdGFuY2VfdHlwZSBhcyBzdHJpbmdcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZhbGxiYWNrIGxvZ2ljIGFzIGZpbHRlcmluZ1xuICAgICAgY29uc3QgYXZnN2RDcHUgPSBpbnN0YW5jZS5hdmdfY3B1XzdkIGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRDcHUgPSBpbnN0YW5jZS5jdXJyZW50X2NwdSBhcyBudW1iZXIgfCBudWxsXG4gICAgICBjb25zdCBjcHVWYWx1ZSA9IGF2ZzdkQ3B1ID8/IGN1cnJlbnRDcHUgPz8gMFxuICAgICAgY29uc3QgY3VycmVudE1lbW9yeSA9IChpbnN0YW5jZS5jdXJyZW50X21lbW9yeSBhcyBudW1iZXIpID8/IDBcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgYW5kIHJlY29tbWVuZGVkIGluc3RhbmNlIGRldGFpbHNcbiAgICAgIGNvbnN0IGN1cnJlbnRTcGVjcyA9IGdldEVDMkluc3RhbmNlU3BlY3MoaW5zdGFuY2VUeXBlKVxuICAgICAgY29uc3QgcmVjb21tZW5kZWRUeXBlID0gZ2V0UmVjb21tZW5kZWRTbWFsbGVySW5zdGFuY2UoaW5zdGFuY2VUeXBlKSFcbiAgICAgIGNvbnN0IHJlY29tbWVuZGVkU3BlY3MgPSBnZXRFQzJJbnN0YW5jZVNwZWNzKHJlY29tbWVuZGVkVHlwZSlcblxuICAgICAgLy8gQ2FsY3VsYXRlIGNvc3RzXG4gICAgICBjb25zdCBjdXJyZW50TW9udGhseUNvc3QgPSBnZXRFQzJNb250aGx5Q29zdChpbnN0YW5jZVR5cGUpXG4gICAgICBjb25zdCByZWNvbW1lbmRlZE1vbnRobHlDb3N0ID0gZ2V0RUMyTW9udGhseUNvc3QocmVjb21tZW5kZWRUeXBlKVxuICAgICAgY29uc3QgcG90ZW50aWFsU2F2aW5ncyA9IGN1cnJlbnRNb250aGx5Q29zdCAtIHJlY29tbWVuZGVkTW9udGhseUNvc3RcblxuICAgICAgLy8gQWRqdXN0IGNvbmZpZGVuY2UgYmFzZWQgb24gaG93IHVuZGVydXRpbGl6ZWQgdGhlIGluc3RhbmNlIGlzXG4gICAgICBsZXQgY29uZmlkZW5jZSA9IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlXG4gICAgICBpZiAoY3B1VmFsdWUgPCAxNSkgY29uZmlkZW5jZSArPSAxMFxuICAgICAgaWYgKGN1cnJlbnRNZW1vcnkgPCAyNSkgY29uZmlkZW5jZSArPSA1XG4gICAgICBpZiAoaW5zdGFuY2UuZW52ID09PSBcImRldlwiIHx8IGluc3RhbmNlLmVudiA9PT0gXCJzdGFnaW5nXCIpIGNvbmZpZGVuY2UgKz0gNVxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcIm92ZXJfcHJvdmlzaW9uZWRfaW5zdGFuY2VcIixcbiAgICAgICAgcmVzb3VyY2U6IGluc3RhbmNlLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwiaW5zdGFuY2VzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0OiBjdXJyZW50TW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgICAgIGNvbmZpZGVuY2U6IE1hdGgubWluKGNvbmZpZGVuY2UsIDEwMCksXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBpbnN0YW5jZU5hbWU6IGluc3RhbmNlLm5hbWUsXG4gICAgICAgICAgaW5zdGFuY2VJZDogaW5zdGFuY2UuaW5zdGFuY2VfaWQsXG4gICAgICAgICAgY3VycmVudEluc3RhbmNlVHlwZTogaW5zdGFuY2VUeXBlLFxuICAgICAgICAgIHJlY29tbWVuZGVkSW5zdGFuY2VUeXBlOiByZWNvbW1lbmRlZFR5cGUsXG4gICAgICAgICAgY3VycmVudFZjcHU6IGN1cnJlbnRTcGVjcz8udmNwdSxcbiAgICAgICAgICBjdXJyZW50TWVtb3J5R2I6IGN1cnJlbnRTcGVjcz8ubWVtb3J5R2IsXG4gICAgICAgICAgcmVjb21tZW5kZWRWY3B1OiByZWNvbW1lbmRlZFNwZWNzPy52Y3B1LFxuICAgICAgICAgIHJlY29tbWVuZGVkTWVtb3J5R2I6IHJlY29tbWVuZGVkU3BlY3M/Lm1lbW9yeUdiLFxuICAgICAgICAgIGF2Z0NwdTdkOiBjcHVWYWx1ZSxcbiAgICAgICAgICBjdXJyZW50TWVtb3J5UGN0OiBjdXJyZW50TWVtb3J5LFxuICAgICAgICAgIGN1cnJlbnRNb250aGx5Q29zdCxcbiAgICAgICAgICByZWNvbW1lbmRlZE1vbnRobHlDb3N0LFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBgRG93bnNpemUgZnJvbSAke2luc3RhbmNlVHlwZX0gdG8gJHtyZWNvbW1lbmRlZFR5cGV9YCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUVVJQ0stV0lOIE9QVElNSVpBVElPTlMgLSBQaGFzZSAxIChObyBtaWdyYXRpb25zIG5lZWRlZClcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgR1AyIHZvbHVtZXMgdGhhdCBzaG91bGQgYmUgdXBncmFkZWQgdG8gR1AzIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogR1AzIG9mZmVycyB+MjAlIGNvc3Qgc2F2aW5ncyB3aXRoIGJldHRlciBiYXNlbGluZSBwZXJmb3JtYW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RHcDJWb2x1bWVzRnJvbURhdGEodm9sdW1lczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIEdQMiBWb2x1bWVzOiBDaGVja2luZyAke3ZvbHVtZXMubGVuZ3RofSBFQlMgdm9sdW1lc2ApXG5cbiAgICAvLyBGaWx0ZXI6IHZvbHVtZXMgd2l0aCB2b2x1bWVfdHlwZSA9ICdncDInIGFuZCBub3QgZGVsZXRlZFxuICAgIGNvbnN0IGZpbHRlcmVkID0gdm9sdW1lcy5maWx0ZXIoKHYpID0+IHtcbiAgICAgIGNvbnN0IHZvbHVtZVR5cGUgPSB2LnZvbHVtZV90eXBlIGFzIHN0cmluZ1xuICAgICAgY29uc3Qgc3RhdGUgPSB2LnN0YXRlIGFzIHN0cmluZ1xuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBWb2x1bWU6ICR7di52b2x1bWVfaWR9IHwgdHlwZTogJHt2b2x1bWVUeXBlfSB8IHN0YXRlOiAke3N0YXRlfWApXG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gXCJkZWxldGVkXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogVm9sdW1lIGlzIGRlbGV0ZWRgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHZvbHVtZVR5cGUgIT09IFwiZ3AyXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogVm9sdW1lIHR5cGUgaXMgJHt2b2x1bWVUeXBlfSwgbm90IGdwMmApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogR1AyIHZvbHVtZSBkZXRlY3RlZGApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBHUDIgVm9sdW1lczogRm91bmQgJHtmaWx0ZXJlZC5sZW5ndGh9IGdwMiB2b2x1bWVzIHRvIHVwZ3JhZGVgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgodm9sdW1lKSA9PiB7XG4gICAgICBjb25zdCBzY2VuYXJpbyA9IFdBU1RFX1NDRU5BUklPUy5ncDJfdm9sdW1lXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFZvbHVtZU1vbnRobHlDb3N0KFwiZ3AyXCIsIHZvbHVtZS5zaXplX2dpYiBhcyBudW1iZXIpXG4gICAgICAvLyBHUDMgaXMgfjIwJSBjaGVhcGVyIHRoYW4gR1AyXG4gICAgICBjb25zdCBncDNDb3N0ID0gZ2V0Vm9sdW1lTW9udGhseUNvc3QoXCJncDNcIiwgdm9sdW1lLnNpemVfZ2liIGFzIG51bWJlcilcbiAgICAgIGNvbnN0IHBvdGVudGlhbFNhdmluZ3MgPSBtb250aGx5Q29zdCAtIGdwM0Nvc3RcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJncDJfdm9sdW1lXCIsXG4gICAgICAgIHJlc291cmNlOiB2b2x1bWUsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJ2b2x1bWVzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJ2b2x1bWVfaWRcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgICAgIGNvbmZpZGVuY2U6IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgdm9sdW1lSWQ6IHZvbHVtZS52b2x1bWVfaWQsXG4gICAgICAgICAgY3VycmVudFR5cGU6IFwiZ3AyXCIsXG4gICAgICAgICAgcmVjb21tZW5kZWRUeXBlOiBcImdwM1wiLFxuICAgICAgICAgIHNpemVHaWI6IHZvbHVtZS5zaXplX2dpYixcbiAgICAgICAgICBjdXJyZW50TW9udGhseUNvc3Q6IG1vbnRobHlDb3N0LFxuICAgICAgICAgIHByb2plY3RlZE1vbnRobHlDb3N0OiBncDNDb3N0LFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCB1bnVzZWQgTGFtYmRhIGZ1bmN0aW9ucyAoSU4tTUVNT1JZIHZlcnNpb24pXG4gICAqIEZ1bmN0aW9ucyB3aXRoIHplcm8gaW52b2NhdGlvbnMgaW4gdGhlIGxhc3QgNyBkYXlzXG4gICAqL1xuICBwcml2YXRlIGRldGVjdFVudXNlZExhbWJkYXNGcm9tRGF0YShsYW1iZGFzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gVW51c2VkIExhbWJkYXM6IENoZWNraW5nICR7bGFtYmRhcy5sZW5ndGh9IExhbWJkYSBmdW5jdGlvbnNgKVxuXG4gICAgLy8gRmlsdGVyOiBmdW5jdGlvbnMgd2l0aCBpbnZvY2F0aW9uc183ZCA9IDAgb3IgbnVsbFxuICAgIGNvbnN0IGZpbHRlcmVkID0gbGFtYmRhcy5maWx0ZXIoKGZuKSA9PiB7XG4gICAgICBjb25zdCBpbnZvY2F0aW9ucyA9IGZuLmludm9jYXRpb25zXzdkIGFzIG51bWJlciB8IG51bGxcblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTGFtYmRhOiAke2ZuLm5hbWV9IHwgaW52b2NhdGlvbnNfN2Q6ICR7aW52b2NhdGlvbnN9YClcblxuICAgICAgaWYgKGludm9jYXRpb25zICE9PSBudWxsICYmIGludm9jYXRpb25zICE9PSB1bmRlZmluZWQgJiYgaW52b2NhdGlvbnMgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IEhhcyAke2ludm9jYXRpb25zfSBpbnZvY2F0aW9ucyBpbiA3IGRheXNgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IFVudXNlZCBMYW1iZGEgZGV0ZWN0ZWRgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gVW51c2VkIExhbWJkYXM6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSB1bnVzZWQgTGFtYmRhIGZ1bmN0aW9uc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChmbikgPT4ge1xuICAgICAgY29uc3Qgc2NlbmFyaW8gPSBXQVNURV9TQ0VOQVJJT1MudW51c2VkX2xhbWJkYVxuICAgICAgLy8gRXN0aW1hdGUgY29zdCBiYXNlZCBvbiBtZW1vcnkgYWxsb2NhdGlvbiAoZXZlbiB1bnVzZWQgZnVuY3Rpb25zIGhhdmUgc3RvcmFnZSBjb3N0cylcbiAgICAgIGNvbnN0IG1lbW9yeU1iID0gKGZuLm1lbW9yeV9tYiBhcyBudW1iZXIpIHx8IDEyOFxuICAgICAgY29uc3QgZXN0aW1hdGVkTW9uaXRvcmluZ0Nvc3QgPSAwLjUwIC8vIENsb3VkV2F0Y2ggTG9ncy9tZXRyaWNzIG92ZXJoZWFkXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGVzdGltYXRlZE1vbml0b3JpbmdDb3N0XG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwidW51c2VkX2xhbWJkYVwiLFxuICAgICAgICByZXNvdXJjZTogZm4sXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJsYW1iZGFfZnVuY3Rpb25zXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzOiBtb250aGx5Q29zdCxcbiAgICAgICAgY29uZmlkZW5jZTogc2NlbmFyaW8uYmFzZUNvbmZpZGVuY2UsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZuLm5hbWUsXG4gICAgICAgICAgbWVtb3J5TWIsXG4gICAgICAgICAgaW52b2NhdGlvbnM3ZDogMCxcbiAgICAgICAgICBydW50aW1lOiBmbi5ydW50aW1lLFxuICAgICAgICAgIGxhc3RNb2RpZmllZDogZm4udXBkYXRlZF9hdCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3Qgb3JwaGFuZWQgc25hcHNob3RzIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogU25hcHNob3RzIHdob3NlIHNvdXJjZSB2b2x1bWUgbm8gbG9uZ2VyIGV4aXN0c1xuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RPcnBoYW5lZFNuYXBzaG90c0Zyb21EYXRhKFxuICAgIHNuYXBzaG90czogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSxcbiAgICB2b2x1bWVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdXG4gICk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIE9ycGhhbmVkIFNuYXBzaG90czogQ2hlY2tpbmcgJHtzbmFwc2hvdHMubGVuZ3RofSBzbmFwc2hvdHMgYWdhaW5zdCAke3ZvbHVtZXMubGVuZ3RofSB2b2x1bWVzYClcblxuICAgIC8vIEJ1aWxkIGEgc2V0IG9mIGFsbCBleGlzdGluZyB2b2x1bWUgSURzIChub3QgZGVsZXRlZClcbiAgICBjb25zdCBleGlzdGluZ1ZvbHVtZUlkcyA9IG5ldyBTZXQoXG4gICAgICB2b2x1bWVzXG4gICAgICAgIC5maWx0ZXIoKHYpID0+IHYuc3RhdGUgIT09IFwiZGVsZXRlZFwiKVxuICAgICAgICAubWFwKCh2KSA9PiB2LnZvbHVtZV9pZCBhcyBzdHJpbmcpXG4gICAgKVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gT3JwaGFuZWQgU25hcHNob3RzOiAke2V4aXN0aW5nVm9sdW1lSWRzLnNpemV9IGFjdGl2ZSB2b2x1bWVzIGZvdW5kYClcblxuICAgIC8vIEZpbHRlcjogc25hcHNob3RzIHdob3NlIHNvdXJjZV92b2x1bWVfaWQgZG9lc24ndCBleGlzdFxuICAgIGNvbnN0IGZpbHRlcmVkID0gc25hcHNob3RzLmZpbHRlcigocykgPT4ge1xuICAgICAgY29uc3Qgc291cmNlVm9sdW1lSWQgPSBzLnNvdXJjZV92b2x1bWVfaWQgYXMgc3RyaW5nIHwgbnVsbFxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBTbmFwc2hvdDogJHtzLnNuYXBzaG90X2lkfSB8IHNvdXJjZV92b2x1bWVfaWQ6ICR7c291cmNlVm9sdW1lSWR9YClcblxuICAgICAgLy8gSWYgbm8gc291cmNlIHZvbHVtZSBJRCwgY2FuJ3QgZGV0ZXJtaW5lIGlmIG9ycGhhbmVkXG4gICAgICBpZiAoIXNvdXJjZVZvbHVtZUlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IE5vIHNvdXJjZSB2b2x1bWUgSURgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSB2b2x1bWUgc3RpbGwgZXhpc3RzXG4gICAgICBpZiAoZXhpc3RpbmdWb2x1bWVJZHMuaGFzKHNvdXJjZVZvbHVtZUlkKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBTb3VyY2Ugdm9sdW1lICR7c291cmNlVm9sdW1lSWR9IHN0aWxsIGV4aXN0c2ApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogT3JwaGFuZWQgc25hcHNob3QgKHZvbHVtZSAke3NvdXJjZVZvbHVtZUlkfSBubyBsb25nZXIgZXhpc3RzKWApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBPcnBoYW5lZCBTbmFwc2hvdHM6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBvcnBoYW5lZCBzbmFwc2hvdHNgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLm9ycGhhbmVkX3NuYXBzaG90XG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldFNuYXBzaG90TW9udGhseUNvc3Qoc25hcHNob3Quc2l6ZV9naWIgYXMgbnVtYmVyKVxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcIm9ycGhhbmVkX3NuYXBzaG90XCIsXG4gICAgICAgIHJlc291cmNlOiBzbmFwc2hvdCxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiBcInNuYXBzaG90c1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwic25hcHNob3RfaWRcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3M6IG1vbnRobHlDb3N0LFxuICAgICAgICBjb25maWRlbmNlOiBzY2VuYXJpby5iYXNlQ29uZmlkZW5jZSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHNuYXBzaG90SWQ6IHNuYXBzaG90LnNuYXBzaG90X2lkLFxuICAgICAgICAgIHNvdXJjZVZvbHVtZUlkOiBzbmFwc2hvdC5zb3VyY2Vfdm9sdW1lX2lkLFxuICAgICAgICAgIHNpemVHaWI6IHNuYXBzaG90LnNpemVfZ2liLFxuICAgICAgICAgIGNyZWF0ZWRBdDogc25hcHNob3QuY3JlYXRlZF9hdCxcbiAgICAgICAgICBkYXlzT2xkOiB0aGlzLmRheXNTaW5jZShzbmFwc2hvdC5jcmVhdGVkX2F0IGFzIHN0cmluZyksXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHN0YXRpYyBBU0dzIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogQVNHcyB3aXRoIG1pbl9zaXplID0gbWF4X3NpemUgPSBkZXNpcmVkX2NhcGFjaXR5ID4gMSAobm90IGFjdHVhbGx5IHNjYWxpbmcpXG4gICAqL1xuICBwcml2YXRlIGRldGVjdFN0YXRpY0FTR3NGcm9tRGF0YShhc2dzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gU3RhdGljIEFTR3M6IENoZWNraW5nICR7YXNncy5sZW5ndGh9IEF1dG8gU2NhbGluZyBHcm91cHNgKVxuXG4gICAgLy8gRmlsdGVyOiBBU0dzIHdoZXJlIG1pbiA9IG1heCA9IGRlc2lyZWQgYW5kIGRlc2lyZWQgPiAxXG4gICAgY29uc3QgZmlsdGVyZWQgPSBhc2dzLmZpbHRlcigoYXNnKSA9PiB7XG4gICAgICBjb25zdCBtaW5TaXplID0gYXNnLm1pbl9zaXplIGFzIG51bWJlclxuICAgICAgY29uc3QgbWF4U2l6ZSA9IGFzZy5tYXhfc2l6ZSBhcyBudW1iZXJcbiAgICAgIGNvbnN0IGRlc2lyZWRDYXBhY2l0eSA9IGFzZy5kZXNpcmVkX2NhcGFjaXR5IGFzIG51bWJlclxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBBU0c6ICR7YXNnLm5hbWV9IHwgbWluOiAke21pblNpemV9IHwgbWF4OiAke21heFNpemV9IHwgZGVzaXJlZDogJHtkZXNpcmVkQ2FwYWNpdHl9YClcblxuICAgICAgLy8gU2tpcCB0ZXJtaW5hdGVkIEFTR3NcbiAgICAgIGlmIChkZXNpcmVkQ2FwYWNpdHkgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogQVNHIGlzIHRlcm1pbmF0ZWQgKGNhcGFjaXR5ID0gMClgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgc3RhdGljIChhbGwgdmFsdWVzIGVxdWFsKVxuICAgICAgaWYgKG1pblNpemUgIT09IG1heFNpemUgfHwgbWF4U2l6ZSAhPT0gZGVzaXJlZENhcGFjaXR5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IEFTRyBoYXMgZHluYW1pYyBzY2FsaW5nIChtaW4g4omgIG1heCBvciBtYXgg4omgIGRlc2lyZWQpYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZmxhZyBpZiBkZXNpcmVkID4gMSAoc2luZ2xlIGluc3RhbmNlIEFTR3MgbWlnaHQgYmUgaW50ZW50aW9uYWwpXG4gICAgICBpZiAoZGVzaXJlZENhcGFjaXR5IDw9IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogU2luZ2xlIGluc3RhbmNlIEFTRyAobWF5IGJlIGludGVudGlvbmFsKWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogU3RhdGljIEFTRyBkZXRlY3RlZCAobWluID0gbWF4ID0gZGVzaXJlZCA9ICR7ZGVzaXJlZENhcGFjaXR5fSlgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gU3RhdGljIEFTR3M6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBzdGF0aWMgQVNHc2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChhc2cpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLnN0YXRpY19hc2dcbiAgICAgIGNvbnN0IGluc3RhbmNlQ29zdCA9IGdldEVDMk1vbnRobHlDb3N0KGFzZy5pbnN0YW5jZV90eXBlIGFzIHN0cmluZylcbiAgICAgIGNvbnN0IGRlc2lyZWRDYXBhY2l0eSA9IGFzZy5kZXNpcmVkX2NhcGFjaXR5IGFzIG51bWJlclxuICAgICAgY29uc3QgbW9udGhseUNvc3QgPSBpbnN0YW5jZUNvc3QgKiBkZXNpcmVkQ2FwYWNpdHlcblxuICAgICAgLy8gUG90ZW50aWFsIHNhdmluZ3MgZnJvbSBlbmFibGluZyBzY2FsaW5nIChlc3RpbWF0ZSAzMCUgcmVkdWN0aW9uKVxuICAgICAgY29uc3QgcG90ZW50aWFsU2F2aW5ncyA9IG1vbnRobHlDb3N0ICogMC4zXG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwic3RhdGljX2FzZ1wiLFxuICAgICAgICByZXNvdXJjZTogYXNnLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzLFxuICAgICAgICBjb25maWRlbmNlOiBzY2VuYXJpby5iYXNlQ29uZmlkZW5jZSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGFzZ05hbWU6IGFzZy5uYW1lLFxuICAgICAgICAgIGluc3RhbmNlVHlwZTogYXNnLmluc3RhbmNlX3R5cGUsXG4gICAgICAgICAgY3VycmVudENhcGFjaXR5OiBkZXNpcmVkQ2FwYWNpdHksXG4gICAgICAgICAgbWluU2l6ZTogYXNnLm1pbl9zaXplLFxuICAgICAgICAgIG1heFNpemU6IGFzZy5tYXhfc2l6ZSxcbiAgICAgICAgICByZWNvbW1lbmRlZE1pblNpemU6IDEsXG4gICAgICAgICAgcmVjb21tZW5kZWRNYXhTaXplOiBkZXNpcmVkQ2FwYWNpdHkgKiAyLFxuICAgICAgICAgIHJlY29tbWVuZGF0aW9uOiBcIkVuYWJsZSBkeW5hbWljIHNjYWxpbmcgdG8gb3B0aW1pemUgY29zdHMgYmFzZWQgb24gZGVtYW5kXCIsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFFVSUNLLVdJTiBPUFRJTUlaQVRJT05TIC0gUGhhc2UgMiAoV2l0aCBtaWdyYXRpb25zKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIERldGVjdCBNdWx0aS1BWiBlbmFibGVkIG9uIG5vbi1wcm9kdWN0aW9uIFJEUyBpbnN0YW5jZXMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKiBNdWx0aS1BWiBkb3VibGVzIHRoZSBjb3N0IGFuZCBpcyB1bm5lY2Vzc2FyeSBmb3IgZGV2L3N0YWdpbmcvdGVzdCBlbnZpcm9ubWVudHNcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0TXVsdGlBek5vblByb2RGcm9tRGF0YShyZHNJbnN0YW5jZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W10pOiBXYXN0ZURldGVjdGlvbltdIHtcbiAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBNdWx0aS1BWiBOb24tUHJvZDogQ2hlY2tpbmcgJHtyZHNJbnN0YW5jZXMubGVuZ3RofSBSRFMgaW5zdGFuY2VzYClcblxuICAgIGNvbnN0IG5vblByb2RFbnZzID0gW1wiZGV2XCIsIFwic3RhZ2luZ1wiLCBcInRlc3RcIiwgXCJwcmV2aWV3XCIsIFwiZGV2ZWxvcG1lbnRcIiwgXCJxYVwiXVxuXG4gICAgLy8gRmlsdGVyOiBSRFMgd2l0aCBtdWx0aV9heiA9IHRydWUgYW5kIGVudiBpbiBub24tcHJvZCBsaXN0XG4gICAgY29uc3QgZmlsdGVyZWQgPSByZHNJbnN0YW5jZXMuZmlsdGVyKChyKSA9PiB7XG4gICAgICBjb25zdCBtdWx0aUF6ID0gci5tdWx0aV9heiBhcyBib29sZWFuXG4gICAgICBjb25zdCBlbnYgPSAoKHIuZW52IGFzIHN0cmluZykgfHwgXCJcIikudG9Mb3dlckNhc2UoKVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBSRFM6ICR7ci5kYl9pbnN0YW5jZV9pZH0gfCBtdWx0aV9hejogJHttdWx0aUF6fSB8IGVudjogJHtlbnZ9YClcblxuICAgICAgLy8gSWYgbXVsdGlfYXogY29sdW1uIGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZmFsc2UsIHNraXBcbiAgICAgIGlmIChtdWx0aUF6ICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IE11bHRpLUFaIG5vdCBlbmFibGVkYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIG5vbi1wcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgICBjb25zdCBpc05vblByb2QgPSBub25Qcm9kRW52cy5zb21lKChlKSA9PiBlbnYuaW5jbHVkZXMoZSkpXG4gICAgICBpZiAoIWlzTm9uUHJvZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBQcm9kdWN0aW9uIGVudmlyb25tZW50ICgke2Vudn0pYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIE1BVENIOiBNdWx0aS1BWiBvbiBub24tcHJvZCBSRFMgZGV0ZWN0ZWRgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTXVsdGktQVogTm9uLVByb2Q6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBpbnN0YW5jZXNgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgocmRzKSA9PiB7XG4gICAgICBjb25zdCBzY2VuYXJpbyA9IFdBU1RFX1NDRU5BUklPUy5tdWx0aV9hel9ub25fcHJvZFxuICAgICAgY29uc3QgbW9udGhseUNvc3QgPSBnZXRSRFNNb250aGx5Q29zdChyZHMuaW5zdGFuY2VfY2xhc3MgYXMgc3RyaW5nKVxuICAgICAgLy8gTXVsdGktQVogcm91Z2hseSBkb3VibGVzIHRoZSBjb3N0XG4gICAgICBjb25zdCBwb3RlbnRpYWxTYXZpbmdzID0gbW9udGhseUNvc3QgKiAwLjVcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGV0ZWN0aW9uKHtcbiAgICAgICAgc2NlbmFyaW9JZDogXCJtdWx0aV9hel9ub25fcHJvZFwiLFxuICAgICAgICByZXNvdXJjZTogcmRzLFxuICAgICAgICByZXNvdXJjZVR5cGU6IFwicmRzX2luc3RhbmNlc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwiZGJfaW5zdGFuY2VfaWRcIixcbiAgICAgICAgbW9udGhseUNvc3QsXG4gICAgICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgICAgIGNvbmZpZGVuY2U6IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgZGJJbnN0YW5jZUlkOiByZHMuZGJfaW5zdGFuY2VfaWQsXG4gICAgICAgICAgaW5zdGFuY2VDbGFzczogcmRzLmluc3RhbmNlX2NsYXNzLFxuICAgICAgICAgIGVuZ2luZTogcmRzLmVuZ2luZSxcbiAgICAgICAgICBlbnY6IHJkcy5lbnYsXG4gICAgICAgICAgbXVsdGlBejogdHJ1ZSxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbjogXCJEaXNhYmxlIE11bHRpLUFaIGZvciBub24tcHJvZHVjdGlvbiB3b3JrbG9hZHNcIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgZW1wdHkgTG9hZCBCYWxhbmNlcnMgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKiBMb2FkIGJhbGFuY2VycyB3aXRoIHRhcmdldF9jb3VudCA9IDAgb3IgaGVhbHRoeV90YXJnZXRfY291bnQgPSAwXG4gICAqL1xuICBwcml2YXRlIGRldGVjdEVtcHR5TG9hZEJhbGFuY2Vyc0Zyb21EYXRhKGxiczogUmVjb3JkPHN0cmluZywgdW5rbm93bj5bXSk6IFdhc3RlRGV0ZWN0aW9uW10ge1xuICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIEVtcHR5IExvYWQgQmFsYW5jZXJzOiBDaGVja2luZyAke2xicy5sZW5ndGh9IGxvYWQgYmFsYW5jZXJzYClcblxuICAgIC8vIEZpbHRlcjogTEJzIHdpdGggdGFyZ2V0X2NvdW50ID0gMFxuICAgIGNvbnN0IGZpbHRlcmVkID0gbGJzLmZpbHRlcigobGIpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldENvdW50ID0gbGIudGFyZ2V0X2NvdW50IGFzIG51bWJlciB8IG51bGxcbiAgICAgIGNvbnN0IGhlYWx0aHlUYXJnZXRDb3VudCA9IGxiLmhlYWx0aHlfdGFyZ2V0X2NvdW50IGFzIG51bWJlciB8IG51bGxcblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gTEI6ICR7bGIubmFtZX0gfCB0YXJnZXRfY291bnQ6ICR7dGFyZ2V0Q291bnR9IHwgaGVhbHRoeV90YXJnZXRfY291bnQ6ICR7aGVhbHRoeVRhcmdldENvdW50fWApXG5cbiAgICAgIC8vIElmIHRhcmdldF9jb3VudCBjb2x1bW4gZXhpc3RzIGFuZCBpcyAwLCBpdCdzIGVtcHR5XG4gICAgICBpZiAodGFyZ2V0Q291bnQgIT09IG51bGwgJiYgdGFyZ2V0Q291bnQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRDb3VudCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogRW1wdHkgTEIgKHRhcmdldF9jb3VudCA9IDApYClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaGVhbHRoeV90YXJnZXRfY291bnQgZXhpc3RzIGFuZCBpcyAwIChidXQgdGFyZ2V0X2NvdW50IG1pZ2h0IGJlID4gMClcbiAgICAgIGlmIChoZWFsdGh5VGFyZ2V0Q291bnQgIT09IG51bGwgJiYgaGVhbHRoeVRhcmdldENvdW50ICE9PSB1bmRlZmluZWQgJiYgaGVhbHRoeVRhcmdldENvdW50ID09PSAwICYmIHRhcmdldENvdW50ICE9PSBudWxsICYmIHRhcmdldENvdW50ID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBNQVRDSDogTEIgd2l0aCBubyBoZWFsdGh5IHRhcmdldHNgKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBMQiBoYXMgdGFyZ2V0c2ApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gRW1wdHkgTG9hZCBCYWxhbmNlcnM6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBlbXB0eSBMQnNgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgobGIpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLmVtcHR5X2xvYWRfYmFsYW5jZXJcbiAgICAgIC8vIEJhc2UgQUxCIGNvc3QgaXMgfiQxNi9tbyArIExDVSBjaGFyZ2VzXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGdldExvYWRCYWxhbmNlck1vbnRobHlDb3N0KDApXG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwiZW1wdHlfbG9hZF9iYWxhbmNlclwiLFxuICAgICAgICByZXNvdXJjZTogbGIsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJsb2FkX2JhbGFuY2Vyc1wiLFxuICAgICAgICBuYW1lRmllbGQ6IFwibmFtZVwiLFxuICAgICAgICBtb250aGx5Q29zdCxcbiAgICAgICAgcG90ZW50aWFsU2F2aW5nczogbW9udGhseUNvc3QsXG4gICAgICAgIGNvbmZpZGVuY2U6IHNjZW5hcmlvLmJhc2VDb25maWRlbmNlLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgbmFtZTogbGIubmFtZSxcbiAgICAgICAgICB0eXBlOiBsYi50eXBlLFxuICAgICAgICAgIHRhcmdldENvdW50OiBsYi50YXJnZXRfY291bnQgPz8gXCJ1bmtub3duXCIsXG4gICAgICAgICAgaGVhbHRoeVRhcmdldENvdW50OiBsYi5oZWFsdGh5X3RhcmdldF9jb3VudCA/PyBcInVua25vd25cIixcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbjogXCJEZWxldGUgbG9hZCBiYWxhbmNlciBvciByZWdpc3RlciBoZWFsdGh5IHRhcmdldHNcIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgUzMgYnVja2V0cyB3aXRoIHZlcnNpb25pbmcgYnV0IG5vIG5vbmN1cnJlbnQgdmVyc2lvbiBleHBpcmF0aW9uIChJTi1NRU1PUlkgdmVyc2lvbilcbiAgICogVmVyc2lvbmVkIGJ1Y2tldHMgd2l0aG91dCBleHBpcmF0aW9uIGFjY3VtdWxhdGUgb2xkIHZlcnNpb25zIGluZGVmaW5pdGVseVxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RTM05vVmVyc2lvbkV4cGlyYXRpb25Gcm9tRGF0YShidWNrZXRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gUzMgTm8gVmVyc2lvbiBFeHBpcmF0aW9uOiBDaGVja2luZyAke2J1Y2tldHMubGVuZ3RofSBTMyBidWNrZXRzYClcblxuICAgIC8vIEZpbHRlcjogdmVyc2lvbmVkIGJ1Y2tldHMgd2l0aG91dCBub25jdXJyZW50IHZlcnNpb24gZXhwaXJhdGlvblxuICAgIGNvbnN0IGZpbHRlcmVkID0gYnVja2V0cy5maWx0ZXIoKGIpID0+IHtcbiAgICAgIGNvbnN0IHZlcnNpb25pbmdFbmFibGVkID0gYi52ZXJzaW9uaW5nX2VuYWJsZWQgYXMgYm9vbGVhblxuICAgICAgY29uc3QgbGlmZWN5Y2xlUnVsZXMgPSBiLmxpZmVjeWNsZV9ydWxlcyBhcyB1bmtub3duW10gfCBudWxsXG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdIFMzOiAke2IubmFtZX0gfCB2ZXJzaW9uaW5nX2VuYWJsZWQ6ICR7dmVyc2lvbmluZ0VuYWJsZWR9IHwgbGlmZWN5Y2xlX3J1bGVzOiAke2xpZmVjeWNsZVJ1bGVzPy5sZW5ndGggPz8gMH1gKVxuXG4gICAgICAvLyBJZiB2ZXJzaW9uaW5nIG5vdCBlbmFibGVkLCBza2lwIChub3RoaW5nIHRvIGV4cGlyZSlcbiAgICAgIGlmICh2ZXJzaW9uaW5nRW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBWZXJzaW9uaW5nIG5vdCBlbmFibGVkYClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFueSBsaWZlY3ljbGUgcnVsZSBoYXMgbm9uY3VycmVudF92ZXJzaW9uX2V4cGlyYXRpb25cbiAgICAgIGlmIChsaWZlY3ljbGVSdWxlcyAmJiBBcnJheS5pc0FycmF5KGxpZmVjeWNsZVJ1bGVzKSkge1xuICAgICAgICBjb25zdCBoYXNOb25jdXJyZW50RXhwaXJhdGlvbiA9IGxpZmVjeWNsZVJ1bGVzLnNvbWUoKHJ1bGUpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gcnVsZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICAgIHJldHVybiByLm5vbmN1cnJlbnRfdmVyc2lvbl9leHBpcmF0aW9uIHx8IHIuTm9uY3VycmVudFZlcnNpb25FeHBpcmF0aW9uXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKGhhc05vbmN1cnJlbnRFeHBpcmF0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogSGFzIG5vbmN1cnJlbnQgdmVyc2lvbiBleHBpcmF0aW9uIHJ1bGVgKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIE1BVENIOiBWZXJzaW9uZWQgYnVja2V0IHdpdGhvdXQgbm9uY3VycmVudCB2ZXJzaW9uIGV4cGlyYXRpb25gKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gUzMgTm8gVmVyc2lvbiBFeHBpcmF0aW9uOiBGb3VuZCAke2ZpbHRlcmVkLmxlbmd0aH0gYnVja2V0c2ApXG5cbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChidWNrZXQpID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLnMzX25vX3ZlcnNpb25fZXhwaXJhdGlvblxuICAgICAgLy8gRXN0aW1hdGUgYmFzZWQgb24gdHlwaWNhbCB2ZXJzaW9uIGFjY3VtdWxhdGlvblxuICAgICAgY29uc3QgZXN0aW1hdGVkVmVyc2lvblN0b3JhZ2VHYiA9IDUwXG4gICAgICBjb25zdCBtb250aGx5Q29zdCA9IGVzdGltYXRlZFZlcnNpb25TdG9yYWdlR2IgKiAwLjAyM1xuICAgICAgY29uc3QgcG90ZW50aWFsU2F2aW5ncyA9IG1vbnRobHlDb3N0ICogMC43IC8vIDcwJSBzYXZpbmdzIGZyb20gZXhwaXJpbmcgb2xkIHZlcnNpb25zXG5cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURldGVjdGlvbih7XG4gICAgICAgIHNjZW5hcmlvSWQ6IFwiczNfbm9fdmVyc2lvbl9leHBpcmF0aW9uXCIsXG4gICAgICAgIHJlc291cmNlOiBidWNrZXQsXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJzM19idWNrZXRzXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzLFxuICAgICAgICBjb25maWRlbmNlOiBzY2VuYXJpby5iYXNlQ29uZmlkZW5jZSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGJ1Y2tldE5hbWU6IGJ1Y2tldC5uYW1lLFxuICAgICAgICAgIHZlcnNpb25pbmdFbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGhhc05vbmN1cnJlbnRFeHBpcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbjogXCJBZGQgbGlmZWN5Y2xlIHJ1bGUgdG8gZXhwaXJlIG5vbmN1cnJlbnQgdmVyc2lvbnMgYWZ0ZXIgMzAgZGF5c1wiLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBMYW1iZGEgZnVuY3Rpb25zIHdpdGggb3Zlci1jb25maWd1cmVkIHRpbWVvdXQgKElOLU1FTU9SWSB2ZXJzaW9uKVxuICAgKiBGdW5jdGlvbnMgd2l0aCB0aW1lb3V0ID4+IGFjdHVhbCBkdXJhdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBkZXRlY3RPdmVyQ29uZmlndXJlZFRpbWVvdXRGcm9tRGF0YShsYW1iZGFzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPltdKTogV2FzdGVEZXRlY3Rpb25bXSB7XG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gT3Zlci1Db25maWd1cmVkIFRpbWVvdXQ6IENoZWNraW5nICR7bGFtYmRhcy5sZW5ndGh9IExhbWJkYSBmdW5jdGlvbnNgKVxuXG4gICAgLy8gRmlsdGVyOiBmdW5jdGlvbnMgd2hlcmUgdGltZW91dCBpcyAzeCsgdGhlIGFjdHVhbCBhdmcgZHVyYXRpb25cbiAgICBjb25zdCBmaWx0ZXJlZCA9IGxhbWJkYXMuZmlsdGVyKChmbikgPT4ge1xuICAgICAgY29uc3QgdGltZW91dFNlY29uZHMgPSAoZm4udGltZW91dF9zZWNvbmRzIGFzIG51bWJlcikgfHwgMzBcbiAgICAgIGNvbnN0IGF2Z0R1cmF0aW9uTXMgPSBmbi5hdmdfZHVyYXRpb25fbXNfN2QgYXMgbnVtYmVyIHwgbnVsbFxuXG4gICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSBMYW1iZGE6ICR7Zm4ubmFtZX0gfCB0aW1lb3V0OiAke3RpbWVvdXRTZWNvbmRzfXMgfCBhdmdfZHVyYXRpb25fbXNfN2Q6ICR7YXZnRHVyYXRpb25Nc31gKVxuXG4gICAgICAvLyBOZWVkIGR1cmF0aW9uIGRhdGEgdG8gY29tcGFyZVxuICAgICAgaWYgKGF2Z0R1cmF0aW9uTXMgPT09IG51bGwgfHwgYXZnRHVyYXRpb25NcyA9PT0gdW5kZWZpbmVkIHx8IGF2Z0R1cmF0aW9uTXMgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgU0tJUDogTm8gZHVyYXRpb24gZGF0YWApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHRvIHNhbWUgdW5pdHMgKHNlY29uZHMpXG4gICAgICBjb25zdCBhdmdEdXJhdGlvblNlY29uZHMgPSBhdmdEdXJhdGlvbk1zIC8gMTAwMFxuXG4gICAgICAvLyBGbGFnIGlmIHRpbWVvdXQgaXMgM3ggb3IgbW9yZSB0aGUgYWN0dWFsIGR1cmF0aW9uXG4gICAgICBpZiAodGltZW91dFNlY29uZHMgPCBhdmdEdXJhdGlvblNlY29uZHMgKiAzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbRGV0ZWN0b3JdICAg4oaSIFNLSVA6IFRpbWVvdXQgJHt0aW1lb3V0U2Vjb25kc31zIGlzIHJlYXNvbmFibGUgZm9yICR7YXZnRHVyYXRpb25TZWNvbmRzLnRvRml4ZWQoMSl9cyBhdmcgZHVyYXRpb25gKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gQWxzbyBza2lwIGlmIHRpbWVvdXQgaXMgYWxyZWFkeSBzbWFsbCAoPCAxMHMpXG4gICAgICBpZiAodGltZW91dFNlY29uZHMgPCAxMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RldGVjdG9yXSAgIOKGkiBTS0lQOiBUaW1lb3V0IGFscmVhZHkgb3B0aW1pemVkICg8IDEwcylgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gICDihpIgTUFUQ0g6IFRpbWVvdXQgJHt0aW1lb3V0U2Vjb25kc31zID4+IGF2ZyBkdXJhdGlvbiAke2F2Z0R1cmF0aW9uU2Vjb25kcy50b0ZpeGVkKDEpfXNgKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFtEZXRlY3Rvcl0gT3Zlci1Db25maWd1cmVkIFRpbWVvdXQ6IEZvdW5kICR7ZmlsdGVyZWQubGVuZ3RofSBmdW5jdGlvbnNgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkLm1hcCgoZm4pID0+IHtcbiAgICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TLm92ZXJfY29uZmlndXJlZF9sYW1iZGFfdGltZW91dFxuICAgICAgY29uc3QgbWVtb3J5TWIgPSAoZm4ubWVtb3J5X21iIGFzIG51bWJlcikgfHwgMTI4XG4gICAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IChmbi50aW1lb3V0X3NlY29uZHMgYXMgbnVtYmVyKSB8fCAzMFxuICAgICAgY29uc3QgYXZnRHVyYXRpb25NcyA9IChmbi5hdmdfZHVyYXRpb25fbXNfN2QgYXMgbnVtYmVyKSB8fCAwXG4gICAgICBjb25zdCBpbnZvY2F0aW9uczdkID0gKGZuLmludm9jYXRpb25zXzdkIGFzIG51bWJlcikgfHwgMFxuXG4gICAgICAvLyBDYWxjdWxhdGUgcmVjb21tZW5kZWQgdGltZW91dCAoMnggYXZnIGR1cmF0aW9uLCByb3VuZGVkIHVwLCBtaW4gM3MpXG4gICAgICBjb25zdCByZWNvbW1lbmRlZFRpbWVvdXQgPSBNYXRoLm1heCgzLCBNYXRoLmNlaWwoKGF2Z0R1cmF0aW9uTXMgLyAxMDAwKSAqIDIpKVxuXG4gICAgICAvLyBMYW1iZGEgYmlsbGluZyBpcyBwZXIgMW1zIG9mIGV4ZWN1dGlvbiwgYnV0IHRpbWVvdXQgaXRzZWxmIGRvZXNuJ3QgZGlyZWN0bHkgY29zdFxuICAgICAgLy8gSG93ZXZlciwgb3Zlci1jb25maWd1cmVkIHRpbWVvdXQgY2FuIGxlYWQgdG8gcnVuYXdheSBjb3N0cyBpZiBmdW5jdGlvbnMgaGFuZ1xuICAgICAgY29uc3QgbW9udGhseUNvc3QgPSBnZXRMYW1iZGFNb250aGx5Q29zdChtZW1vcnlNYiwgYXZnRHVyYXRpb25NcywgaW52b2NhdGlvbnM3ZCAqICgzMCAvIDcpKVxuICAgICAgY29uc3QgcG90ZW50aWFsU2F2aW5ncyA9IG1vbnRobHlDb3N0ICogMC4xIC8vIEluZGlyZWN0IHNhdmluZ3MgZnJvbSBiZXR0ZXIgcmVzb3VyY2UgbWFuYWdlbWVudFxuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZXRlY3Rpb24oe1xuICAgICAgICBzY2VuYXJpb0lkOiBcIm92ZXJfY29uZmlndXJlZF9sYW1iZGFfdGltZW91dFwiLFxuICAgICAgICByZXNvdXJjZTogZm4sXG4gICAgICAgIHJlc291cmNlVHlwZTogXCJsYW1iZGFfZnVuY3Rpb25zXCIsXG4gICAgICAgIG5hbWVGaWVsZDogXCJuYW1lXCIsXG4gICAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgICBwb3RlbnRpYWxTYXZpbmdzLFxuICAgICAgICBjb25maWRlbmNlOiBzY2VuYXJpby5iYXNlQ29uZmlkZW5jZSxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZm4ubmFtZSxcbiAgICAgICAgICBjdXJyZW50VGltZW91dDogdGltZW91dFNlY29uZHMsXG4gICAgICAgICAgYXZnRHVyYXRpb25NczogYXZnRHVyYXRpb25NcyxcbiAgICAgICAgICByZWNvbW1lbmRlZFRpbWVvdXQsXG4gICAgICAgICAgaW52b2NhdGlvbnM3ZCxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbjogYFJlZHVjZSB0aW1lb3V0IGZyb20gJHt0aW1lb3V0U2Vjb25kc31zIHRvICR7cmVjb21tZW5kZWRUaW1lb3V0fXNgLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBjcmVhdGUgYSBkZXRlY3Rpb24gb2JqZWN0XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZURldGVjdGlvbih7XG4gICAgc2NlbmFyaW9JZCxcbiAgICByZXNvdXJjZSxcbiAgICByZXNvdXJjZVR5cGUsXG4gICAgbmFtZUZpZWxkLFxuICAgIG1vbnRobHlDb3N0LFxuICAgIHBvdGVudGlhbFNhdmluZ3MsXG4gICAgY29uZmlkZW5jZSxcbiAgICBkZXRhaWxzLFxuICB9OiB7XG4gICAgc2NlbmFyaW9JZDogV2FzdGVTY2VuYXJpb0lkXG4gICAgcmVzb3VyY2U6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGVcbiAgICBuYW1lRmllbGQ6IHN0cmluZ1xuICAgIG1vbnRobHlDb3N0OiBudW1iZXJcbiAgICBwb3RlbnRpYWxTYXZpbmdzOiBudW1iZXJcbiAgICBjb25maWRlbmNlOiBudW1iZXJcbiAgICBkZXRhaWxzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICB9KTogV2FzdGVEZXRlY3Rpb24ge1xuICAgIGNvbnN0IHNjZW5hcmlvID0gV0FTVEVfU0NFTkFSSU9TW3NjZW5hcmlvSWRdXG4gICAgY29uc3QgY2FuQXV0b09wdGltaXplID0gc2NlbmFyaW8ubW9kZSA9PT0gMiAmJiAhcmVzb3VyY2Uub3B0aW1pemF0aW9uX3BvbGljeV9sb2NrZWRcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogYCR7c2NlbmFyaW9JZH0tJHtyZXNvdXJjZS5pZH1gLFxuICAgICAgc2NlbmFyaW9JZCxcbiAgICAgIHNjZW5hcmlvLFxuICAgICAgLy8gRmxhdHRlbmVkIHNjZW5hcmlvIHByb3BlcnRpZXMgZm9yIGhvb2tzIGNvbXBhdGliaWxpdHlcbiAgICAgIHNjZW5hcmlvTmFtZTogc2NlbmFyaW8ubmFtZSxcbiAgICAgIG1vZGU6IHNjZW5hcmlvLm1vZGUsXG4gICAgICBhY3Rpb246IHNjZW5hcmlvLmFjdGlvbixcbiAgICAgIHJlc291cmNlSWQ6IFN0cmluZyhyZXNvdXJjZS5pZCksXG4gICAgICByZXNvdXJjZVR5cGUsXG4gICAgICByZXNvdXJjZU5hbWU6IFN0cmluZyhyZXNvdXJjZVtuYW1lRmllbGRdIHx8IHJlc291cmNlLmlkKSxcbiAgICAgIGFjY291bnRJZDogU3RyaW5nKHJlc291cmNlLmFjY291bnRfaWQgfHwgXCJcIiksXG4gICAgICByZWdpb246IFN0cmluZyhyZXNvdXJjZS5yZWdpb24gfHwgXCJcIiksXG4gICAgICBlbnY6IFN0cmluZyhyZXNvdXJjZS5lbnYgfHwgXCJ1bmtub3duXCIpLFxuICAgICAgY29uZmlkZW5jZSxcbiAgICAgIG1vbnRobHlDb3N0LFxuICAgICAgcG90ZW50aWFsU2F2aW5ncyxcbiAgICAgIGRldGFpbHMsXG4gICAgICBjYW5BdXRvT3B0aW1pemUsXG4gICAgICBvcHRpbWl6YXRpb25Qb2xpY3lMb2NrZWQ6IEJvb2xlYW4ocmVzb3VyY2Uub3B0aW1pemF0aW9uX3BvbGljeV9sb2NrZWQpLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgcmVzb3VyY2UgY291bnRzIGZyb20gcHJlLWZldGNoZWQgZGF0YSAoMCBleHRyYSBxdWVyaWVzKVxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlUmVzb3VyY2VDb3VudHMocmVzb3VyY2VEYXRhOiBSZXNvdXJjZURhdGEpOiBSZXNvdXJjZUNvdW50cyB7XG4gICAgY29uc3QgY291bnRzOiBSZXNvdXJjZUNvdW50cyA9IHtcbiAgICAgIGluc3RhbmNlczogcmVzb3VyY2VEYXRhLmluc3RhbmNlcy5sZW5ndGgsXG4gICAgICByZHNJbnN0YW5jZXM6IHJlc291cmNlRGF0YS5yZHNJbnN0YW5jZXMubGVuZ3RoLFxuICAgICAgY2FjaGVDbHVzdGVyczogcmVzb3VyY2VEYXRhLmNhY2hlQ2x1c3RlcnMubGVuZ3RoLFxuICAgICAgbG9hZEJhbGFuY2VyczogcmVzb3VyY2VEYXRhLmxvYWRCYWxhbmNlcnMubGVuZ3RoLFxuICAgICAgbGFtYmRhRnVuY3Rpb25zOiByZXNvdXJjZURhdGEubGFtYmRhRnVuY3Rpb25zLmxlbmd0aCxcbiAgICAgIHZvbHVtZXM6IHJlc291cmNlRGF0YS52b2x1bWVzLmxlbmd0aCxcbiAgICAgIHNuYXBzaG90czogcmVzb3VyY2VEYXRhLnNuYXBzaG90cy5sZW5ndGgsXG4gICAgICBlbGFzdGljSXBzOiByZXNvdXJjZURhdGEuZWxhc3RpY0lwcy5sZW5ndGgsXG4gICAgICBzM0J1Y2tldHM6IHJlc291cmNlRGF0YS5zM0J1Y2tldHMubGVuZ3RoLFxuICAgICAgbG9nR3JvdXBzOiByZXNvdXJjZURhdGEubG9nR3JvdXBzLmxlbmd0aCxcbiAgICAgIGF1dG9zY2FsaW5nR3JvdXBzOiByZXNvdXJjZURhdGEuYXV0b3NjYWxpbmdHcm91cHMubGVuZ3RoLFxuICAgICAgdG90YWw6IDAsXG4gICAgfVxuICAgIGNvdW50cy50b3RhbCA9IE9iamVjdC52YWx1ZXMoY291bnRzKS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApXG4gICAgcmV0dXJuIGNvdW50c1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBzdW1tYXJ5IHN0YXRpc3RpY3NcbiAgICovXG4gIHByaXZhdGUgY2FsY3VsYXRlU3VtbWFyeShkZXRlY3Rpb25zOiBXYXN0ZURldGVjdGlvbltdKTogRGV0ZWN0aW9uU3VtbWFyeSB7XG4gICAgY29uc3Qgc3VtbWFyeTogRGV0ZWN0aW9uU3VtbWFyeSA9IHtcbiAgICAgIHRvdGFsUmVzb3VyY2VzOiAwLFxuICAgICAgd2FzdGVEZXRlY3RlZDogZGV0ZWN0aW9ucy5sZW5ndGgsXG4gICAgICB0b3RhbE1vbnRobHlDb3N0OiAwLFxuICAgICAgdG90YWxQb3RlbnRpYWxTYXZpbmdzOiAwLFxuICAgICAgYXV0b09wdGltaXphYmxlU2F2aW5nczogMCxcbiAgICAgIGJ5U2NlbmFyaW86IHt9IGFzIFJlY29yZDxXYXN0ZVNjZW5hcmlvSWQsIG51bWJlcj4sXG4gICAgICBieVNldmVyaXR5OiB7XG4gICAgICAgIGhpZ2g6IDAsXG4gICAgICAgIG1lZGl1bTogMCxcbiAgICAgICAgbG93OiAwLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRldGVjdGlvbiBvZiBkZXRlY3Rpb25zKSB7XG4gICAgICBzdW1tYXJ5LnRvdGFsTW9udGhseUNvc3QgKz0gZGV0ZWN0aW9uLm1vbnRobHlDb3N0XG4gICAgICBzdW1tYXJ5LnRvdGFsUG90ZW50aWFsU2F2aW5ncyArPSBkZXRlY3Rpb24ucG90ZW50aWFsU2F2aW5nc1xuXG4gICAgICBpZiAoZGV0ZWN0aW9uLmNhbkF1dG9PcHRpbWl6ZSkge1xuICAgICAgICBzdW1tYXJ5LmF1dG9PcHRpbWl6YWJsZVNhdmluZ3MgKz0gZGV0ZWN0aW9uLnBvdGVudGlhbFNhdmluZ3NcbiAgICAgIH1cblxuICAgICAgLy8gQ291bnQgYnkgc2NlbmFyaW9cbiAgICAgIHN1bW1hcnkuYnlTY2VuYXJpb1tkZXRlY3Rpb24uc2NlbmFyaW9JZF0gPVxuICAgICAgICAoc3VtbWFyeS5ieVNjZW5hcmlvW2RldGVjdGlvbi5zY2VuYXJpb0lkXSB8fCAwKSArIDFcblxuICAgICAgLy8gQ291bnQgYnkgc2V2ZXJpdHlcbiAgICAgIHN1bW1hcnkuYnlTZXZlcml0eVtkZXRlY3Rpb24uc2NlbmFyaW8uc2V2ZXJpdHldKytcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtbWFyeVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkYXlzIHNpbmNlIGEgZGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBkYXlzU2luY2UoZGF0ZVN0cmluZzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZylcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgZGlmZk1zID0gbm93LmdldFRpbWUoKSAtIGRhdGUuZ2V0VGltZSgpXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGlmZk1zIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGV0ZWN0b3IgaW5zdGFuY2UgZnJvbSBjb25uZWN0aW9uIGRldGFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURldGVjdG9yKHN1cGFiYXNlVXJsOiBzdHJpbmcsIHN1cGFiYXNlS2V5OiBzdHJpbmcpOiBXYXN0ZURldGVjdG9yIHtcbiAgcmV0dXJuIG5ldyBXYXN0ZURldGVjdG9yKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSlcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgZGV0ZWN0aW9uIGNhY2hlICh1c2VmdWwgZm9yIGZvcmNpbmcgYSBmcmVzaCBkZXRlY3Rpb24pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckRldGVjdGlvbkNhY2hlKCk6IHZvaWQge1xuICBkZXRlY3Rpb25DYWNoZSA9IG51bGxcbiAgLy8gY29uc29sZS5sb2coXCJbRGV0ZWN0b3JdIENhY2hlIGNsZWFyZWRcIilcbn1cblxuLyoqXG4gKiBHZXQgY2FjaGUgc3RhdHVzIGZvciBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlU3RhdHVzKCk6IHsgY2FjaGVkOiBib29sZWFuOyBhZ2VNczogbnVtYmVyIHwgbnVsbCB9IHtcbiAgaWYgKCFkZXRlY3Rpb25DYWNoZSkge1xuICAgIHJldHVybiB7IGNhY2hlZDogZmFsc2UsIGFnZU1zOiBudWxsIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNhY2hlZDogdHJ1ZSxcbiAgICBhZ2VNczogRGF0ZS5ub3coKSAtIGRldGVjdGlvbkNhY2hlLnRpbWVzdGFtcCxcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsIldBU1RFX1NDRU5BUklPUyIsImdldEVDMk1vbnRobHlDb3N0IiwiZ2V0UkRTTW9udGhseUNvc3QiLCJnZXRDYWNoZU1vbnRobHlDb3N0IiwiZ2V0TG9hZEJhbGFuY2VyTW9udGhseUNvc3QiLCJnZXRWb2x1bWVNb250aGx5Q29zdCIsImdldFNuYXBzaG90TW9udGhseUNvc3QiLCJnZXRVbmF0dGFjaGVkRUlQTW9udGhseUNvc3QiLCJnZXRTM1RpZXJpbmdTYXZpbmdzIiwiZ2V0TGFtYmRhTW9udGhseUNvc3QiLCJnZXRSZWNvbW1lbmRlZFNtYWxsZXJJbnN0YW5jZSIsImdldEVDMkluc3RhbmNlU3BlY3MiLCJkZXRlY3Rpb25DYWNoZSIsIkNBQ0hFX1RUTF9NUyIsIldhc3RlRGV0ZWN0b3IiLCJjb25zdHJ1Y3RvciIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VLZXkiLCJzdXBhYmFzZSIsImRldGVjdEFsbCIsImRldGVjdEFsbFN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiY29uc29sZSIsImxvZyIsImFnZSIsIkRhdGUiLCJ0aW1lc3RhbXAiLCJjYWNoZUhpdFRpbWUiLCJNYXRoIiwicm91bmQiLCJ0b0ZpeGVkIiwicmVzdWx0IiwiZmV0Y2hTdGFydFRpbWUiLCJyZXNvdXJjZURhdGEiLCJiYXRjaEZldGNoQWxsUmVzb3VyY2VzIiwiZmV0Y2hEdXJhdGlvbiIsImluc3RhbmNlcyIsImxlbmd0aCIsInJkc0luc3RhbmNlcyIsImNhY2hlQ2x1c3RlcnMiLCJsb2FkQmFsYW5jZXJzIiwibGFtYmRhRnVuY3Rpb25zIiwidm9sdW1lcyIsInNuYXBzaG90cyIsImVsYXN0aWNJcHMiLCJzM0J1Y2tldHMiLCJsb2dHcm91cHMiLCJhdXRvc2NhbGluZ0dyb3VwcyIsImRldGVjdGlvbnMiLCJ0b0lTT1N0cmluZyIsImlkbGVJbnN0YW5jZXMiLCJkZXRlY3RJZGxlSW5zdGFuY2VzRnJvbURhdGEiLCJwdXNoIiwib3JwaGFuZWRFaXBzIiwiZGV0ZWN0T3JwaGFuZWRFSVBzRnJvbURhdGEiLCJ1bmF0dGFjaGVkVm9sdW1lcyIsImRldGVjdFVuYXR0YWNoZWRWb2x1bWVzRnJvbURhdGEiLCJvbGRTbmFwc2hvdHMiLCJkZXRlY3RPbGRTbmFwc2hvdHNGcm9tRGF0YSIsImlkbGVSZHMiLCJkZXRlY3RJZGxlUkRTRnJvbURhdGEiLCJpZGxlQ2FjaGUiLCJkZXRlY3RJZGxlQ2FjaGVGcm9tRGF0YSIsImlkbGVMYnMiLCJkZXRlY3RJZGxlTG9hZEJhbGFuY2Vyc0Zyb21EYXRhIiwib3ZlclByb3ZMYW1iZGFzIiwiZGV0ZWN0T3ZlclByb3Zpc2lvbmVkTGFtYmRhc0Zyb21EYXRhIiwiczNOb0xpZmVjeWNsZSIsImRldGVjdFMzTm9MaWZlY3ljbGVGcm9tRGF0YSIsImxvZ05vUmV0ZW50aW9uIiwiZGV0ZWN0TG9nTm9SZXRlbnRpb25Gcm9tRGF0YSIsImZvcmdvdHRlblByZXZpZXdzIiwiZGV0ZWN0Rm9yZ290dGVuUHJldmlld3NGcm9tRGF0YSIsIm92ZXJQcm92QXNncyIsImRldGVjdE92ZXJQcm92aXNpb25lZEFTR3NGcm9tRGF0YSIsInN0YWxlRmVhdHVyZUVudnMiLCJkZXRlY3RTdGFsZUZlYXR1cmVFbnZzRnJvbURhdGEiLCJpZGxlQ2lSdW5uZXJzIiwiZGV0ZWN0SWRsZUNJUnVubmVyc0Zyb21EYXRhIiwib2ZmSG91cnNEZXYiLCJkZXRlY3RPZmZIb3Vyc0Rldkluc3RhbmNlc0Zyb21EYXRhIiwib3ZlclByb3ZJbnN0YW5jZXMiLCJkZXRlY3RPdmVyUHJvdmlzaW9uZWRJbnN0YW5jZXNGcm9tRGF0YSIsImdwMlZvbHVtZXMiLCJkZXRlY3RHcDJWb2x1bWVzRnJvbURhdGEiLCJ1bnVzZWRMYW1iZGFzIiwiZGV0ZWN0VW51c2VkTGFtYmRhc0Zyb21EYXRhIiwib3JwaGFuZWRTbmFwc2hvdHMiLCJkZXRlY3RPcnBoYW5lZFNuYXBzaG90c0Zyb21EYXRhIiwic3RhdGljQXNncyIsImRldGVjdFN0YXRpY0FTR3NGcm9tRGF0YSIsIm11bHRpQXpOb25Qcm9kIiwiZGV0ZWN0TXVsdGlBek5vblByb2RGcm9tRGF0YSIsImVtcHR5TGJzIiwiZGV0ZWN0RW1wdHlMb2FkQmFsYW5jZXJzRnJvbURhdGEiLCJzM05vVmVyc2lvbkV4cGlyYXRpb24iLCJkZXRlY3RTM05vVmVyc2lvbkV4cGlyYXRpb25Gcm9tRGF0YSIsIm92ZXJDb25maWd1cmVkVGltZW91dCIsImRldGVjdE92ZXJDb25maWd1cmVkVGltZW91dEZyb21EYXRhIiwic3VtbWFyeSIsImNhbGN1bGF0ZVN1bW1hcnkiLCJyZXNvdXJjZUNvdW50cyIsImNvbXB1dGVSZXNvdXJjZUNvdW50cyIsInRvdGFsRHVyYXRpb24iLCJ0b3RhbFBvdGVudGlhbFNhdmluZ3MiLCJQcm9taXNlIiwiYWxsIiwiZnJvbSIsInNlbGVjdCIsImRhdGEiLCJmaWx0ZXJlZCIsImZpbHRlciIsImkiLCJzdGF0ZSIsImF2ZzdkQ3B1IiwiYXZnX2NwdV83ZCIsImN1cnJlbnRDcHUiLCJjdXJyZW50X2NwdSIsImNwdVZhbHVlIiwidW5kZWZpbmVkIiwibWFwIiwiaW5zdGFuY2UiLCJzY2VuYXJpbyIsImlkbGVfaW5zdGFuY2UiLCJtb250aGx5Q29zdCIsImluc3RhbmNlX3R5cGUiLCJjb25maWRlbmNlIiwiYmFzZUNvbmZpZGVuY2UiLCJlbnYiLCJjcmVhdGVEZXRlY3Rpb24iLCJzY2VuYXJpb0lkIiwicmVzb3VyY2UiLCJyZXNvdXJjZVR5cGUiLCJuYW1lRmllbGQiLCJwb3RlbnRpYWxTYXZpbmdzIiwibWluIiwiZGV0YWlscyIsImluc3RhbmNlVHlwZSIsImF2Z0NwdTdkIiwibGF1bmNoVGltZSIsImxhdW5jaF90aW1lIiwiZGV0ZWN0SWRsZUluc3RhbmNlcyIsImVycm9yIiwiZXEiLCJsdCIsImVpcHMiLCJlIiwicHVibGljX2lwIiwiYXNzb2NpYXRlZF9pbnN0YW5jZV9pZCIsImVpcCIsIm9ycGhhbmVkX2VpcCIsInB1YmxpY0lwIiwiYWxsb2NhdGlvbklkIiwiYWxsb2NhdGlvbl9pZCIsImFzc29jaWF0ZWRXaXRoIiwiZGV0ZWN0T3JwaGFuZWRFSVBzIiwiaXMiLCJ2Iiwidm9sdW1lX2lkIiwic2l6ZV9naWIiLCJ2b2x1bWUiLCJ1bmF0dGFjaGVkX3ZvbHVtZSIsInZvbHVtZV90eXBlIiwiZGF5c1NpbmNlQ3JlYXRpb24iLCJkYXlzU2luY2UiLCJjcmVhdGVkX2F0Iiwidm9sdW1lSWQiLCJ2b2x1bWVUeXBlIiwic2l6ZUdpYiIsImRldGVjdFVuYXR0YWNoZWRWb2x1bWVzIiwicyIsImRheXNPbGQiLCJzbmFwc2hvdF9pZCIsInNuYXBzaG90Iiwib2xkX3NuYXBzaG90Iiwic25hcHNob3RJZCIsInJldGVudGlvblBvbGljeSIsInJldGVudGlvbl9wb2xpY3kiLCJkZXRlY3RPbGRTbmFwc2hvdHMiLCJyIiwiYXZnQ3B1IiwiYXZnQ29ubmVjdGlvbnMiLCJhdmdfY29ubmVjdGlvbnNfN2QiLCJjdXJyZW50Q29ubmVjdGlvbnMiLCJjdXJyZW50X2Nvbm5lY3Rpb25zIiwiY29ubmVjdGlvbnNWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNOb25Qcm9kIiwiaW5jbHVkZXMiLCJkYl9pbnN0YW5jZV9pZCIsImlzTG93Q3B1IiwiaXNMb3dDb25uZWN0aW9ucyIsImlzSWRsZU5vblByb2QiLCJoYXNOb01ldHJpY3MiLCJyZHMiLCJpZGxlX3JkcyIsImluc3RhbmNlX2NsYXNzIiwiZGJJbnN0YW5jZUlkIiwiaW5zdGFuY2VDbGFzcyIsImVuZ2luZSIsImF2Z0Nvbm5lY3Rpb25zN2QiLCJkZXRlY3RJZGxlUkRTIiwiY2x1c3RlcnMiLCJjIiwiY2x1c3Rlcl9pZCIsImNsdXN0ZXIiLCJpZGxlX2NhY2hlIiwibm9kZV90eXBlIiwibnVtX25vZGVzIiwiY2x1c3RlcklkIiwibm9kZVR5cGUiLCJudW1Ob2RlcyIsImRldGVjdElkbGVDYWNoZSIsImxicyIsImxiIiwiYXZnUmVxdWVzdENvdW50IiwiYXZnX3JlcXVlc3RfY291bnRfN2QiLCJjdXJyZW50UmVxdWVzdENvdW50IiwiY3VycmVudF9yZXF1ZXN0X2NvdW50IiwicmVxdWVzdENvdW50IiwibmFtZSIsInJlcXVlc3RDaGVjayIsImlkbGVfbG9hZF9iYWxhbmNlciIsInR5cGUiLCJhdmdSZXF1ZXN0Q291bnQ3ZCIsImRldGVjdElkbGVMb2FkQmFsYW5jZXJzIiwibGFtYmRhcyIsImZuIiwiYXZnTWVtb3J5IiwiYXZnX21lbW9yeV91c2VkX21iXzdkIiwibWVtb3J5TWIiLCJtZW1vcnlfbWIiLCJ1dGlsaXphdGlvblBjdCIsIm92ZXJfcHJvdmlzaW9uZWRfbGFtYmRhIiwib3B0aW1hbE1lbW9yeSIsIm1heCIsImNlaWwiLCJpbnZvY2F0aW9uczdkIiwiaW52b2NhdGlvbnNfN2QiLCJhdmdEdXJhdGlvbk1zIiwiYXZnX2R1cmF0aW9uX21zXzdkIiwibW9udGhseUludm9jYXRpb25zIiwiZXN0aW1hdGVkX21vbnRobHlfY29zdCIsImVzdGltYXRlZEludm9jYXRpb25zUGVyTW9udGgiLCJlc3RpbWF0ZWRBdmdEdXJhdGlvbiIsIm9wdGltaXplZE1vbnRobHlDb3N0IiwiZnVuY3Rpb25OYW1lIiwiY3VycmVudE1lbW9yeU1iIiwiYXZnTWVtb3J5VXNlZE1iIiwicmVjb21tZW5kZWRNZW1vcnlNYiIsImN1cnJlbnRNb250aGx5Q29zdCIsImRldGVjdE92ZXJQcm92aXNpb25lZExhbWJkYXMiLCJub3QiLCJidWNrZXRzIiwiYiIsInBvbGljeSIsImxpZmVjeWNsZV9wb2xpY3kiLCJydWxlcyIsImxpZmVjeWNsZV9ydWxlcyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleXMiLCJwb2xpY3lSdWxlcyIsImJ1Y2tldCIsInMzX25vX2xpZmVjeWNsZSIsImVzdGltYXRlZFNpemVHYiIsImJ1Y2tldE5hbWUiLCJsaWZlY3ljbGVQb2xpY3kiLCJyZWNvbW1lbmRhdGlvbiIsImRldGVjdFMzTm9MaWZlY3ljbGUiLCJsZyIsInJldGVudGlvbl9kYXlzIiwicmV0ZW50aW9uX2luX2RheXMiLCJsb2dfbm9fcmV0ZW50aW9uIiwibG9nR3JvdXBOYW1lIiwiY3VycmVudFJldGVudGlvbiIsInJlY29tbWVuZGVkUmV0ZW50aW9uIiwiZGV0ZWN0TG9nTm9SZXRlbnRpb24iLCJhc2dzIiwiYXNnIiwiZGVzaXJlZENhcGFjaXR5IiwiZGVzaXJlZF9jYXBhY2l0eSIsImN1cnJlbnRfdXRpbGl6YXRpb24iLCJpc1ByZXZpZXciLCJpc0xvd1V0aWwiLCJmb3Jnb3R0ZW5fcHJldmlldyIsImluc3RhbmNlQ29zdCIsImFzZ05hbWUiLCJjdXJyZW50VXRpbGl6YXRpb24iLCJkZXRlY3RGb3Jnb3R0ZW5QcmV2aWV3cyIsInV0aWxpemF0aW9uIiwibWluU2l6ZSIsIm1pbl9zaXplIiwib3Zlcl9wcm92aXNpb25lZF9hc2ciLCJvcHRpbWFsQ2FwYWNpdHkiLCJzYXZpbmdzQ2FwYWNpdHkiLCJjdXJyZW50Q2FwYWNpdHkiLCJtYXhTaXplIiwibWF4X3NpemUiLCJyZWNvbW1lbmRlZENhcGFjaXR5IiwiZGV0ZWN0T3ZlclByb3Zpc2lvbmVkQVNHcyIsImd0IiwiaXNGZWF0dXJlIiwic3RhbGVfZmVhdHVyZV9lbnYiLCJkZXRlY3RTdGFsZUZlYXR1cmVFbnZzIiwibG93Q3B1UnVubmluZyIsInRhZ3MiLCJ0YWdWYWx1ZXMiLCJ2YWx1ZXMiLCJTdHJpbmciLCJ0YWdLZXlzIiwiayIsImlzQ0kiLCJzb21lIiwiaWRsZV9jaV9ydW5uZXIiLCJpbnN0YW5jZU5hbWUiLCJkZXRlY3RJZGxlQ0lSdW5uZXJzIiwiZGF5T2ZXZWVrIiwiZ2V0RGF5IiwiaG91ciIsImdldEhvdXJzIiwiaXNXZWVrZW5kIiwiaXNPZmZIb3VycyIsIm9mZl9ob3Vyc19kZXYiLCJvZmZIb3Vyc1NhdmluZ3MiLCJjdXJyZW50SG91ciIsImRldGVjdE9mZkhvdXJzRGV2SW5zdGFuY2VzIiwicnVubmluZ0luc3RhbmNlcyIsImN1cnJlbnRNZW1vcnkiLCJjdXJyZW50X21lbW9yeSIsInNtYWxsZXJUeXBlIiwibG93Q3B1IiwibG93TWVtb3J5Iiwib3Zlcl9wcm92aXNpb25lZF9pbnN0YW5jZSIsImN1cnJlbnRTcGVjcyIsInJlY29tbWVuZGVkVHlwZSIsInJlY29tbWVuZGVkU3BlY3MiLCJyZWNvbW1lbmRlZE1vbnRobHlDb3N0IiwiaW5zdGFuY2VJZCIsImluc3RhbmNlX2lkIiwiY3VycmVudEluc3RhbmNlVHlwZSIsInJlY29tbWVuZGVkSW5zdGFuY2VUeXBlIiwiY3VycmVudFZjcHUiLCJ2Y3B1IiwiY3VycmVudE1lbW9yeUdiIiwibWVtb3J5R2IiLCJyZWNvbW1lbmRlZFZjcHUiLCJyZWNvbW1lbmRlZE1lbW9yeUdiIiwiY3VycmVudE1lbW9yeVBjdCIsImdwMl92b2x1bWUiLCJncDNDb3N0IiwiY3VycmVudFR5cGUiLCJwcm9qZWN0ZWRNb250aGx5Q29zdCIsImludm9jYXRpb25zIiwidW51c2VkX2xhbWJkYSIsImVzdGltYXRlZE1vbml0b3JpbmdDb3N0IiwicnVudGltZSIsImxhc3RNb2RpZmllZCIsInVwZGF0ZWRfYXQiLCJleGlzdGluZ1ZvbHVtZUlkcyIsIlNldCIsInNpemUiLCJzb3VyY2VWb2x1bWVJZCIsInNvdXJjZV92b2x1bWVfaWQiLCJoYXMiLCJvcnBoYW5lZF9zbmFwc2hvdCIsImNyZWF0ZWRBdCIsInN0YXRpY19hc2ciLCJyZWNvbW1lbmRlZE1pblNpemUiLCJyZWNvbW1lbmRlZE1heFNpemUiLCJub25Qcm9kRW52cyIsIm11bHRpQXoiLCJtdWx0aV9heiIsIm11bHRpX2F6X25vbl9wcm9kIiwidGFyZ2V0Q291bnQiLCJ0YXJnZXRfY291bnQiLCJoZWFsdGh5VGFyZ2V0Q291bnQiLCJoZWFsdGh5X3RhcmdldF9jb3VudCIsImVtcHR5X2xvYWRfYmFsYW5jZXIiLCJ2ZXJzaW9uaW5nRW5hYmxlZCIsInZlcnNpb25pbmdfZW5hYmxlZCIsImxpZmVjeWNsZVJ1bGVzIiwiaGFzTm9uY3VycmVudEV4cGlyYXRpb24iLCJydWxlIiwibm9uY3VycmVudF92ZXJzaW9uX2V4cGlyYXRpb24iLCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb24iLCJzM19ub192ZXJzaW9uX2V4cGlyYXRpb24iLCJlc3RpbWF0ZWRWZXJzaW9uU3RvcmFnZUdiIiwidGltZW91dFNlY29uZHMiLCJ0aW1lb3V0X3NlY29uZHMiLCJhdmdEdXJhdGlvblNlY29uZHMiLCJvdmVyX2NvbmZpZ3VyZWRfbGFtYmRhX3RpbWVvdXQiLCJyZWNvbW1lbmRlZFRpbWVvdXQiLCJjdXJyZW50VGltZW91dCIsImNhbkF1dG9PcHRpbWl6ZSIsIm1vZGUiLCJvcHRpbWl6YXRpb25fcG9saWN5X2xvY2tlZCIsImlkIiwic2NlbmFyaW9OYW1lIiwiYWN0aW9uIiwicmVzb3VyY2VJZCIsInJlc291cmNlTmFtZSIsImFjY291bnRJZCIsImFjY291bnRfaWQiLCJyZWdpb24iLCJvcHRpbWl6YXRpb25Qb2xpY3lMb2NrZWQiLCJCb29sZWFuIiwiY291bnRzIiwidG90YWwiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJ0b3RhbFJlc291cmNlcyIsIndhc3RlRGV0ZWN0ZWQiLCJ0b3RhbE1vbnRobHlDb3N0IiwiYXV0b09wdGltaXphYmxlU2F2aW5ncyIsImJ5U2NlbmFyaW8iLCJieVNldmVyaXR5IiwiaGlnaCIsIm1lZGl1bSIsImxvdyIsImRldGVjdGlvbiIsInNldmVyaXR5IiwiZGF0ZVN0cmluZyIsImRhdGUiLCJkaWZmTXMiLCJnZXRUaW1lIiwiZmxvb3IiLCJjcmVhdGVEZXRlY3RvciIsImNsZWFyRGV0ZWN0aW9uQ2FjaGUiLCJnZXRDYWNoZVN0YXR1cyIsImNhY2hlZCIsImFnZU1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/agent/detector.ts\n");

/***/ }),

/***/ "(rsc)/./lib/agent/executor.ts":
/*!*******************************!*\
  !*** ./lib/agent/executor.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExecutor: () => (/* binding */ createExecutor)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var _detector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./detector */ \"(rsc)/./lib/agent/detector.ts\");\n/**\n * Action Executor for Auto-Safe Optimizations (Phase 6)\n *\n * Executes optimization actions on cloud resources.\n * For this demo, actions update the Supabase database to simulate AWS operations.\n *\n * Actions supported:\n * - terminate_asg: Delete ASG and set instances to terminated\n * - scale_down_asg: Reduce ASG desired capacity\n * - terminate_instance: Terminate an EC2 instance\n * - stop_instance: Stop an EC2 instance\n * - rightsize_instance: Rightsize an EC2 instance to a smaller type\n * - add_lifecycle_policy: Add lifecycle policy to S3 bucket\n * - set_retention: Set retention policy on CloudWatch log group\n * - release_eip: Release an Elastic IP\n * - delete_volume: Delete an EBS volume\n * - delete_snapshot: Delete an EBS snapshot\n * - stop_rds: Stop an RDS instance\n * - downsize_rds: Downsize an RDS instance\n * - delete_cache: Delete an ElastiCache cluster\n * - delete_lb: Delete a load balancer\n * - rightsize_lambda: Rightsize a Lambda function\n */ \n\n/**\n * Creates an executor instance for running optimization actions\n */ function createExecutor(supabaseUrl, supabaseKey) {\n    console.log(\"[Executor] Creating executor instance\");\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseKey);\n    return {\n        /**\n     * Execute a single optimization action\n     */ async executeAction (params) {\n            const startTime = performance.now();\n            console.log(`[Executor] Executing action: ${params.action} on ${params.resourceType}/${params.resourceId}`);\n            try {\n                let result;\n                switch(params.action){\n                    case \"terminate_instance\":\n                        result = await terminateInstance(supabase, params, startTime);\n                        break;\n                    case \"stop_instance\":\n                        result = await stopInstance(supabase, params, startTime);\n                        break;\n                    case \"terminate_asg\":\n                        result = await terminateAsg(supabase, params, startTime);\n                        break;\n                    case \"scale_down_asg\":\n                        result = await scaleDownAsg(supabase, params, startTime);\n                        break;\n                    case \"release_eip\":\n                        result = await releaseEip(supabase, params, startTime);\n                        break;\n                    case \"delete_volume\":\n                        result = await deleteVolume(supabase, params, startTime);\n                        break;\n                    case \"delete_snapshot\":\n                        result = await deleteSnapshot(supabase, params, startTime);\n                        break;\n                    case \"add_lifecycle_policy\":\n                        result = await addLifecyclePolicy(supabase, params, startTime);\n                        break;\n                    case \"set_retention\":\n                        result = await setRetention(supabase, params, startTime);\n                        break;\n                    case \"stop_rds\":\n                        result = await stopRds(supabase, params, startTime);\n                        break;\n                    case \"downsize_rds\":\n                        result = await downsizeRds(supabase, params, startTime);\n                        break;\n                    case \"delete_cache\":\n                        result = await deleteCache(supabase, params, startTime);\n                        break;\n                    case \"delete_lb\":\n                        result = await deleteLoadBalancer(supabase, params, startTime);\n                        break;\n                    case \"rightsize_lambda\":\n                        result = await rightsizeLambda(supabase, params, startTime);\n                        break;\n                    case \"rightsize_instance\":\n                        result = await rightsizeInstance(supabase, params, startTime);\n                        break;\n                    // Phase 1: Quick-win actions\n                    case \"upgrade_volume_type\":\n                        result = await upgradeVolumeType(supabase, params, startTime);\n                        break;\n                    case \"delete_lambda\":\n                        result = await deleteLambda(supabase, params, startTime);\n                        break;\n                    case \"delete_orphaned_snapshot\":\n                        result = await deleteOrphanedSnapshot(supabase, params, startTime);\n                        break;\n                    case \"enable_asg_scaling\":\n                        result = await enableAsgScaling(supabase, params, startTime);\n                        break;\n                    // Phase 2: Quick-win actions\n                    case \"disable_multi_az\":\n                        result = await disableMultiAz(supabase, params, startTime);\n                        break;\n                    case \"delete_empty_lb\":\n                        result = await deleteEmptyLb(supabase, params, startTime);\n                        break;\n                    case \"add_version_expiration\":\n                        result = await addVersionExpiration(supabase, params, startTime);\n                        break;\n                    case \"optimize_lambda_timeout\":\n                        result = await optimizeLambdaTimeout(supabase, params, startTime);\n                        break;\n                    default:\n                        throw new Error(`Unknown action type: ${params.action}`);\n                }\n                // Log the action to audit log\n                await logAction(supabase, params, result);\n                // Clear the detection cache so next detection fetch returns fresh data\n                if (result.success) {\n                    (0,_detector__WEBPACK_IMPORTED_MODULE_0__.clearDetectionCache)();\n                    console.log(`[Executor] Detection cache cleared after successful action`);\n                }\n                const duration = performance.now() - startTime;\n                console.log(`[Executor] ‚úÖ Action completed in ${duration.toFixed(0)}ms: ${result.message}`);\n                return result;\n            } catch (error) {\n                const duration = performance.now() - startTime;\n                console.error(`[Executor] ‚ùå Action failed after ${duration.toFixed(0)}ms:`, error);\n                const failedResult = {\n                    success: false,\n                    action: params.action,\n                    resourceId: params.resourceId,\n                    resourceType: params.resourceType,\n                    message: error instanceof Error ? error.message : \"Action failed\",\n                    executedAt: new Date().toISOString(),\n                    durationMs: duration\n                };\n                // Log the failed action\n                await logAction(supabase, params, failedResult).catch(console.error);\n                return failedResult;\n            }\n        },\n        /**\n     * Get audit log entries\n     */ async getAuditLog (limit = 50) {\n            console.log(`[Executor] Fetching audit log (limit: ${limit})`);\n            const startTime = performance.now();\n            const { data, error } = await supabase.from(\"action_audit_log\").select(\"*\").order(\"executed_at\", {\n                ascending: false\n            }).limit(limit);\n            if (error) {\n                console.error(`[Executor] ‚ùå Failed to fetch audit log:`, error);\n                return [];\n            }\n            const duration = performance.now() - startTime;\n            console.log(`[Executor] Fetched ${data?.length ?? 0} audit entries in ${duration.toFixed(0)}ms`);\n            return data ?? [];\n        }\n    };\n}\n/**\n * Log action to audit table\n */ async function logAction(supabase, params, result) {\n    console.log(`[Executor] Logging action to audit log`);\n    const entry = {\n        action: params.action,\n        resource_type: params.resourceType,\n        resource_id: params.resourceId,\n        resource_name: params.resourceName,\n        scenario_id: params.scenarioId,\n        detection_id: params.detectionId,\n        success: result.success,\n        message: result.message,\n        previous_state: result.previousState ?? null,\n        new_state: result.newState ?? null,\n        executed_at: result.executedAt,\n        duration_ms: Math.round(result.durationMs),\n        executed_by: \"auto-safe-agent\"\n    };\n    const { error } = await supabase.from(\"action_audit_log\").insert(entry);\n    if (error) {\n        console.error(`[Executor] ‚ùå Failed to log action:`, error);\n    // Don't throw - audit logging failure shouldn't fail the action\n    }\n}\n// =============================================================================\n// Instance Actions\n// =============================================================================\nasync function terminateInstance(supabase, params, startTime) {\n    console.log(`[Executor] Terminating instance: ${params.resourceId}`);\n    // Get current state - try by id first, then by instance_id\n    let { data: instance, error: fetchError } = await supabase.from(\"instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !instance) {\n        const result = await supabase.from(\"instances\").select(\"*\").eq(\"instance_id\", params.resourceId).single();\n        instance = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !instance) {\n        throw new Error(`Instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        state: instance.state\n    };\n    // Update to terminated using the instance's actual id\n    const { error: updateError } = await supabase.from(\"instances\").update({\n        state: \"terminated\",\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", instance.id);\n    if (updateError) {\n        throw new Error(`Failed to terminate instance: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Instance ${instance.instance_id || params.resourceName} terminated successfully`,\n        previousState,\n        newState: {\n            state: \"terminated\"\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\nasync function stopInstance(supabase, params, startTime) {\n    console.log(`[Executor] Stopping instance: ${params.resourceId}`);\n    // Get current state - try by id first, then by instance_id\n    let { data: instance, error: fetchError } = await supabase.from(\"instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to instance_id if not found by id\n    if (fetchError || !instance) {\n        const result = await supabase.from(\"instances\").select(\"*\").eq(\"instance_id\", params.resourceId).single();\n        instance = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !instance) {\n        throw new Error(`Instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        state: instance.state\n    };\n    // Update to stopped using the instance's actual id\n    const { error: updateError } = await supabase.from(\"instances\").update({\n        state: \"stopped\",\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", instance.id);\n    if (updateError) {\n        throw new Error(`Failed to stop instance: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Instance ${instance.instance_id || params.resourceName} stopped successfully`,\n        previousState,\n        newState: {\n            state: \"stopped\"\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// Auto Scaling Group Actions\n// =============================================================================\nasync function terminateAsg(supabase, params, startTime) {\n    console.log(`[Executor] Terminating ASG: ${params.resourceId}`);\n    // Get current state - try by id first, then by asg_name\n    let { data: asg, error: fetchError } = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to asg_name if not found by id\n    if (fetchError || !asg) {\n        const result = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"asg_name\", params.resourceId).single();\n        asg = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !asg) {\n        throw new Error(`ASG not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        desired_capacity: asg.desired_capacity,\n        min_size: asg.min_size,\n        max_size: asg.max_size\n    };\n    // Set all capacities to 0 (simulating termination)\n    const { error: updateError } = await supabase.from(\"autoscaling_groups\").update({\n        desired_capacity: 0,\n        min_size: 0,\n        max_size: 0,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", asg.id);\n    if (updateError) {\n        throw new Error(`Failed to terminate ASG: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `ASG ${params.resourceName} terminated (capacity set to 0)`,\n        previousState,\n        newState: {\n            desired_capacity: 0,\n            min_size: 0,\n            max_size: 0\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\nasync function scaleDownAsg(supabase, params, startTime) {\n    console.log(`[Executor] Scaling down ASG: ${params.resourceId}`);\n    // Get current state - try by id first, then by asg_name\n    let { data: asg, error: fetchError } = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to asg_name if not found by id\n    if (fetchError || !asg) {\n        const result = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"asg_name\", params.resourceId).single();\n        asg = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !asg) {\n        throw new Error(`ASG not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        desired_capacity: asg.desired_capacity,\n        min_size: asg.min_size\n    };\n    // Scale down by 50% or to min 1\n    const newDesired = Math.max(1, Math.floor(asg.desired_capacity / 2));\n    const newMin = Math.min(newDesired, asg.min_size);\n    const { error: updateError } = await supabase.from(\"autoscaling_groups\").update({\n        desired_capacity: newDesired,\n        min_size: newMin,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", asg.id);\n    if (updateError) {\n        throw new Error(`Failed to scale down ASG: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `ASG ${params.resourceName} scaled down from ${asg.desired_capacity} to ${newDesired}`,\n        previousState,\n        newState: {\n            desired_capacity: newDesired,\n            min_size: newMin\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// Elastic IP Actions\n// =============================================================================\nasync function releaseEip(supabase, params, startTime) {\n    console.log(`[Executor] Releasing EIP: ${params.resourceId}`);\n    // Get current state - try by id first, then by allocation_id\n    let { data: eip, error: fetchError } = await supabase.from(\"elastic_ips\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to allocation_id if not found by id\n    if (fetchError || !eip) {\n        const result = await supabase.from(\"elastic_ips\").select(\"*\").eq(\"allocation_id\", params.resourceId).single();\n        eip = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !eip) {\n        throw new Error(`Elastic IP not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        public_ip: eip.public_ip,\n        association_id: eip.association_id\n    };\n    // Delete the EIP record (simulating release)\n    const { error: deleteError } = await supabase.from(\"elastic_ips\").delete().eq(\"id\", eip.id);\n    if (deleteError) {\n        throw new Error(`Failed to release EIP: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Elastic IP ${eip.public_ip} released successfully`,\n        previousState,\n        newState: {\n            released: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// EBS Volume Actions\n// =============================================================================\nasync function deleteVolume(supabase, params, startTime) {\n    console.log(`[Executor] Deleting volume: ${params.resourceId}`);\n    // Get current state - try by id first, then by volume_id\n    let { data: volume, error: fetchError } = await supabase.from(\"volumes\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to volume_id if not found by id\n    if (fetchError || !volume) {\n        const result = await supabase.from(\"volumes\").select(\"*\").eq(\"volume_id\", params.resourceId).single();\n        volume = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !volume) {\n        throw new Error(`Volume not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        state: volume.state,\n        size_gb: volume.size_gb,\n        volume_type: volume.volume_type\n    };\n    // Update state to deleted (or actually delete)\n    const { error: updateError } = await supabase.from(\"volumes\").update({\n        state: \"deleted\",\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", volume.id);\n    if (updateError) {\n        throw new Error(`Failed to delete volume: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Volume ${params.resourceName} (${volume.size_gb}GB) deleted successfully`,\n        previousState,\n        newState: {\n            state: \"deleted\"\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// EBS Snapshot Actions\n// =============================================================================\nasync function deleteSnapshot(supabase, params, startTime) {\n    console.log(`[Executor] Deleting snapshot: ${params.resourceId}`);\n    // Get current state - try by id first, then by snapshot_id\n    let { data: snapshot, error: fetchError } = await supabase.from(\"snapshots\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to snapshot_id if not found by id\n    if (fetchError || !snapshot) {\n        const result = await supabase.from(\"snapshots\").select(\"*\").eq(\"snapshot_id\", params.resourceId).single();\n        snapshot = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !snapshot) {\n        throw new Error(`Snapshot not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        state: snapshot.state,\n        volume_size_gb: snapshot.volume_size_gb,\n        start_time: snapshot.start_time\n    };\n    // Delete the snapshot record\n    const { error: deleteError } = await supabase.from(\"snapshots\").delete().eq(\"id\", snapshot.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete snapshot: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Snapshot ${params.resourceName} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// S3 Bucket Actions\n// =============================================================================\nasync function addLifecyclePolicy(supabase, params, startTime) {\n    console.log(`[Executor] Adding lifecycle policy to bucket: ${params.resourceId}`);\n    // Get current state - try by id first, then by bucket_name\n    let { data: bucket, error: fetchError } = await supabase.from(\"s3_buckets\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to bucket_name if not found by id\n    if (fetchError || !bucket) {\n        const result = await supabase.from(\"s3_buckets\").select(\"*\").eq(\"bucket_name\", params.resourceId).single();\n        bucket = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !bucket) {\n        throw new Error(`S3 bucket not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        lifecycle_rules: bucket.lifecycle_rules\n    };\n    // Add intelligent tiering lifecycle rule\n    const newLifecycleRules = [\n        ...bucket.lifecycle_rules || [],\n        {\n            id: \"intelligent-tiering\",\n            status: \"Enabled\",\n            transitions: [\n                {\n                    days: 30,\n                    storage_class: \"INTELLIGENT_TIERING\"\n                },\n                {\n                    days: 90,\n                    storage_class: \"GLACIER\"\n                }\n            ]\n        }\n    ];\n    const { error: updateError } = await supabase.from(\"s3_buckets\").update({\n        lifecycle_rules: newLifecycleRules\n    }).eq(\"id\", bucket.id);\n    if (updateError) {\n        throw new Error(`Failed to add lifecycle policy: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Lifecycle policy added to bucket ${params.resourceName}`,\n        previousState,\n        newState: {\n            lifecycle_rules: newLifecycleRules\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// CloudWatch Log Group Actions\n// =============================================================================\nasync function setRetention(supabase, params, startTime) {\n    console.log(`[Executor] Setting retention on log group: ${params.resourceId}`);\n    // Get current state - try by id first, then by log_group_name\n    let { data: logGroup, error: fetchError } = await supabase.from(\"log_groups\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to log_group_name if not found by id\n    if (fetchError || !logGroup) {\n        const result = await supabase.from(\"log_groups\").select(\"*\").eq(\"log_group_name\", params.resourceId).single();\n        logGroup = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !logGroup) {\n        throw new Error(`Log group not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        retention_in_days: logGroup.retention_in_days\n    };\n    // Set 30-day retention\n    const newRetention = 30;\n    const { error: updateError } = await supabase.from(\"log_groups\").update({\n        retention_in_days: newRetention\n    }).eq(\"id\", logGroup.id);\n    if (updateError) {\n        throw new Error(`Failed to set retention: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Retention set to ${newRetention} days for ${logGroup.log_group_name || params.resourceName}`,\n        previousState,\n        newState: {\n            retention_in_days: newRetention\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// RDS Actions\n// =============================================================================\nasync function stopRds(supabase, params, startTime) {\n    console.log(`[Executor] Stopping RDS instance: ${params.resourceId}`);\n    // Get current state - try by id first, then by db_instance_id\n    let { data: rds, error: fetchError } = await supabase.from(\"rds_instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to db_instance_id if not found by id\n    if (fetchError || !rds) {\n        const result = await supabase.from(\"rds_instances\").select(\"*\").eq(\"db_instance_id\", params.resourceId).single();\n        rds = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !rds) {\n        throw new Error(`RDS instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        status: rds.status\n    };\n    const { error: updateError } = await supabase.from(\"rds_instances\").update({\n        status: \"stopped\",\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", rds.id);\n    if (updateError) {\n        throw new Error(`Failed to stop RDS instance: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `RDS instance ${params.resourceName} stopped successfully`,\n        previousState,\n        newState: {\n            status: \"stopped\"\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\nasync function downsizeRds(supabase, params, startTime) {\n    console.log(`[Executor] Downsizing RDS instance: ${params.resourceId}`);\n    // Get current state - try by id first, then by db_instance_id\n    let { data: rds, error: fetchError } = await supabase.from(\"rds_instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to db_instance_id if not found by id\n    if (fetchError || !rds) {\n        const result = await supabase.from(\"rds_instances\").select(\"*\").eq(\"db_instance_id\", params.resourceId).single();\n        rds = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !rds) {\n        throw new Error(`RDS instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        instance_class: rds.instance_class\n    };\n    // Downsize to smaller instance class\n    const instanceSizes = [\n        \"db.t3.micro\",\n        \"db.t3.small\",\n        \"db.t3.medium\",\n        \"db.t3.large\",\n        \"db.t3.xlarge\"\n    ];\n    const currentIndex = instanceSizes.indexOf(rds.instance_class);\n    const newClass = currentIndex > 0 ? instanceSizes[currentIndex - 1] : rds.instance_class;\n    const { error: updateError } = await supabase.from(\"rds_instances\").update({\n        instance_class: newClass,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", rds.id);\n    if (updateError) {\n        throw new Error(`Failed to downsize RDS instance: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `RDS instance ${params.resourceName} downsized from ${rds.instance_class} to ${newClass}`,\n        previousState,\n        newState: {\n            instance_class: newClass\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// ElastiCache Actions\n// =============================================================================\nasync function deleteCache(supabase, params, startTime) {\n    console.log(`[Executor] Deleting cache cluster: ${params.resourceId}`);\n    // Get current state - try by id first, then by cluster_id\n    let { data: cache, error: fetchError } = await supabase.from(\"cache_clusters\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to cluster_id if not found by id\n    if (fetchError || !cache) {\n        const result = await supabase.from(\"cache_clusters\").select(\"*\").eq(\"cluster_id\", params.resourceId).single();\n        cache = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !cache) {\n        throw new Error(`Cache cluster not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        cluster_id: cache.cluster_id,\n        node_type: cache.node_type,\n        num_nodes: cache.num_nodes\n    };\n    // Delete the cache cluster record\n    const { error: deleteError } = await supabase.from(\"cache_clusters\").delete().eq(\"id\", cache.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete cache cluster: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Cache cluster ${params.resourceName} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// Load Balancer Actions\n// =============================================================================\nasync function deleteLoadBalancer(supabase, params, startTime) {\n    console.log(`[Executor] Deleting load balancer: ${params.resourceId}`);\n    // Get current state - try by id first, then by lb_arn\n    let { data: lb, error: fetchError } = await supabase.from(\"load_balancers\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to lb_arn if not found by id\n    if (fetchError || !lb) {\n        const result = await supabase.from(\"load_balancers\").select(\"*\").eq(\"lb_arn\", params.resourceId).single();\n        lb = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !lb) {\n        throw new Error(`Load balancer not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        state: lb.state,\n        type: lb.type\n    };\n    // Delete the load balancer record\n    const { error: deleteError } = await supabase.from(\"load_balancers\").delete().eq(\"id\", lb.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete load balancer: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Load balancer ${params.resourceName} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// Lambda Actions\n// =============================================================================\nasync function rightsizeLambda(supabase, params, startTime) {\n    console.log(`[Executor] Rightsizing Lambda function: ${params.resourceId}`);\n    // Get current state - try by id first, then by function_name\n    let { data: lambda, error: fetchError } = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to function_name if not found by id\n    if (fetchError || !lambda) {\n        const result = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"function_name\", params.resourceId).single();\n        lambda = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !lambda) {\n        throw new Error(`Lambda function not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        memory_mb: lambda.memory_mb\n    };\n    // Rightsize to 50% of current or minimum 128MB\n    const newMemory = Math.max(128, Math.floor(lambda.memory_mb / 2));\n    const { error: updateError } = await supabase.from(\"lambda_functions\").update({\n        memory_mb: newMemory,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", lambda.id);\n    if (updateError) {\n        throw new Error(`Failed to rightsize Lambda: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Lambda ${lambda.function_name || params.resourceName} rightsized from ${lambda.memory_mb}MB to ${newMemory}MB`,\n        previousState,\n        newState: {\n            memory_mb: newMemory\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// EC2 Instance Rightsizing Actions\n// =============================================================================\nasync function rightsizeInstance(supabase, params, startTime) {\n    console.log(`[Executor] Rightsizing EC2 instance: ${params.resourceId}`);\n    // Get current state - try by id first, then by instance_id\n    let { data: instance, error: fetchError } = await supabase.from(\"instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    // Fallback to instance_id if not found by id\n    if (fetchError || !instance) {\n        const result = await supabase.from(\"instances\").select(\"*\").eq(\"instance_id\", params.resourceId).single();\n        instance = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !instance) {\n        throw new Error(`Instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        instance_type: instance.instance_type\n    };\n    // Get the recommended instance type from detection details\n    const recommendedType = params.details?.recommendedInstanceType;\n    if (!recommendedType) {\n        throw new Error(`No recommended instance type provided for rightsizing`);\n    }\n    // Update to the recommended instance type\n    const { error: updateError } = await supabase.from(\"instances\").update({\n        instance_type: recommendedType,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", instance.id);\n    if (updateError) {\n        throw new Error(`Failed to rightsize instance: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Instance ${instance.instance_id || params.resourceName} rightsized from ${instance.instance_type} to ${recommendedType}`,\n        previousState,\n        newState: {\n            instance_type: recommendedType\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// QUICK-WIN OPTIMIZATIONS - Phase 1 Actions\n// =============================================================================\n/**\n * Upgrade EBS volume from gp2 to gp3\n */ async function upgradeVolumeType(supabase, params, startTime) {\n    console.log(`[Executor] Upgrading volume type: ${params.resourceId}`);\n    // Get current state - try by id first, then by volume_id\n    let { data: volume, error: fetchError } = await supabase.from(\"volumes\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !volume) {\n        const result = await supabase.from(\"volumes\").select(\"*\").eq(\"volume_id\", params.resourceId).single();\n        volume = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !volume) {\n        throw new Error(`Volume not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        volume_type: volume.volume_type\n    };\n    // Update to gp3\n    const { error: updateError } = await supabase.from(\"volumes\").update({\n        volume_type: \"gp3\",\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", volume.id);\n    if (updateError) {\n        throw new Error(`Failed to upgrade volume type: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Volume ${volume.volume_id} upgraded from gp2 to gp3`,\n        previousState,\n        newState: {\n            volume_type: \"gp3\"\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Delete unused Lambda function\n */ async function deleteLambda(supabase, params, startTime) {\n    console.log(`[Executor] Deleting Lambda function: ${params.resourceId}`);\n    // Get current state - try by id first, then by function_name\n    let { data: lambda, error: fetchError } = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !lambda) {\n        const result = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"function_name\", params.resourceId).single();\n        lambda = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !lambda) {\n        throw new Error(`Lambda function not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        name: lambda.name,\n        memory_mb: lambda.memory_mb,\n        runtime: lambda.runtime\n    };\n    // Delete the Lambda function record\n    const { error: deleteError } = await supabase.from(\"lambda_functions\").delete().eq(\"id\", lambda.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete Lambda function: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Lambda function ${lambda.name} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Delete orphaned EBS snapshot\n */ async function deleteOrphanedSnapshot(supabase, params, startTime) {\n    console.log(`[Executor] Deleting orphaned snapshot: ${params.resourceId}`);\n    // Get current state - try by id first, then by snapshot_id\n    let { data: snapshot, error: fetchError } = await supabase.from(\"snapshots\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !snapshot) {\n        const result = await supabase.from(\"snapshots\").select(\"*\").eq(\"snapshot_id\", params.resourceId).single();\n        snapshot = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !snapshot) {\n        throw new Error(`Snapshot not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        snapshot_id: snapshot.snapshot_id,\n        source_volume_id: snapshot.source_volume_id,\n        size_gib: snapshot.size_gib\n    };\n    // Delete the snapshot record\n    const { error: deleteError } = await supabase.from(\"snapshots\").delete().eq(\"id\", snapshot.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete orphaned snapshot: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Orphaned snapshot ${snapshot.snapshot_id} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Enable dynamic scaling for static ASG\n */ async function enableAsgScaling(supabase, params, startTime) {\n    console.log(`[Executor] Enabling ASG scaling: ${params.resourceId}`);\n    // Get current state - try by id first, then by asg_name\n    let { data: asg, error: fetchError } = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !asg) {\n        const result = await supabase.from(\"autoscaling_groups\").select(\"*\").eq(\"asg_name\", params.resourceId).single();\n        asg = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !asg) {\n        throw new Error(`ASG not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        min_size: asg.min_size,\n        max_size: asg.max_size,\n        desired_capacity: asg.desired_capacity\n    };\n    // Enable scaling: set min to 1, max to 2x current\n    const newMinSize = 1;\n    const newMaxSize = Math.max(asg.desired_capacity * 2, 4);\n    const { error: updateError } = await supabase.from(\"autoscaling_groups\").update({\n        min_size: newMinSize,\n        max_size: newMaxSize,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", asg.id);\n    if (updateError) {\n        throw new Error(`Failed to enable ASG scaling: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `ASG ${params.resourceName} scaling enabled (min: ${newMinSize}, max: ${newMaxSize})`,\n        previousState,\n        newState: {\n            min_size: newMinSize,\n            max_size: newMaxSize\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n// =============================================================================\n// QUICK-WIN OPTIMIZATIONS - Phase 2 Actions\n// =============================================================================\n/**\n * Disable Multi-AZ for non-production RDS\n */ async function disableMultiAz(supabase, params, startTime) {\n    console.log(`[Executor] Disabling Multi-AZ: ${params.resourceId}`);\n    // Get current state - try by id first, then by db_instance_id\n    let { data: rds, error: fetchError } = await supabase.from(\"rds_instances\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !rds) {\n        const result = await supabase.from(\"rds_instances\").select(\"*\").eq(\"db_instance_id\", params.resourceId).single();\n        rds = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !rds) {\n        throw new Error(`RDS instance not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        multi_az: rds.multi_az\n    };\n    // Disable Multi-AZ\n    const { error: updateError } = await supabase.from(\"rds_instances\").update({\n        multi_az: false,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", rds.id);\n    if (updateError) {\n        throw new Error(`Failed to disable Multi-AZ: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Multi-AZ disabled for RDS ${rds.db_instance_id}`,\n        previousState,\n        newState: {\n            multi_az: false\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Delete empty load balancer\n */ async function deleteEmptyLb(supabase, params, startTime) {\n    console.log(`[Executor] Deleting empty load balancer: ${params.resourceId}`);\n    // Get current state - try by id first, then by lb_arn\n    let { data: lb, error: fetchError } = await supabase.from(\"load_balancers\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !lb) {\n        const result = await supabase.from(\"load_balancers\").select(\"*\").eq(\"lb_arn\", params.resourceId).single();\n        lb = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !lb) {\n        throw new Error(`Load balancer not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        name: lb.name,\n        type: lb.type,\n        target_count: lb.target_count\n    };\n    // Delete the load balancer record\n    const { error: deleteError } = await supabase.from(\"load_balancers\").delete().eq(\"id\", lb.id);\n    if (deleteError) {\n        throw new Error(`Failed to delete empty load balancer: ${deleteError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Empty load balancer ${lb.name} deleted successfully`,\n        previousState,\n        newState: {\n            deleted: true\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Add noncurrent version expiration to S3 bucket\n */ async function addVersionExpiration(supabase, params, startTime) {\n    console.log(`[Executor] Adding version expiration to bucket: ${params.resourceId}`);\n    // Get current state - try by id first, then by bucket_name\n    let { data: bucket, error: fetchError } = await supabase.from(\"s3_buckets\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !bucket) {\n        const result = await supabase.from(\"s3_buckets\").select(\"*\").eq(\"bucket_name\", params.resourceId).single();\n        bucket = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !bucket) {\n        throw new Error(`S3 bucket not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        lifecycle_rules: bucket.lifecycle_rules\n    };\n    // Add noncurrent version expiration rule\n    const existingRules = bucket.lifecycle_rules || [];\n    const newRule = {\n        id: \"expire-noncurrent-versions\",\n        status: \"Enabled\",\n        noncurrent_version_expiration: {\n            days: 30\n        }\n    };\n    const newLifecycleRules = [\n        ...existingRules,\n        newRule\n    ];\n    const { error: updateError } = await supabase.from(\"s3_buckets\").update({\n        lifecycle_rules: newLifecycleRules\n    }).eq(\"id\", bucket.id);\n    if (updateError) {\n        throw new Error(`Failed to add version expiration: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Version expiration (30 days) added to bucket ${bucket.name}`,\n        previousState,\n        newState: {\n            lifecycle_rules: newLifecycleRules\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n/**\n * Optimize Lambda function timeout\n */ async function optimizeLambdaTimeout(supabase, params, startTime) {\n    console.log(`[Executor] Optimizing Lambda timeout: ${params.resourceId}`);\n    // Get current state - try by id first, then by function_name\n    let { data: lambda, error: fetchError } = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"id\", params.resourceId).single();\n    if (fetchError || !lambda) {\n        const result = await supabase.from(\"lambda_functions\").select(\"*\").eq(\"function_name\", params.resourceId).single();\n        lambda = result.data;\n        fetchError = result.error;\n    }\n    if (fetchError || !lambda) {\n        throw new Error(`Lambda function not found: ${params.resourceId}`);\n    }\n    const previousState = {\n        timeout_seconds: lambda.timeout_seconds\n    };\n    // Get recommended timeout from detection details\n    const recommendedTimeout = params.details?.recommendedTimeout;\n    if (!recommendedTimeout) {\n        throw new Error(`No recommended timeout provided for optimization`);\n    }\n    // Update to the recommended timeout\n    const { error: updateError } = await supabase.from(\"lambda_functions\").update({\n        timeout_seconds: recommendedTimeout,\n        updated_at: new Date().toISOString()\n    }).eq(\"id\", lambda.id);\n    if (updateError) {\n        throw new Error(`Failed to optimize Lambda timeout: ${updateError.message}`);\n    }\n    return {\n        success: true,\n        action: params.action,\n        resourceId: params.resourceId,\n        resourceType: params.resourceType,\n        message: `Lambda ${lambda.name} timeout optimized from ${lambda.timeout_seconds}s to ${recommendedTimeout}s`,\n        previousState,\n        newState: {\n            timeout_seconds: recommendedTimeout\n        },\n        executedAt: new Date().toISOString(),\n        durationMs: performance.now() - startTime\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWdlbnQvZXhlY3V0b3IudHM/MTkwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFjdGlvbiBFeGVjdXRvciBmb3IgQXV0by1TYWZlIE9wdGltaXphdGlvbnMgKFBoYXNlIDYpXG4gKlxuICogRXhlY3V0ZXMgb3B0aW1pemF0aW9uIGFjdGlvbnMgb24gY2xvdWQgcmVzb3VyY2VzLlxuICogRm9yIHRoaXMgZGVtbywgYWN0aW9ucyB1cGRhdGUgdGhlIFN1cGFiYXNlIGRhdGFiYXNlIHRvIHNpbXVsYXRlIEFXUyBvcGVyYXRpb25zLlxuICpcbiAqIEFjdGlvbnMgc3VwcG9ydGVkOlxuICogLSB0ZXJtaW5hdGVfYXNnOiBEZWxldGUgQVNHIGFuZCBzZXQgaW5zdGFuY2VzIHRvIHRlcm1pbmF0ZWRcbiAqIC0gc2NhbGVfZG93bl9hc2c6IFJlZHVjZSBBU0cgZGVzaXJlZCBjYXBhY2l0eVxuICogLSB0ZXJtaW5hdGVfaW5zdGFuY2U6IFRlcm1pbmF0ZSBhbiBFQzIgaW5zdGFuY2VcbiAqIC0gc3RvcF9pbnN0YW5jZTogU3RvcCBhbiBFQzIgaW5zdGFuY2VcbiAqIC0gcmlnaHRzaXplX2luc3RhbmNlOiBSaWdodHNpemUgYW4gRUMyIGluc3RhbmNlIHRvIGEgc21hbGxlciB0eXBlXG4gKiAtIGFkZF9saWZlY3ljbGVfcG9saWN5OiBBZGQgbGlmZWN5Y2xlIHBvbGljeSB0byBTMyBidWNrZXRcbiAqIC0gc2V0X3JldGVudGlvbjogU2V0IHJldGVudGlvbiBwb2xpY3kgb24gQ2xvdWRXYXRjaCBsb2cgZ3JvdXBcbiAqIC0gcmVsZWFzZV9laXA6IFJlbGVhc2UgYW4gRWxhc3RpYyBJUFxuICogLSBkZWxldGVfdm9sdW1lOiBEZWxldGUgYW4gRUJTIHZvbHVtZVxuICogLSBkZWxldGVfc25hcHNob3Q6IERlbGV0ZSBhbiBFQlMgc25hcHNob3RcbiAqIC0gc3RvcF9yZHM6IFN0b3AgYW4gUkRTIGluc3RhbmNlXG4gKiAtIGRvd25zaXplX3JkczogRG93bnNpemUgYW4gUkRTIGluc3RhbmNlXG4gKiAtIGRlbGV0ZV9jYWNoZTogRGVsZXRlIGFuIEVsYXN0aUNhY2hlIGNsdXN0ZXJcbiAqIC0gZGVsZXRlX2xiOiBEZWxldGUgYSBsb2FkIGJhbGFuY2VyXG4gKiAtIHJpZ2h0c2l6ZV9sYW1iZGE6IFJpZ2h0c2l6ZSBhIExhbWJkYSBmdW5jdGlvblxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCwgU3VwYWJhc2VDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCJcbmltcG9ydCB7IEFjdGlvblR5cGUsIFJlc291cmNlVHlwZSB9IGZyb20gXCIuL3NjZW5hcmlvc1wiXG5pbXBvcnQgeyBjbGVhckRldGVjdGlvbkNhY2hlIH0gZnJvbSBcIi4vZGV0ZWN0b3JcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvblJlc3VsdCB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW5cbiAgYWN0aW9uOiBBY3Rpb25UeXBlXG4gIHJlc291cmNlSWQ6IHN0cmluZ1xuICByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZVxuICBtZXNzYWdlOiBzdHJpbmdcbiAgcHJldmlvdXNTdGF0ZT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gIG5ld1N0YXRlPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgZXhlY3V0ZWRBdDogc3RyaW5nXG4gIGR1cmF0aW9uTXM6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGVBY3Rpb25QYXJhbXMge1xuICBhY3Rpb246IEFjdGlvblR5cGVcbiAgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGVcbiAgcmVzb3VyY2VJZDogc3RyaW5nXG4gIHJlc291cmNlTmFtZTogc3RyaW5nXG4gIGRldGVjdGlvbklkOiBzdHJpbmdcbiAgc2NlbmFyaW9JZDogc3RyaW5nXG4gIGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGl0TG9nRW50cnkge1xuICBhY3Rpb246IEFjdGlvblR5cGVcbiAgcmVzb3VyY2VfdHlwZTogUmVzb3VyY2VUeXBlXG4gIHJlc291cmNlX2lkOiBzdHJpbmdcbiAgcmVzb3VyY2VfbmFtZTogc3RyaW5nXG4gIHNjZW5hcmlvX2lkOiBzdHJpbmdcbiAgZGV0ZWN0aW9uX2lkOiBzdHJpbmdcbiAgc3VjY2VzczogYm9vbGVhblxuICBtZXNzYWdlOiBzdHJpbmdcbiAgcHJldmlvdXNfc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbFxuICBuZXdfc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbFxuICBleGVjdXRlZF9hdDogc3RyaW5nXG4gIGR1cmF0aW9uX21zOiBudW1iZXJcbiAgZXhlY3V0ZWRfYnk6IHN0cmluZ1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXhlY3V0b3IgaW5zdGFuY2UgZm9yIHJ1bm5pbmcgb3B0aW1pemF0aW9uIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4ZWN1dG9yKHN1cGFiYXNlVXJsOiBzdHJpbmcsIHN1cGFiYXNlS2V5OiBzdHJpbmcpIHtcbiAgY29uc29sZS5sb2coXCJbRXhlY3V0b3JdIENyZWF0aW5nIGV4ZWN1dG9yIGluc3RhbmNlXCIpXG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSlcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBzaW5nbGUgb3B0aW1pemF0aW9uIGFjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVBY3Rpb24ocGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBFeGVjdXRpbmcgYWN0aW9uOiAke3BhcmFtcy5hY3Rpb259IG9uICR7cGFyYW1zLnJlc291cmNlVHlwZX0vJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcmVzdWx0OiBBY3Rpb25SZXN1bHRcblxuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5hY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFwidGVybWluYXRlX2luc3RhbmNlXCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0ZXJtaW5hdGVJbnN0YW5jZShzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJzdG9wX2luc3RhbmNlXCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBzdG9wSW5zdGFuY2Uoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwidGVybWluYXRlX2FzZ1wiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGVybWluYXRlQXNnKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBcInNjYWxlX2Rvd25fYXNnXCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBzY2FsZURvd25Bc2coc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwicmVsZWFzZV9laXBcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlbGVhc2VFaXAoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwiZGVsZXRlX3ZvbHVtZVwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZGVsZXRlVm9sdW1lKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBcImRlbGV0ZV9zbmFwc2hvdFwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZGVsZXRlU25hcHNob3Qoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwiYWRkX2xpZmVjeWNsZV9wb2xpY3lcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGFkZExpZmVjeWNsZVBvbGljeShzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJzZXRfcmV0ZW50aW9uXCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBzZXRSZXRlbnRpb24oc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwic3RvcF9yZHNcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHN0b3BSZHMoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwiZG93bnNpemVfcmRzXCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBkb3duc2l6ZVJkcyhzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJkZWxldGVfY2FjaGVcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGRlbGV0ZUNhY2hlKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBcImRlbGV0ZV9sYlwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZGVsZXRlTG9hZEJhbGFuY2VyKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBcInJpZ2h0c2l6ZV9sYW1iZGFcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJpZ2h0c2l6ZUxhbWJkYShzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJyaWdodHNpemVfaW5zdGFuY2VcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJpZ2h0c2l6ZUluc3RhbmNlKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgLy8gUGhhc2UgMTogUXVpY2std2luIGFjdGlvbnNcbiAgICAgICAgICBjYXNlIFwidXBncmFkZV92b2x1bWVfdHlwZVwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdXBncmFkZVZvbHVtZVR5cGUoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwiZGVsZXRlX2xhbWJkYVwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZGVsZXRlTGFtYmRhKHN1cGFiYXNlLCBwYXJhbXMsIHN0YXJ0VGltZSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBcImRlbGV0ZV9vcnBoYW5lZF9zbmFwc2hvdFwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZGVsZXRlT3JwaGFuZWRTbmFwc2hvdChzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJlbmFibGVfYXNnX3NjYWxpbmdcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGVuYWJsZUFzZ1NjYWxpbmcoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAvLyBQaGFzZSAyOiBRdWljay13aW4gYWN0aW9uc1xuICAgICAgICAgIGNhc2UgXCJkaXNhYmxlX211bHRpX2F6XCI6XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBkaXNhYmxlTXVsdGlBeihzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgXCJkZWxldGVfZW1wdHlfbGJcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGRlbGV0ZUVtcHR5TGIoc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwiYWRkX3ZlcnNpb25fZXhwaXJhdGlvblwiOlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgYWRkVmVyc2lvbkV4cGlyYXRpb24oc3VwYWJhc2UsIHBhcmFtcywgc3RhcnRUaW1lKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIFwib3B0aW1pemVfbGFtYmRhX3RpbWVvdXRcIjpcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IG9wdGltaXplTGFtYmRhVGltZW91dChzdXBhYmFzZSwgcGFyYW1zLCBzdGFydFRpbWUpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIHR5cGU6ICR7cGFyYW1zLmFjdGlvbn1gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9nIHRoZSBhY3Rpb24gdG8gYXVkaXQgbG9nXG4gICAgICAgIGF3YWl0IGxvZ0FjdGlvbihzdXBhYmFzZSwgcGFyYW1zLCByZXN1bHQpXG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRldGVjdGlvbiBjYWNoZSBzbyBuZXh0IGRldGVjdGlvbiBmZXRjaCByZXR1cm5zIGZyZXNoIGRhdGFcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgY2xlYXJEZXRlY3Rpb25DYWNoZSgpXG4gICAgICAgICAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRGV0ZWN0aW9uIGNhY2hlIGNsZWFyZWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBhY3Rpb25gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSDinIUgQWN0aW9uIGNvbXBsZXRlZCBpbiAke2R1cmF0aW9uLnRvRml4ZWQoMCl9bXM6ICR7cmVzdWx0Lm1lc3NhZ2V9YClcblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtFeGVjdXRvcl0g4p2MIEFjdGlvbiBmYWlsZWQgYWZ0ZXIgJHtkdXJhdGlvbi50b0ZpeGVkKDApfW1zOmAsIGVycm9yKVxuXG4gICAgICAgIGNvbnN0IGZhaWxlZFJlc3VsdDogQWN0aW9uUmVzdWx0ID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICAgICAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICAgICAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkFjdGlvbiBmYWlsZWRcIixcbiAgICAgICAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZHVyYXRpb25NczogZHVyYXRpb24sXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgdGhlIGZhaWxlZCBhY3Rpb25cbiAgICAgICAgYXdhaXQgbG9nQWN0aW9uKHN1cGFiYXNlLCBwYXJhbXMsIGZhaWxlZFJlc3VsdCkuY2F0Y2goY29uc29sZS5lcnJvcilcblxuICAgICAgICByZXR1cm4gZmFpbGVkUmVzdWx0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhdWRpdCBsb2cgZW50cmllc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEF1ZGl0TG9nKGxpbWl0ID0gNTApOiBQcm9taXNlPEF1ZGl0TG9nRW50cnlbXT4ge1xuICAgICAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRmV0Y2hpbmcgYXVkaXQgbG9nIChsaW1pdDogJHtsaW1pdH0pYClcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwiYWN0aW9uX2F1ZGl0X2xvZ1wiKVxuICAgICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgICAub3JkZXIoXCJleGVjdXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KGxpbWl0KVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0V4ZWN1dG9yXSDinYwgRmFpbGVkIHRvIGZldGNoIGF1ZGl0IGxvZzpgLCBlcnJvcilcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIEZldGNoZWQgJHtkYXRhPy5sZW5ndGggPz8gMH0gYXVkaXQgZW50cmllcyBpbiAke2R1cmF0aW9uLnRvRml4ZWQoMCl9bXNgKVxuXG4gICAgICByZXR1cm4gZGF0YSA/PyBbXVxuICAgIH0sXG4gIH1cbn1cblxuLyoqXG4gKiBMb2cgYWN0aW9uIHRvIGF1ZGl0IHRhYmxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvZ0FjdGlvbihcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHJlc3VsdDogQWN0aW9uUmVzdWx0XG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gTG9nZ2luZyBhY3Rpb24gdG8gYXVkaXQgbG9nYClcblxuICBjb25zdCBlbnRyeTogT21pdDxBdWRpdExvZ0VudHJ5LCBcImlkXCI+ID0ge1xuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZV90eXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIHJlc291cmNlX2lkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZV9uYW1lOiBwYXJhbXMucmVzb3VyY2VOYW1lLFxuICAgIHNjZW5hcmlvX2lkOiBwYXJhbXMuc2NlbmFyaW9JZCxcbiAgICBkZXRlY3Rpb25faWQ6IHBhcmFtcy5kZXRlY3Rpb25JZCxcbiAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICBtZXNzYWdlOiByZXN1bHQubWVzc2FnZSxcbiAgICBwcmV2aW91c19zdGF0ZTogcmVzdWx0LnByZXZpb3VzU3RhdGUgPz8gbnVsbCxcbiAgICBuZXdfc3RhdGU6IHJlc3VsdC5uZXdTdGF0ZSA/PyBudWxsLFxuICAgIGV4ZWN1dGVkX2F0OiByZXN1bHQuZXhlY3V0ZWRBdCxcbiAgICBkdXJhdGlvbl9tczogTWF0aC5yb3VuZChyZXN1bHQuZHVyYXRpb25NcyksXG4gICAgZXhlY3V0ZWRfYnk6IFwiYXV0by1zYWZlLWFnZW50XCIsXG4gIH1cblxuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwiYWN0aW9uX2F1ZGl0X2xvZ1wiKS5pbnNlcnQoZW50cnkpXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0V4ZWN1dG9yXSDinYwgRmFpbGVkIHRvIGxvZyBhY3Rpb246YCwgZXJyb3IpXG4gICAgLy8gRG9uJ3QgdGhyb3cgLSBhdWRpdCBsb2dnaW5nIGZhaWx1cmUgc2hvdWxkbid0IGZhaWwgdGhlIGFjdGlvblxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJbnN0YW5jZSBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiB0ZXJtaW5hdGVJbnN0YW5jZShcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBUZXJtaW5hdGluZyBpbnN0YW5jZTogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGluc3RhbmNlX2lkXG4gIGxldCB7IGRhdGE6IGluc3RhbmNlLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWluc3RhbmNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiaW5zdGFuY2VzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiaW5zdGFuY2VfaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBpbnN0YW5jZSA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7IHN0YXRlOiBpbnN0YW5jZS5zdGF0ZSB9XG5cbiAgLy8gVXBkYXRlIHRvIHRlcm1pbmF0ZWQgdXNpbmcgdGhlIGluc3RhbmNlJ3MgYWN0dWFsIGlkXG4gIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiaW5zdGFuY2VzXCIpXG4gICAgLnVwZGF0ZSh7IHN0YXRlOiBcInRlcm1pbmF0ZWRcIiwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG4gICAgLmVxKFwiaWRcIiwgaW5zdGFuY2UuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdGVybWluYXRlIGluc3RhbmNlOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBJbnN0YW5jZSAke2luc3RhbmNlLmluc3RhbmNlX2lkIHx8IHBhcmFtcy5yZXNvdXJjZU5hbWV9IHRlcm1pbmF0ZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IHN0YXRlOiBcInRlcm1pbmF0ZWRcIiB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdG9wSW5zdGFuY2UoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gU3RvcHBpbmcgaW5zdGFuY2U6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSBpbnN0YW5jZV9pZFxuICBsZXQgeyBkYXRhOiBpbnN0YW5jZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJpbnN0YW5jZXNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIC8vIEZhbGxiYWNrIHRvIGluc3RhbmNlX2lkIGlmIG5vdCBmb3VuZCBieSBpZFxuICBpZiAoZmV0Y2hFcnJvciB8fCAhaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJpbnN0YW5jZXNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJpbnN0YW5jZV9pZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIGluc3RhbmNlID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhaW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHsgc3RhdGU6IGluc3RhbmNlLnN0YXRlIH1cblxuICAvLyBVcGRhdGUgdG8gc3RvcHBlZCB1c2luZyB0aGUgaW5zdGFuY2UncyBhY3R1YWwgaWRcbiAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJpbnN0YW5jZXNcIilcbiAgICAudXBkYXRlKHsgc3RhdGU6IFwic3RvcHBlZFwiLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbiAgICAuZXEoXCJpZFwiLCBpbnN0YW5jZS5pZClcblxuICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzdG9wIGluc3RhbmNlOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBJbnN0YW5jZSAke2luc3RhbmNlLmluc3RhbmNlX2lkIHx8IHBhcmFtcy5yZXNvdXJjZU5hbWV9IHN0b3BwZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IHN0YXRlOiBcInN0b3BwZWRcIiB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQXV0byBTY2FsaW5nIEdyb3VwIEFjdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmFzeW5jIGZ1bmN0aW9uIHRlcm1pbmF0ZUFzZyhcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBUZXJtaW5hdGluZyBBU0c6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSBhc2dfbmFtZVxuICBsZXQgeyBkYXRhOiBhc2csIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICAvLyBGYWxsYmFjayB0byBhc2dfbmFtZSBpZiBub3QgZm91bmQgYnkgaWRcbiAgaWYgKGZldGNoRXJyb3IgfHwgIWFzZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImFzZ19uYW1lXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgYXNnID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhYXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBU0cgbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIGRlc2lyZWRfY2FwYWNpdHk6IGFzZy5kZXNpcmVkX2NhcGFjaXR5LFxuICAgIG1pbl9zaXplOiBhc2cubWluX3NpemUsXG4gICAgbWF4X3NpemU6IGFzZy5tYXhfc2l6ZSxcbiAgfVxuXG4gIC8vIFNldCBhbGwgY2FwYWNpdGllcyB0byAwIChzaW11bGF0aW5nIHRlcm1pbmF0aW9uKVxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgZGVzaXJlZF9jYXBhY2l0eTogMCxcbiAgICAgIG1pbl9zaXplOiAwLFxuICAgICAgbWF4X3NpemU6IDAsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCBhc2cuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdGVybWluYXRlIEFTRzogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgYWN0aW9uOiBwYXJhbXMuYWN0aW9uLFxuICAgIHJlc291cmNlSWQ6IHBhcmFtcy5yZXNvdXJjZUlkLFxuICAgIHJlc291cmNlVHlwZTogcGFyYW1zLnJlc291cmNlVHlwZSxcbiAgICBtZXNzYWdlOiBgQVNHICR7cGFyYW1zLnJlc291cmNlTmFtZX0gdGVybWluYXRlZCAoY2FwYWNpdHkgc2V0IHRvIDApYCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IGRlc2lyZWRfY2FwYWNpdHk6IDAsIG1pbl9zaXplOiAwLCBtYXhfc2l6ZTogMCB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzY2FsZURvd25Bc2coXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gU2NhbGluZyBkb3duIEFTRzogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGFzZ19uYW1lXG4gIGxldCB7IGRhdGE6IGFzZywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJhdXRvc2NhbGluZ19ncm91cHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFzZ19uYW1lIGlmIG5vdCBmb3VuZCBieSBpZFxuICBpZiAoZmV0Y2hFcnJvciB8fCAhYXNnKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiYXNnX25hbWVcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBhc2cgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFhc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFTRyBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgZGVzaXJlZF9jYXBhY2l0eTogYXNnLmRlc2lyZWRfY2FwYWNpdHksXG4gICAgbWluX3NpemU6IGFzZy5taW5fc2l6ZSxcbiAgfVxuXG4gIC8vIFNjYWxlIGRvd24gYnkgNTAlIG9yIHRvIG1pbiAxXG4gIGNvbnN0IG5ld0Rlc2lyZWQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGFzZy5kZXNpcmVkX2NhcGFjaXR5IC8gMikpXG4gIGNvbnN0IG5ld01pbiA9IE1hdGgubWluKG5ld0Rlc2lyZWQsIGFzZy5taW5fc2l6ZSlcblxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgZGVzaXJlZF9jYXBhY2l0eTogbmV3RGVzaXJlZCxcbiAgICAgIG1pbl9zaXplOiBuZXdNaW4sXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCBhc2cuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2NhbGUgZG93biBBU0c6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYEFTRyAke3BhcmFtcy5yZXNvdXJjZU5hbWV9IHNjYWxlZCBkb3duIGZyb20gJHthc2cuZGVzaXJlZF9jYXBhY2l0eX0gdG8gJHtuZXdEZXNpcmVkfWAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBkZXNpcmVkX2NhcGFjaXR5OiBuZXdEZXNpcmVkLCBtaW5fc2l6ZTogbmV3TWluIH0sXG4gICAgZXhlY3V0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGR1cmF0aW9uTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFbGFzdGljIElQIEFjdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbGVhc2VFaXAoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gUmVsZWFzaW5nIEVJUDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGFsbG9jYXRpb25faWRcbiAgbGV0IHsgZGF0YTogZWlwLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImVsYXN0aWNfaXBzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICAvLyBGYWxsYmFjayB0byBhbGxvY2F0aW9uX2lkIGlmIG5vdCBmb3VuZCBieSBpZFxuICBpZiAoZmV0Y2hFcnJvciB8fCAhZWlwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiZWxhc3RpY19pcHNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJhbGxvY2F0aW9uX2lkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgZWlwID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhZWlwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbGFzdGljIElQIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICBwdWJsaWNfaXA6IGVpcC5wdWJsaWNfaXAsXG4gICAgYXNzb2NpYXRpb25faWQ6IGVpcC5hc3NvY2lhdGlvbl9pZCxcbiAgfVxuXG4gIC8vIERlbGV0ZSB0aGUgRUlQIHJlY29yZCAoc2ltdWxhdGluZyByZWxlYXNlKVxuICBjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImVsYXN0aWNfaXBzXCIpXG4gICAgLmRlbGV0ZSgpXG4gICAgLmVxKFwiaWRcIiwgZWlwLmlkKVxuXG4gIGlmIChkZWxldGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlbGVhc2UgRUlQOiAke2RlbGV0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBFbGFzdGljIElQICR7ZWlwLnB1YmxpY19pcH0gcmVsZWFzZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IHJlbGVhc2VkOiB0cnVlIH0sXG4gICAgZXhlY3V0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGR1cmF0aW9uTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFQlMgVm9sdW1lIEFjdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVZvbHVtZShcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBEZWxldGluZyB2b2x1bWU6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSB2b2x1bWVfaWRcbiAgbGV0IHsgZGF0YTogdm9sdW1lLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInZvbHVtZXNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIC8vIEZhbGxiYWNrIHRvIHZvbHVtZV9pZCBpZiBub3QgZm91bmQgYnkgaWRcbiAgaWYgKGZldGNoRXJyb3IgfHwgIXZvbHVtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInZvbHVtZXNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJ2b2x1bWVfaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICB2b2x1bWUgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICF2b2x1bWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZvbHVtZSBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgc3RhdGU6IHZvbHVtZS5zdGF0ZSxcbiAgICBzaXplX2diOiB2b2x1bWUuc2l6ZV9nYixcbiAgICB2b2x1bWVfdHlwZTogdm9sdW1lLnZvbHVtZV90eXBlLFxuICB9XG5cbiAgLy8gVXBkYXRlIHN0YXRlIHRvIGRlbGV0ZWQgKG9yIGFjdHVhbGx5IGRlbGV0ZSlcbiAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJ2b2x1bWVzXCIpXG4gICAgLnVwZGF0ZSh7IHN0YXRlOiBcImRlbGV0ZWRcIiwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG4gICAgLmVxKFwiaWRcIiwgdm9sdW1lLmlkKVxuXG4gIGlmICh1cGRhdGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSB2b2x1bWU6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYFZvbHVtZSAke3BhcmFtcy5yZXNvdXJjZU5hbWV9ICgke3ZvbHVtZS5zaXplX2difUdCKSBkZWxldGVkIHN1Y2Nlc3NmdWxseWAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBzdGF0ZTogXCJkZWxldGVkXCIgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEVCUyBTbmFwc2hvdCBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVTbmFwc2hvdChcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBEZWxldGluZyBzbmFwc2hvdDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IHNuYXBzaG90X2lkXG4gIGxldCB7IGRhdGE6IHNuYXBzaG90LCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInNuYXBzaG90c1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gc25hcHNob3RfaWQgaWYgbm90IGZvdW5kIGJ5IGlkXG4gIGlmIChmZXRjaEVycm9yIHx8ICFzbmFwc2hvdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInNuYXBzaG90c1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInNuYXBzaG90X2lkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgc25hcHNob3QgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFzbmFwc2hvdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU25hcHNob3Qgbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIHN0YXRlOiBzbmFwc2hvdC5zdGF0ZSxcbiAgICB2b2x1bWVfc2l6ZV9nYjogc25hcHNob3Qudm9sdW1lX3NpemVfZ2IsXG4gICAgc3RhcnRfdGltZTogc25hcHNob3Quc3RhcnRfdGltZSxcbiAgfVxuXG4gIC8vIERlbGV0ZSB0aGUgc25hcHNob3QgcmVjb3JkXG4gIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwic25hcHNob3RzXCIpXG4gICAgLmRlbGV0ZSgpXG4gICAgLmVxKFwiaWRcIiwgc25hcHNob3QuaWQpXG5cbiAgaWYgKGRlbGV0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIHNuYXBzaG90OiAke2RlbGV0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBTbmFwc2hvdCAke3BhcmFtcy5yZXNvdXJjZU5hbWV9IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IGRlbGV0ZWQ6IHRydWUgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFMzIEJ1Y2tldCBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBhZGRMaWZlY3ljbGVQb2xpY3koXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gQWRkaW5nIGxpZmVjeWNsZSBwb2xpY3kgdG8gYnVja2V0OiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG5cbiAgLy8gR2V0IGN1cnJlbnQgc3RhdGUgLSB0cnkgYnkgaWQgZmlyc3QsIHRoZW4gYnkgYnVja2V0X25hbWVcbiAgbGV0IHsgZGF0YTogYnVja2V0LCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInMzX2J1Y2tldHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIC8vIEZhbGxiYWNrIHRvIGJ1Y2tldF9uYW1lIGlmIG5vdCBmb3VuZCBieSBpZFxuICBpZiAoZmV0Y2hFcnJvciB8fCAhYnVja2V0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiczNfYnVja2V0c1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImJ1Y2tldF9uYW1lXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgYnVja2V0ID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhYnVja2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTMyBidWNrZXQgbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIGxpZmVjeWNsZV9ydWxlczogYnVja2V0LmxpZmVjeWNsZV9ydWxlcyxcbiAgfVxuXG4gIC8vIEFkZCBpbnRlbGxpZ2VudCB0aWVyaW5nIGxpZmVjeWNsZSBydWxlXG4gIGNvbnN0IG5ld0xpZmVjeWNsZVJ1bGVzID0gW1xuICAgIC4uLihidWNrZXQubGlmZWN5Y2xlX3J1bGVzIHx8IFtdKSxcbiAgICB7XG4gICAgICBpZDogXCJpbnRlbGxpZ2VudC10aWVyaW5nXCIsXG4gICAgICBzdGF0dXM6IFwiRW5hYmxlZFwiLFxuICAgICAgdHJhbnNpdGlvbnM6IFtcbiAgICAgICAgeyBkYXlzOiAzMCwgc3RvcmFnZV9jbGFzczogXCJJTlRFTExJR0VOVF9USUVSSU5HXCIgfSxcbiAgICAgICAgeyBkYXlzOiA5MCwgc3RvcmFnZV9jbGFzczogXCJHTEFDSUVSXCIgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgXVxuXG4gIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiczNfYnVja2V0c1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgbGlmZWN5Y2xlX3J1bGVzOiBuZXdMaWZlY3ljbGVSdWxlcyxcbiAgICB9KVxuICAgIC5lcShcImlkXCIsIGJ1Y2tldC5pZClcblxuICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgbGlmZWN5Y2xlIHBvbGljeTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgYWN0aW9uOiBwYXJhbXMuYWN0aW9uLFxuICAgIHJlc291cmNlSWQ6IHBhcmFtcy5yZXNvdXJjZUlkLFxuICAgIHJlc291cmNlVHlwZTogcGFyYW1zLnJlc291cmNlVHlwZSxcbiAgICBtZXNzYWdlOiBgTGlmZWN5Y2xlIHBvbGljeSBhZGRlZCB0byBidWNrZXQgJHtwYXJhbXMucmVzb3VyY2VOYW1lfWAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBsaWZlY3ljbGVfcnVsZXM6IG5ld0xpZmVjeWNsZVJ1bGVzIH0sXG4gICAgZXhlY3V0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGR1cmF0aW9uTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDbG91ZFdhdGNoIExvZyBHcm91cCBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBzZXRSZXRlbnRpb24oXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gU2V0dGluZyByZXRlbnRpb24gb24gbG9nIGdyb3VwOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG5cbiAgLy8gR2V0IGN1cnJlbnQgc3RhdGUgLSB0cnkgYnkgaWQgZmlyc3QsIHRoZW4gYnkgbG9nX2dyb3VwX25hbWVcbiAgbGV0IHsgZGF0YTogbG9nR3JvdXAsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwibG9nX2dyb3Vwc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gbG9nX2dyb3VwX25hbWUgaWYgbm90IGZvdW5kIGJ5IGlkXG4gIGlmIChmZXRjaEVycm9yIHx8ICFsb2dHcm91cCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImxvZ19ncm91cHNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJsb2dfZ3JvdXBfbmFtZVwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIGxvZ0dyb3VwID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhbG9nR3JvdXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExvZyBncm91cCBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgcmV0ZW50aW9uX2luX2RheXM6IGxvZ0dyb3VwLnJldGVudGlvbl9pbl9kYXlzLFxuICB9XG5cbiAgLy8gU2V0IDMwLWRheSByZXRlbnRpb25cbiAgY29uc3QgbmV3UmV0ZW50aW9uID0gMzBcblxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImxvZ19ncm91cHNcIilcbiAgICAudXBkYXRlKHtcbiAgICAgIHJldGVudGlvbl9pbl9kYXlzOiBuZXdSZXRlbnRpb24sXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCBsb2dHcm91cC5pZClcblxuICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXQgcmV0ZW50aW9uOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBSZXRlbnRpb24gc2V0IHRvICR7bmV3UmV0ZW50aW9ufSBkYXlzIGZvciAke2xvZ0dyb3VwLmxvZ19ncm91cF9uYW1lIHx8IHBhcmFtcy5yZXNvdXJjZU5hbWV9YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IHJldGVudGlvbl9pbl9kYXlzOiBuZXdSZXRlbnRpb24gfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFJEUyBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBzdG9wUmRzKFxuICBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQsXG4gIHBhcmFtczogRXhlY3V0ZUFjdGlvblBhcmFtcyxcbiAgc3RhcnRUaW1lOiBudW1iZXJcbik6IFByb21pc2U8QWN0aW9uUmVzdWx0PiB7XG4gIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIFN0b3BwaW5nIFJEUyBpbnN0YW5jZTogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGRiX2luc3RhbmNlX2lkXG4gIGxldCB7IGRhdGE6IHJkcywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICAvLyBGYWxsYmFjayB0byBkYl9pbnN0YW5jZV9pZCBpZiBub3QgZm91bmQgYnkgaWRcbiAgaWYgKGZldGNoRXJyb3IgfHwgIXJkcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInJkc19pbnN0YW5jZXNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJkYl9pbnN0YW5jZV9pZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIHJkcyA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIXJkcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgUkRTIGluc3RhbmNlIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICBzdGF0dXM6IHJkcy5zdGF0dXMsXG4gIH1cblxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInJkc19pbnN0YW5jZXNcIilcbiAgICAudXBkYXRlKHtcbiAgICAgIHN0YXR1czogXCJzdG9wcGVkXCIsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCByZHMuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc3RvcCBSRFMgaW5zdGFuY2U6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYFJEUyBpbnN0YW5jZSAke3BhcmFtcy5yZXNvdXJjZU5hbWV9IHN0b3BwZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IHN0YXR1czogXCJzdG9wcGVkXCIgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bnNpemVSZHMoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRG93bnNpemluZyBSRFMgaW5zdGFuY2U6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSBkYl9pbnN0YW5jZV9pZFxuICBsZXQgeyBkYXRhOiByZHMsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmRzX2luc3RhbmNlc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gZGJfaW5zdGFuY2VfaWQgaWYgbm90IGZvdW5kIGJ5IGlkXG4gIGlmIChmZXRjaEVycm9yIHx8ICFyZHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiZGJfaW5zdGFuY2VfaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICByZHMgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFyZHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJEUyBpbnN0YW5jZSBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgaW5zdGFuY2VfY2xhc3M6IHJkcy5pbnN0YW5jZV9jbGFzcyxcbiAgfVxuXG4gIC8vIERvd25zaXplIHRvIHNtYWxsZXIgaW5zdGFuY2UgY2xhc3NcbiAgY29uc3QgaW5zdGFuY2VTaXplcyA9IFtcImRiLnQzLm1pY3JvXCIsIFwiZGIudDMuc21hbGxcIiwgXCJkYi50My5tZWRpdW1cIiwgXCJkYi50My5sYXJnZVwiLCBcImRiLnQzLnhsYXJnZVwiXVxuICBjb25zdCBjdXJyZW50SW5kZXggPSBpbnN0YW5jZVNpemVzLmluZGV4T2YocmRzLmluc3RhbmNlX2NsYXNzKVxuICBjb25zdCBuZXdDbGFzcyA9IGN1cnJlbnRJbmRleCA+IDAgPyBpbnN0YW5jZVNpemVzW2N1cnJlbnRJbmRleCAtIDFdIDogcmRzLmluc3RhbmNlX2NsYXNzXG5cbiAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpXG4gICAgLnVwZGF0ZSh7XG4gICAgICBpbnN0YW5jZV9jbGFzczogbmV3Q2xhc3MsXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCByZHMuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZG93bnNpemUgUkRTIGluc3RhbmNlOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBSRFMgaW5zdGFuY2UgJHtwYXJhbXMucmVzb3VyY2VOYW1lfSBkb3duc2l6ZWQgZnJvbSAke3Jkcy5pbnN0YW5jZV9jbGFzc30gdG8gJHtuZXdDbGFzc31gLFxuICAgIHByZXZpb3VzU3RhdGUsXG4gICAgbmV3U3RhdGU6IHsgaW5zdGFuY2VfY2xhc3M6IG5ld0NsYXNzIH0sXG4gICAgZXhlY3V0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGR1cmF0aW9uTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFbGFzdGlDYWNoZSBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVDYWNoZShcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBEZWxldGluZyBjYWNoZSBjbHVzdGVyOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG5cbiAgLy8gR2V0IGN1cnJlbnQgc3RhdGUgLSB0cnkgYnkgaWQgZmlyc3QsIHRoZW4gYnkgY2x1c3Rlcl9pZFxuICBsZXQgeyBkYXRhOiBjYWNoZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJjYWNoZV9jbHVzdGVyc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gY2x1c3Rlcl9pZCBpZiBub3QgZm91bmQgYnkgaWRcbiAgaWYgKGZldGNoRXJyb3IgfHwgIWNhY2hlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiY2FjaGVfY2x1c3RlcnNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJjbHVzdGVyX2lkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgY2FjaGUgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFjYWNoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FjaGUgY2x1c3RlciBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgY2x1c3Rlcl9pZDogY2FjaGUuY2x1c3Rlcl9pZCxcbiAgICBub2RlX3R5cGU6IGNhY2hlLm5vZGVfdHlwZSxcbiAgICBudW1fbm9kZXM6IGNhY2hlLm51bV9ub2RlcyxcbiAgfVxuXG4gIC8vIERlbGV0ZSB0aGUgY2FjaGUgY2x1c3RlciByZWNvcmRcbiAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJjYWNoZV9jbHVzdGVyc1wiKVxuICAgIC5kZWxldGUoKVxuICAgIC5lcShcImlkXCIsIGNhY2hlLmlkKVxuXG4gIGlmIChkZWxldGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBjYWNoZSBjbHVzdGVyOiAke2RlbGV0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBDYWNoZSBjbHVzdGVyICR7cGFyYW1zLnJlc291cmNlTmFtZX0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgLFxuICAgIHByZXZpb3VzU3RhdGUsXG4gICAgbmV3U3RhdGU6IHsgZGVsZXRlZDogdHJ1ZSB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTG9hZCBCYWxhbmNlciBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBkZWxldGVMb2FkQmFsYW5jZXIoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRGVsZXRpbmcgbG9hZCBiYWxhbmNlcjogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGxiX2FyblxuICBsZXQgeyBkYXRhOiBsYiwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJsb2FkX2JhbGFuY2Vyc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gbGJfYXJuIGlmIG5vdCBmb3VuZCBieSBpZFxuICBpZiAoZmV0Y2hFcnJvciB8fCAhbGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJsb2FkX2JhbGFuY2Vyc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImxiX2FyblwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIGxiID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhbGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExvYWQgYmFsYW5jZXIgbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIHN0YXRlOiBsYi5zdGF0ZSxcbiAgICB0eXBlOiBsYi50eXBlLFxuICB9XG5cbiAgLy8gRGVsZXRlIHRoZSBsb2FkIGJhbGFuY2VyIHJlY29yZFxuICBjb25zdCB7IGVycm9yOiBkZWxldGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImxvYWRfYmFsYW5jZXJzXCIpXG4gICAgLmRlbGV0ZSgpXG4gICAgLmVxKFwiaWRcIiwgbGIuaWQpXG5cbiAgaWYgKGRlbGV0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlIGxvYWQgYmFsYW5jZXI6ICR7ZGVsZXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYExvYWQgYmFsYW5jZXIgJHtwYXJhbXMucmVzb3VyY2VOYW1lfSBkZWxldGVkIHN1Y2Nlc3NmdWxseWAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBkZWxldGVkOiB0cnVlIH0sXG4gICAgZXhlY3V0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGR1cmF0aW9uTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMYW1iZGEgQWN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYXN5bmMgZnVuY3Rpb24gcmlnaHRzaXplTGFtYmRhKFxuICBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQsXG4gIHBhcmFtczogRXhlY3V0ZUFjdGlvblBhcmFtcyxcbiAgc3RhcnRUaW1lOiBudW1iZXJcbik6IFByb21pc2U8QWN0aW9uUmVzdWx0PiB7XG4gIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIFJpZ2h0c2l6aW5nIExhbWJkYSBmdW5jdGlvbjogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGZ1bmN0aW9uX25hbWVcbiAgbGV0IHsgZGF0YTogbGFtYmRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImxhbWJkYV9mdW5jdGlvbnNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIC8vIEZhbGxiYWNrIHRvIGZ1bmN0aW9uX25hbWUgaWYgbm90IGZvdW5kIGJ5IGlkXG4gIGlmIChmZXRjaEVycm9yIHx8ICFsYW1iZGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJsYW1iZGFfZnVuY3Rpb25zXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiZnVuY3Rpb25fbmFtZVwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIGxhbWJkYSA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWxhbWJkYSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGFtYmRhIGZ1bmN0aW9uIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICBtZW1vcnlfbWI6IGxhbWJkYS5tZW1vcnlfbWIsXG4gIH1cblxuICAvLyBSaWdodHNpemUgdG8gNTAlIG9mIGN1cnJlbnQgb3IgbWluaW11bSAxMjhNQlxuICBjb25zdCBuZXdNZW1vcnkgPSBNYXRoLm1heCgxMjgsIE1hdGguZmxvb3IobGFtYmRhLm1lbW9yeV9tYiAvIDIpKVxuXG4gIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwibGFtYmRhX2Z1bmN0aW9uc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgbWVtb3J5X21iOiBuZXdNZW1vcnksXG4gICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSlcbiAgICAuZXEoXCJpZFwiLCBsYW1iZGEuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmlnaHRzaXplIExhbWJkYTogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgYWN0aW9uOiBwYXJhbXMuYWN0aW9uLFxuICAgIHJlc291cmNlSWQ6IHBhcmFtcy5yZXNvdXJjZUlkLFxuICAgIHJlc291cmNlVHlwZTogcGFyYW1zLnJlc291cmNlVHlwZSxcbiAgICBtZXNzYWdlOiBgTGFtYmRhICR7bGFtYmRhLmZ1bmN0aW9uX25hbWUgfHwgcGFyYW1zLnJlc291cmNlTmFtZX0gcmlnaHRzaXplZCBmcm9tICR7bGFtYmRhLm1lbW9yeV9tYn1NQiB0byAke25ld01lbW9yeX1NQmAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBtZW1vcnlfbWI6IG5ld01lbW9yeSB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRUMyIEluc3RhbmNlIFJpZ2h0c2l6aW5nIEFjdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmFzeW5jIGZ1bmN0aW9uIHJpZ2h0c2l6ZUluc3RhbmNlKFxuICBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQsXG4gIHBhcmFtczogRXhlY3V0ZUFjdGlvblBhcmFtcyxcbiAgc3RhcnRUaW1lOiBudW1iZXJcbik6IFByb21pc2U8QWN0aW9uUmVzdWx0PiB7XG4gIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIFJpZ2h0c2l6aW5nIEVDMiBpbnN0YW5jZTogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGluc3RhbmNlX2lkXG4gIGxldCB7IGRhdGE6IGluc3RhbmNlLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgLy8gRmFsbGJhY2sgdG8gaW5zdGFuY2VfaWQgaWYgbm90IGZvdW5kIGJ5IGlkXG4gIGlmIChmZXRjaEVycm9yIHx8ICFpbnN0YW5jZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImluc3RhbmNlX2lkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgaW5zdGFuY2UgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFpbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIGluc3RhbmNlX3R5cGU6IGluc3RhbmNlLmluc3RhbmNlX3R5cGUsXG4gIH1cblxuICAvLyBHZXQgdGhlIHJlY29tbWVuZGVkIGluc3RhbmNlIHR5cGUgZnJvbSBkZXRlY3Rpb24gZGV0YWlsc1xuICBjb25zdCByZWNvbW1lbmRlZFR5cGUgPSBwYXJhbXMuZGV0YWlscz8ucmVjb21tZW5kZWRJbnN0YW5jZVR5cGUgYXMgc3RyaW5nXG5cbiAgaWYgKCFyZWNvbW1lbmRlZFR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlY29tbWVuZGVkIGluc3RhbmNlIHR5cGUgcHJvdmlkZWQgZm9yIHJpZ2h0c2l6aW5nYClcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0byB0aGUgcmVjb21tZW5kZWQgaW5zdGFuY2UgdHlwZVxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImluc3RhbmNlc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgaW5zdGFuY2VfdHlwZTogcmVjb21tZW5kZWRUeXBlLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gICAgLmVxKFwiaWRcIiwgaW5zdGFuY2UuaWQpXG5cbiAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmlnaHRzaXplIGluc3RhbmNlOiAke3VwZGF0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBJbnN0YW5jZSAke2luc3RhbmNlLmluc3RhbmNlX2lkIHx8IHBhcmFtcy5yZXNvdXJjZU5hbWV9IHJpZ2h0c2l6ZWQgZnJvbSAke2luc3RhbmNlLmluc3RhbmNlX3R5cGV9IHRvICR7cmVjb21tZW5kZWRUeXBlfWAsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyBpbnN0YW5jZV90eXBlOiByZWNvbW1lbmRlZFR5cGUgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFFVSUNLLVdJTiBPUFRJTUlaQVRJT05TIC0gUGhhc2UgMSBBY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFVwZ3JhZGUgRUJTIHZvbHVtZSBmcm9tIGdwMiB0byBncDNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBncmFkZVZvbHVtZVR5cGUoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gVXBncmFkaW5nIHZvbHVtZSB0eXBlOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG5cbiAgLy8gR2V0IGN1cnJlbnQgc3RhdGUgLSB0cnkgYnkgaWQgZmlyc3QsIHRoZW4gYnkgdm9sdW1lX2lkXG4gIGxldCB7IGRhdGE6IHZvbHVtZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJ2b2x1bWVzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhdm9sdW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwidm9sdW1lc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcInZvbHVtZV9pZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIHZvbHVtZSA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIXZvbHVtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVm9sdW1lIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICB2b2x1bWVfdHlwZTogdm9sdW1lLnZvbHVtZV90eXBlLFxuICB9XG5cbiAgLy8gVXBkYXRlIHRvIGdwM1xuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInZvbHVtZXNcIilcbiAgICAudXBkYXRlKHtcbiAgICAgIHZvbHVtZV90eXBlOiBcImdwM1wiLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gICAgLmVxKFwiaWRcIiwgdm9sdW1lLmlkKVxuXG4gIGlmICh1cGRhdGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZ3JhZGUgdm9sdW1lIHR5cGU6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYFZvbHVtZSAke3ZvbHVtZS52b2x1bWVfaWR9IHVwZ3JhZGVkIGZyb20gZ3AyIHRvIGdwM2AsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyB2b2x1bWVfdHlwZTogXCJncDNcIiB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSB1bnVzZWQgTGFtYmRhIGZ1bmN0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUxhbWJkYShcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBEZWxldGluZyBMYW1iZGEgZnVuY3Rpb246ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSBmdW5jdGlvbl9uYW1lXG4gIGxldCB7IGRhdGE6IGxhbWJkYSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJsYW1iZGFfZnVuY3Rpb25zXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhbGFtYmRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwibGFtYmRhX2Z1bmN0aW9uc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImZ1bmN0aW9uX25hbWVcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBsYW1iZGEgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFsYW1iZGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExhbWJkYSBmdW5jdGlvbiBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgbmFtZTogbGFtYmRhLm5hbWUsXG4gICAgbWVtb3J5X21iOiBsYW1iZGEubWVtb3J5X21iLFxuICAgIHJ1bnRpbWU6IGxhbWJkYS5ydW50aW1lLFxuICB9XG5cbiAgLy8gRGVsZXRlIHRoZSBMYW1iZGEgZnVuY3Rpb24gcmVjb3JkXG4gIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwibGFtYmRhX2Z1bmN0aW9uc1wiKVxuICAgIC5kZWxldGUoKVxuICAgIC5lcShcImlkXCIsIGxhbWJkYS5pZClcblxuICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgTGFtYmRhIGZ1bmN0aW9uOiAke2RlbGV0ZUVycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBhY3Rpb246IHBhcmFtcy5hY3Rpb24sXG4gICAgcmVzb3VyY2VJZDogcGFyYW1zLnJlc291cmNlSWQsXG4gICAgcmVzb3VyY2VUeXBlOiBwYXJhbXMucmVzb3VyY2VUeXBlLFxuICAgIG1lc3NhZ2U6IGBMYW1iZGEgZnVuY3Rpb24gJHtsYW1iZGEubmFtZX0gZGVsZXRlZCBzdWNjZXNzZnVsbHlgLFxuICAgIHByZXZpb3VzU3RhdGUsXG4gICAgbmV3U3RhdGU6IHsgZGVsZXRlZDogdHJ1ZSB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBvcnBoYW5lZCBFQlMgc25hcHNob3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlT3JwaGFuZWRTbmFwc2hvdChcbiAgc3VwYWJhc2U6IFN1cGFiYXNlQ2xpZW50LFxuICBwYXJhbXM6IEV4ZWN1dGVBY3Rpb25QYXJhbXMsXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4pOiBQcm9taXNlPEFjdGlvblJlc3VsdD4ge1xuICBjb25zb2xlLmxvZyhgW0V4ZWN1dG9yXSBEZWxldGluZyBvcnBoYW5lZCBzbmFwc2hvdDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IHNuYXBzaG90X2lkXG4gIGxldCB7IGRhdGE6IHNuYXBzaG90LCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInNuYXBzaG90c1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIXNuYXBzaG90KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwic25hcHNob3RzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwic25hcHNob3RfaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBzbmFwc2hvdCA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIXNuYXBzaG90KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwc2hvdCBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgc25hcHNob3RfaWQ6IHNuYXBzaG90LnNuYXBzaG90X2lkLFxuICAgIHNvdXJjZV92b2x1bWVfaWQ6IHNuYXBzaG90LnNvdXJjZV92b2x1bWVfaWQsXG4gICAgc2l6ZV9naWI6IHNuYXBzaG90LnNpemVfZ2liLFxuICB9XG5cbiAgLy8gRGVsZXRlIHRoZSBzbmFwc2hvdCByZWNvcmRcbiAgY29uc3QgeyBlcnJvcjogZGVsZXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJzbmFwc2hvdHNcIilcbiAgICAuZGVsZXRlKClcbiAgICAuZXEoXCJpZFwiLCBzbmFwc2hvdC5pZClcblxuICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgb3JwaGFuZWQgc25hcHNob3Q6ICR7ZGVsZXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYE9ycGhhbmVkIHNuYXBzaG90ICR7c25hcHNob3Quc25hcHNob3RfaWR9IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IGRlbGV0ZWQ6IHRydWUgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgZHluYW1pYyBzY2FsaW5nIGZvciBzdGF0aWMgQVNHXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVuYWJsZUFzZ1NjYWxpbmcoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRW5hYmxpbmcgQVNHIHNjYWxpbmc6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcblxuICAvLyBHZXQgY3VycmVudCBzdGF0ZSAtIHRyeSBieSBpZCBmaXJzdCwgdGhlbiBieSBhc2dfbmFtZVxuICBsZXQgeyBkYXRhOiBhc2csIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhYXNnKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiYXNnX25hbWVcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBhc2cgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFhc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFTRyBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgbWluX3NpemU6IGFzZy5taW5fc2l6ZSxcbiAgICBtYXhfc2l6ZTogYXNnLm1heF9zaXplLFxuICAgIGRlc2lyZWRfY2FwYWNpdHk6IGFzZy5kZXNpcmVkX2NhcGFjaXR5LFxuICB9XG5cbiAgLy8gRW5hYmxlIHNjYWxpbmc6IHNldCBtaW4gdG8gMSwgbWF4IHRvIDJ4IGN1cnJlbnRcbiAgY29uc3QgbmV3TWluU2l6ZSA9IDFcbiAgY29uc3QgbmV3TWF4U2l6ZSA9IE1hdGgubWF4KGFzZy5kZXNpcmVkX2NhcGFjaXR5ICogMiwgNClcblxuICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImF1dG9zY2FsaW5nX2dyb3Vwc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgbWluX3NpemU6IG5ld01pblNpemUsXG4gICAgICBtYXhfc2l6ZTogbmV3TWF4U2l6ZSxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KVxuICAgIC5lcShcImlkXCIsIGFzZy5pZClcblxuICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmFibGUgQVNHIHNjYWxpbmc6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYEFTRyAke3BhcmFtcy5yZXNvdXJjZU5hbWV9IHNjYWxpbmcgZW5hYmxlZCAobWluOiAke25ld01pblNpemV9LCBtYXg6ICR7bmV3TWF4U2l6ZX0pYCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IG1pbl9zaXplOiBuZXdNaW5TaXplLCBtYXhfc2l6ZTogbmV3TWF4U2l6ZSB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUVVJQ0stV0lOIE9QVElNSVpBVElPTlMgLSBQaGFzZSAyIEFjdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRGlzYWJsZSBNdWx0aS1BWiBmb3Igbm9uLXByb2R1Y3Rpb24gUkRTXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVNdWx0aUF6KFxuICBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQsXG4gIHBhcmFtczogRXhlY3V0ZUFjdGlvblBhcmFtcyxcbiAgc3RhcnRUaW1lOiBudW1iZXJcbik6IFByb21pc2U8QWN0aW9uUmVzdWx0PiB7XG4gIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIERpc2FibGluZyBNdWx0aS1BWjogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGRiX2luc3RhbmNlX2lkXG4gIGxldCB7IGRhdGE6IHJkcywgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJyZHNfaW5zdGFuY2VzXCIpXG4gICAgLnNlbGVjdChcIipcIilcbiAgICAuZXEoXCJpZFwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAuc2luZ2xlKClcblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhcmRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwicmRzX2luc3RhbmNlc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImRiX2luc3RhbmNlX2lkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgICAgLnNpbmdsZSgpXG4gICAgcmRzID0gcmVzdWx0LmRhdGFcbiAgICBmZXRjaEVycm9yID0gcmVzdWx0LmVycm9yXG4gIH1cblxuICBpZiAoZmV0Y2hFcnJvciB8fCAhcmRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSRFMgaW5zdGFuY2Ugbm90IGZvdW5kOiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG4gIH1cblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0ge1xuICAgIG11bHRpX2F6OiByZHMubXVsdGlfYXosXG4gIH1cblxuICAvLyBEaXNhYmxlIE11bHRpLUFaXG4gIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwicmRzX2luc3RhbmNlc1wiKVxuICAgIC51cGRhdGUoe1xuICAgICAgbXVsdGlfYXo6IGZhbHNlLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pXG4gICAgLmVxKFwiaWRcIiwgcmRzLmlkKVxuXG4gIGlmICh1cGRhdGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRpc2FibGUgTXVsdGktQVo6ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYE11bHRpLUFaIGRpc2FibGVkIGZvciBSRFMgJHtyZHMuZGJfaW5zdGFuY2VfaWR9YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IG11bHRpX2F6OiBmYWxzZSB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZSBlbXB0eSBsb2FkIGJhbGFuY2VyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUVtcHR5TGIoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gRGVsZXRpbmcgZW1wdHkgbG9hZCBiYWxhbmNlcjogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGxiX2FyblxuICBsZXQgeyBkYXRhOiBsYiwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJsb2FkX2JhbGFuY2Vyc1wiKVxuICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgLmVxKFwiaWRcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgLnNpbmdsZSgpXG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWxiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwibG9hZF9iYWxhbmNlcnNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJsYl9hcm5cIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBsYiA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWxiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMb2FkIGJhbGFuY2VyIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICBuYW1lOiBsYi5uYW1lLFxuICAgIHR5cGU6IGxiLnR5cGUsXG4gICAgdGFyZ2V0X2NvdW50OiBsYi50YXJnZXRfY291bnQsXG4gIH1cblxuICAvLyBEZWxldGUgdGhlIGxvYWQgYmFsYW5jZXIgcmVjb3JkXG4gIGNvbnN0IHsgZXJyb3I6IGRlbGV0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKFwibG9hZF9iYWxhbmNlcnNcIilcbiAgICAuZGVsZXRlKClcbiAgICAuZXEoXCJpZFwiLCBsYi5pZClcblxuICBpZiAoZGVsZXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgZW1wdHkgbG9hZCBiYWxhbmNlcjogJHtkZWxldGVFcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgYWN0aW9uOiBwYXJhbXMuYWN0aW9uLFxuICAgIHJlc291cmNlSWQ6IHBhcmFtcy5yZXNvdXJjZUlkLFxuICAgIHJlc291cmNlVHlwZTogcGFyYW1zLnJlc291cmNlVHlwZSxcbiAgICBtZXNzYWdlOiBgRW1wdHkgbG9hZCBiYWxhbmNlciAke2xiLm5hbWV9IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IGRlbGV0ZWQ6IHRydWUgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbm9uY3VycmVudCB2ZXJzaW9uIGV4cGlyYXRpb24gdG8gUzMgYnVja2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFkZFZlcnNpb25FeHBpcmF0aW9uKFxuICBzdXBhYmFzZTogU3VwYWJhc2VDbGllbnQsXG4gIHBhcmFtczogRXhlY3V0ZUFjdGlvblBhcmFtcyxcbiAgc3RhcnRUaW1lOiBudW1iZXJcbik6IFByb21pc2U8QWN0aW9uUmVzdWx0PiB7XG4gIGNvbnNvbGUubG9nKGBbRXhlY3V0b3JdIEFkZGluZyB2ZXJzaW9uIGV4cGlyYXRpb24gdG8gYnVja2V0OiAke3BhcmFtcy5yZXNvdXJjZUlkfWApXG5cbiAgLy8gR2V0IGN1cnJlbnQgc3RhdGUgLSB0cnkgYnkgaWQgZmlyc3QsIHRoZW4gYnkgYnVja2V0X25hbWVcbiAgbGV0IHsgZGF0YTogYnVja2V0LCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcInMzX2J1Y2tldHNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFidWNrZXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJzM19idWNrZXRzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiYnVja2V0X25hbWVcIiwgcGFyYW1zLnJlc291cmNlSWQpXG4gICAgICAuc2luZ2xlKClcbiAgICBidWNrZXQgPSByZXN1bHQuZGF0YVxuICAgIGZldGNoRXJyb3IgPSByZXN1bHQuZXJyb3JcbiAgfVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFidWNrZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFMzIGJ1Y2tldCBub3QgZm91bmQ6ICR7cGFyYW1zLnJlc291cmNlSWR9YClcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB7XG4gICAgbGlmZWN5Y2xlX3J1bGVzOiBidWNrZXQubGlmZWN5Y2xlX3J1bGVzLFxuICB9XG5cbiAgLy8gQWRkIG5vbmN1cnJlbnQgdmVyc2lvbiBleHBpcmF0aW9uIHJ1bGVcbiAgY29uc3QgZXhpc3RpbmdSdWxlcyA9IChidWNrZXQubGlmZWN5Y2xlX3J1bGVzIGFzIHVua25vd25bXSkgfHwgW11cbiAgY29uc3QgbmV3UnVsZSA9IHtcbiAgICBpZDogXCJleHBpcmUtbm9uY3VycmVudC12ZXJzaW9uc1wiLFxuICAgIHN0YXR1czogXCJFbmFibGVkXCIsXG4gICAgbm9uY3VycmVudF92ZXJzaW9uX2V4cGlyYXRpb246IHsgZGF5czogMzAgfSxcbiAgfVxuXG4gIGNvbnN0IG5ld0xpZmVjeWNsZVJ1bGVzID0gWy4uLmV4aXN0aW5nUnVsZXMsIG5ld1J1bGVdXG5cbiAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJzM19idWNrZXRzXCIpXG4gICAgLnVwZGF0ZSh7XG4gICAgICBsaWZlY3ljbGVfcnVsZXM6IG5ld0xpZmVjeWNsZVJ1bGVzLFxuICAgIH0pXG4gICAgLmVxKFwiaWRcIiwgYnVja2V0LmlkKVxuXG4gIGlmICh1cGRhdGVFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFkZCB2ZXJzaW9uIGV4cGlyYXRpb246ICR7dXBkYXRlRXJyb3IubWVzc2FnZX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIGFjdGlvbjogcGFyYW1zLmFjdGlvbixcbiAgICByZXNvdXJjZUlkOiBwYXJhbXMucmVzb3VyY2VJZCxcbiAgICByZXNvdXJjZVR5cGU6IHBhcmFtcy5yZXNvdXJjZVR5cGUsXG4gICAgbWVzc2FnZTogYFZlcnNpb24gZXhwaXJhdGlvbiAoMzAgZGF5cykgYWRkZWQgdG8gYnVja2V0ICR7YnVja2V0Lm5hbWV9YCxcbiAgICBwcmV2aW91c1N0YXRlLFxuICAgIG5ld1N0YXRlOiB7IGxpZmVjeWNsZV9ydWxlczogbmV3TGlmZWN5Y2xlUnVsZXMgfSxcbiAgICBleGVjdXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZHVyYXRpb25NczogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUsXG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpbWl6ZSBMYW1iZGEgZnVuY3Rpb24gdGltZW91dFxuICovXG5hc3luYyBmdW5jdGlvbiBvcHRpbWl6ZUxhbWJkYVRpbWVvdXQoXG4gIHN1cGFiYXNlOiBTdXBhYmFzZUNsaWVudCxcbiAgcGFyYW1zOiBFeGVjdXRlQWN0aW9uUGFyYW1zLFxuICBzdGFydFRpbWU6IG51bWJlclxuKTogUHJvbWlzZTxBY3Rpb25SZXN1bHQ+IHtcbiAgY29uc29sZS5sb2coYFtFeGVjdXRvcl0gT3B0aW1pemluZyBMYW1iZGEgdGltZW91dDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuXG4gIC8vIEdldCBjdXJyZW50IHN0YXRlIC0gdHJ5IGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IGZ1bmN0aW9uX25hbWVcbiAgbGV0IHsgZGF0YTogbGFtYmRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbShcImxhbWJkYV9mdW5jdGlvbnNcIilcbiAgICAuc2VsZWN0KFwiKlwiKVxuICAgIC5lcShcImlkXCIsIHBhcmFtcy5yZXNvdXJjZUlkKVxuICAgIC5zaW5nbGUoKVxuXG4gIGlmIChmZXRjaEVycm9yIHx8ICFsYW1iZGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oXCJsYW1iZGFfZnVuY3Rpb25zXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiZnVuY3Rpb25fbmFtZVwiLCBwYXJhbXMucmVzb3VyY2VJZClcbiAgICAgIC5zaW5nbGUoKVxuICAgIGxhbWJkYSA9IHJlc3VsdC5kYXRhXG4gICAgZmV0Y2hFcnJvciA9IHJlc3VsdC5lcnJvclxuICB9XG5cbiAgaWYgKGZldGNoRXJyb3IgfHwgIWxhbWJkYSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGFtYmRhIGZ1bmN0aW9uIG5vdCBmb3VuZDogJHtwYXJhbXMucmVzb3VyY2VJZH1gKVxuICB9XG5cbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHtcbiAgICB0aW1lb3V0X3NlY29uZHM6IGxhbWJkYS50aW1lb3V0X3NlY29uZHMsXG4gIH1cblxuICAvLyBHZXQgcmVjb21tZW5kZWQgdGltZW91dCBmcm9tIGRldGVjdGlvbiBkZXRhaWxzXG4gIGNvbnN0IHJlY29tbWVuZGVkVGltZW91dCA9IHBhcmFtcy5kZXRhaWxzPy5yZWNvbW1lbmRlZFRpbWVvdXQgYXMgbnVtYmVyXG5cbiAgaWYgKCFyZWNvbW1lbmRlZFRpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlY29tbWVuZGVkIHRpbWVvdXQgcHJvdmlkZWQgZm9yIG9wdGltaXphdGlvbmApXG4gIH1cblxuICAvLyBVcGRhdGUgdG8gdGhlIHJlY29tbWVuZGVkIHRpbWVvdXRcbiAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oXCJsYW1iZGFfZnVuY3Rpb25zXCIpXG4gICAgLnVwZGF0ZSh7XG4gICAgICB0aW1lb3V0X3NlY29uZHM6IHJlY29tbWVuZGVkVGltZW91dCxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KVxuICAgIC5lcShcImlkXCIsIGxhbWJkYS5pZClcblxuICBpZiAodXBkYXRlRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBvcHRpbWl6ZSBMYW1iZGEgdGltZW91dDogJHt1cGRhdGVFcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgYWN0aW9uOiBwYXJhbXMuYWN0aW9uLFxuICAgIHJlc291cmNlSWQ6IHBhcmFtcy5yZXNvdXJjZUlkLFxuICAgIHJlc291cmNlVHlwZTogcGFyYW1zLnJlc291cmNlVHlwZSxcbiAgICBtZXNzYWdlOiBgTGFtYmRhICR7bGFtYmRhLm5hbWV9IHRpbWVvdXQgb3B0aW1pemVkIGZyb20gJHtsYW1iZGEudGltZW91dF9zZWNvbmRzfXMgdG8gJHtyZWNvbW1lbmRlZFRpbWVvdXR9c2AsXG4gICAgcHJldmlvdXNTdGF0ZSxcbiAgICBuZXdTdGF0ZTogeyB0aW1lb3V0X3NlY29uZHM6IHJlY29tbWVuZGVkVGltZW91dCB9LFxuICAgIGV4ZWN1dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkdXJhdGlvbk1zOiBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSB7IFN1cGFiYXNlQ2xpZW50IH1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjbGVhckRldGVjdGlvbkNhY2hlIiwiY3JlYXRlRXhlY3V0b3IiLCJzdXBhYmFzZVVybCIsInN1cGFiYXNlS2V5IiwiY29uc29sZSIsImxvZyIsInN1cGFiYXNlIiwiZXhlY3V0ZUFjdGlvbiIsInBhcmFtcyIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiYWN0aW9uIiwicmVzb3VyY2VUeXBlIiwicmVzb3VyY2VJZCIsInJlc3VsdCIsInRlcm1pbmF0ZUluc3RhbmNlIiwic3RvcEluc3RhbmNlIiwidGVybWluYXRlQXNnIiwic2NhbGVEb3duQXNnIiwicmVsZWFzZUVpcCIsImRlbGV0ZVZvbHVtZSIsImRlbGV0ZVNuYXBzaG90IiwiYWRkTGlmZWN5Y2xlUG9saWN5Iiwic2V0UmV0ZW50aW9uIiwic3RvcFJkcyIsImRvd25zaXplUmRzIiwiZGVsZXRlQ2FjaGUiLCJkZWxldGVMb2FkQmFsYW5jZXIiLCJyaWdodHNpemVMYW1iZGEiLCJyaWdodHNpemVJbnN0YW5jZSIsInVwZ3JhZGVWb2x1bWVUeXBlIiwiZGVsZXRlTGFtYmRhIiwiZGVsZXRlT3JwaGFuZWRTbmFwc2hvdCIsImVuYWJsZUFzZ1NjYWxpbmciLCJkaXNhYmxlTXVsdGlBeiIsImRlbGV0ZUVtcHR5TGIiLCJhZGRWZXJzaW9uRXhwaXJhdGlvbiIsIm9wdGltaXplTGFtYmRhVGltZW91dCIsIkVycm9yIiwibG9nQWN0aW9uIiwic3VjY2VzcyIsImR1cmF0aW9uIiwidG9GaXhlZCIsIm1lc3NhZ2UiLCJlcnJvciIsImZhaWxlZFJlc3VsdCIsImV4ZWN1dGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkdXJhdGlvbk1zIiwiY2F0Y2giLCJnZXRBdWRpdExvZyIsImxpbWl0IiwiZGF0YSIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsImxlbmd0aCIsImVudHJ5IiwicmVzb3VyY2VfdHlwZSIsInJlc291cmNlX2lkIiwicmVzb3VyY2VfbmFtZSIsInJlc291cmNlTmFtZSIsInNjZW5hcmlvX2lkIiwic2NlbmFyaW9JZCIsImRldGVjdGlvbl9pZCIsImRldGVjdGlvbklkIiwicHJldmlvdXNfc3RhdGUiLCJwcmV2aW91c1N0YXRlIiwibmV3X3N0YXRlIiwibmV3U3RhdGUiLCJleGVjdXRlZF9hdCIsImR1cmF0aW9uX21zIiwiTWF0aCIsInJvdW5kIiwiZXhlY3V0ZWRfYnkiLCJpbnNlcnQiLCJpbnN0YW5jZSIsImZldGNoRXJyb3IiLCJlcSIsInNpbmdsZSIsInN0YXRlIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJ1cGRhdGVkX2F0IiwiaWQiLCJpbnN0YW5jZV9pZCIsImFzZyIsImRlc2lyZWRfY2FwYWNpdHkiLCJtaW5fc2l6ZSIsIm1heF9zaXplIiwibmV3RGVzaXJlZCIsIm1heCIsImZsb29yIiwibmV3TWluIiwibWluIiwiZWlwIiwicHVibGljX2lwIiwiYXNzb2NpYXRpb25faWQiLCJkZWxldGVFcnJvciIsImRlbGV0ZSIsInJlbGVhc2VkIiwidm9sdW1lIiwic2l6ZV9nYiIsInZvbHVtZV90eXBlIiwic25hcHNob3QiLCJ2b2x1bWVfc2l6ZV9nYiIsInN0YXJ0X3RpbWUiLCJkZWxldGVkIiwiYnVja2V0IiwibGlmZWN5Y2xlX3J1bGVzIiwibmV3TGlmZWN5Y2xlUnVsZXMiLCJzdGF0dXMiLCJ0cmFuc2l0aW9ucyIsImRheXMiLCJzdG9yYWdlX2NsYXNzIiwibG9nR3JvdXAiLCJyZXRlbnRpb25faW5fZGF5cyIsIm5ld1JldGVudGlvbiIsImxvZ19ncm91cF9uYW1lIiwicmRzIiwiaW5zdGFuY2VfY2xhc3MiLCJpbnN0YW5jZVNpemVzIiwiY3VycmVudEluZGV4IiwiaW5kZXhPZiIsIm5ld0NsYXNzIiwiY2FjaGUiLCJjbHVzdGVyX2lkIiwibm9kZV90eXBlIiwibnVtX25vZGVzIiwibGIiLCJ0eXBlIiwibGFtYmRhIiwibWVtb3J5X21iIiwibmV3TWVtb3J5IiwiZnVuY3Rpb25fbmFtZSIsImluc3RhbmNlX3R5cGUiLCJyZWNvbW1lbmRlZFR5cGUiLCJkZXRhaWxzIiwicmVjb21tZW5kZWRJbnN0YW5jZVR5cGUiLCJ2b2x1bWVfaWQiLCJuYW1lIiwicnVudGltZSIsInNuYXBzaG90X2lkIiwic291cmNlX3ZvbHVtZV9pZCIsInNpemVfZ2liIiwibmV3TWluU2l6ZSIsIm5ld01heFNpemUiLCJtdWx0aV9heiIsImRiX2luc3RhbmNlX2lkIiwidGFyZ2V0X2NvdW50IiwiZXhpc3RpbmdSdWxlcyIsIm5ld1J1bGUiLCJub25jdXJyZW50X3ZlcnNpb25fZXhwaXJhdGlvbiIsInRpbWVvdXRfc2Vjb25kcyIsInJlY29tbWVuZGVkVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/agent/executor.ts\n");

/***/ }),

/***/ "(rsc)/./lib/agent/scenarios.ts":
/*!********************************!*\
  !*** ./lib/agent/scenarios.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APPROVAL_REQUIRED_SCENARIOS: () => (/* binding */ APPROVAL_REQUIRED_SCENARIOS),\n/* harmony export */   AUTO_SAFE_SCENARIOS: () => (/* binding */ AUTO_SAFE_SCENARIOS),\n/* harmony export */   WASTE_SCENARIOS: () => (/* binding */ WASTE_SCENARIOS),\n/* harmony export */   getScenario: () => (/* binding */ getScenario),\n/* harmony export */   getScenariosByMode: () => (/* binding */ getScenariosByMode)\n/* harmony export */ });\n/**\n * Waste Detection Scenarios\n *\n * 15 scenarios for detecting cloud resource waste, organized by:\n * - Mode 2 (Auto-Safe): Can be automatically optimized without approval\n * - Mode 3 (Approval Required): Requires human approval before action\n */ const WASTE_SCENARIOS = {\n    // ============================================================================\n    // MODE 2: Auto-Safe Scenarios (can be automatically optimized)\n    // ============================================================================\n    forgotten_preview: {\n        id: \"forgotten_preview\",\n        name: \"Forgotten Preview Environment\",\n        description: \"Preview environment with idle instances that should be cleaned up\",\n        mode: 2,\n        resourceType: \"autoscaling_groups\",\n        action: \"terminate_asg\",\n        severity: \"medium\",\n        baseConfidence: 85\n    },\n    over_provisioned_asg: {\n        id: \"over_provisioned_asg\",\n        name: \"Over-provisioned Auto Scaling Group\",\n        description: \"ASG with more capacity than needed based on utilization\",\n        mode: 2,\n        resourceType: \"autoscaling_groups\",\n        action: \"scale_down_asg\",\n        severity: \"medium\",\n        baseConfidence: 75\n    },\n    idle_ci_runner: {\n        id: \"idle_ci_runner\",\n        name: \"Idle CI Runner\",\n        description: \"CI runner that completed its job and is now idle\",\n        mode: 2,\n        resourceType: \"instances\",\n        action: \"terminate_instance\",\n        severity: \"low\",\n        baseConfidence: 95\n    },\n    s3_no_lifecycle: {\n        id: \"s3_no_lifecycle\",\n        name: \"S3 Bucket Without Lifecycle Policy\",\n        description: \"Bucket storing data in expensive Standard tier without tiering\",\n        mode: 2,\n        resourceType: \"s3_buckets\",\n        action: \"add_lifecycle_policy\",\n        severity: \"low\",\n        baseConfidence: 90\n    },\n    log_no_retention: {\n        id: \"log_no_retention\",\n        name: \"Log Group Without Retention\",\n        description: \"Log group accumulating data indefinitely\",\n        mode: 2,\n        resourceType: \"log_groups\",\n        action: \"set_retention\",\n        severity: \"low\",\n        baseConfidence: 90\n    },\n    off_hours_dev: {\n        id: \"off_hours_dev\",\n        name: \"Dev Instance Running Off-Hours\",\n        description: \"Development instance running during weekends or nights\",\n        mode: 2,\n        resourceType: \"instances\",\n        action: \"stop_instance\",\n        severity: \"low\",\n        baseConfidence: 80\n    },\n    stale_feature_env: {\n        id: \"stale_feature_env\",\n        name: \"Stale Feature Branch Environment\",\n        description: \"Feature environment older than 7 days with low usage\",\n        mode: 2,\n        resourceType: \"autoscaling_groups\",\n        action: \"terminate_asg\",\n        severity: \"medium\",\n        baseConfidence: 85\n    },\n    orphaned_eip: {\n        id: \"orphaned_eip\",\n        name: \"Orphaned Elastic IP\",\n        description: \"Elastic IP not attached to any resource\",\n        mode: 2,\n        resourceType: \"elastic_ips\",\n        action: \"release_eip\",\n        severity: \"low\",\n        baseConfidence: 98\n    },\n    unattached_volume: {\n        id: \"unattached_volume\",\n        name: \"Unattached EBS Volume\",\n        description: \"EBS volume not attached to any instance\",\n        mode: 2,\n        resourceType: \"volumes\",\n        action: \"delete_volume\",\n        severity: \"medium\",\n        baseConfidence: 85\n    },\n    old_snapshot: {\n        id: \"old_snapshot\",\n        name: \"Old EBS Snapshot\",\n        description: \"Snapshot older than 90 days that may no longer be needed\",\n        mode: 2,\n        resourceType: \"snapshots\",\n        action: \"delete_snapshot\",\n        severity: \"low\",\n        baseConfidence: 70\n    },\n    idle_instance: {\n        id: \"idle_instance\",\n        name: \"Idle Instance\",\n        description: \"Instance with very low CPU utilization for extended period\",\n        mode: 2,\n        resourceType: \"instances\",\n        action: \"stop_instance\",\n        severity: \"medium\",\n        baseConfidence: 80\n    },\n    // ============================================================================\n    // MODE 3: Approval Required Scenarios (require human approval)\n    // ============================================================================\n    idle_rds: {\n        id: \"idle_rds\",\n        name: \"Idle RDS Instance\",\n        description: \"RDS instance with very low CPU and connections\",\n        mode: 3,\n        resourceType: \"rds_instances\",\n        action: \"stop_rds\",\n        severity: \"high\",\n        baseConfidence: 75\n    },\n    idle_cache: {\n        id: \"idle_cache\",\n        name: \"Idle Cache Cluster\",\n        description: \"ElastiCache cluster with minimal usage\",\n        mode: 3,\n        resourceType: \"cache_clusters\",\n        action: \"delete_cache\",\n        severity: \"high\",\n        baseConfidence: 70\n    },\n    idle_load_balancer: {\n        id: \"idle_load_balancer\",\n        name: \"Idle Load Balancer\",\n        description: \"Load balancer with near-zero traffic\",\n        mode: 3,\n        resourceType: \"load_balancers\",\n        action: \"delete_lb\",\n        severity: \"medium\",\n        baseConfidence: 80\n    },\n    over_provisioned_lambda: {\n        id: \"over_provisioned_lambda\",\n        name: \"Over-provisioned Lambda Function\",\n        description: \"Lambda with much more memory allocated than used\",\n        mode: 3,\n        resourceType: \"lambda_functions\",\n        action: \"rightsize_lambda\",\n        severity: \"low\",\n        baseConfidence: 85\n    },\n    over_provisioned_instance: {\n        id: \"over_provisioned_instance\",\n        name: \"Over-provisioned EC2 Instance\",\n        description: \"EC2 instance with much more CPU/memory than utilized\",\n        mode: 3,\n        resourceType: \"instances\",\n        action: \"rightsize_instance\",\n        severity: \"medium\",\n        baseConfidence: 80\n    },\n    // ============================================================================\n    // QUICK-WIN OPTIMIZATIONS - Phase 1 (No migrations needed)\n    // ============================================================================\n    gp2_volume: {\n        id: \"gp2_volume\",\n        name: \"GP2 Volume (Upgrade to GP3)\",\n        description: \"EBS volume using older gp2 type - gp3 offers 20% cost savings with better performance\",\n        mode: 2,\n        resourceType: \"volumes\",\n        action: \"upgrade_volume_type\",\n        severity: \"low\",\n        baseConfidence: 95\n    },\n    unused_lambda: {\n        id: \"unused_lambda\",\n        name: \"Unused Lambda Function\",\n        description: \"Lambda function with zero invocations in the last 7 days\",\n        mode: 2,\n        resourceType: \"lambda_functions\",\n        action: \"delete_lambda\",\n        severity: \"low\",\n        baseConfidence: 90\n    },\n    orphaned_snapshot: {\n        id: \"orphaned_snapshot\",\n        name: \"Orphaned EBS Snapshot\",\n        description: \"Snapshot whose source volume no longer exists\",\n        mode: 2,\n        resourceType: \"snapshots\",\n        action: \"delete_orphaned_snapshot\",\n        severity: \"medium\",\n        baseConfidence: 85\n    },\n    static_asg: {\n        id: \"static_asg\",\n        name: \"Static Auto Scaling Group\",\n        description: \"ASG with min=max=desired capacity - not scaling, consider enabling dynamic scaling\",\n        mode: 3,\n        resourceType: \"autoscaling_groups\",\n        action: \"enable_asg_scaling\",\n        severity: \"low\",\n        baseConfidence: 75\n    },\n    // ============================================================================\n    // QUICK-WIN OPTIMIZATIONS - Phase 2 (With migrations)\n    // ============================================================================\n    multi_az_non_prod: {\n        id: \"multi_az_non_prod\",\n        name: \"Multi-AZ on Non-Production RDS\",\n        description: \"RDS instance with Multi-AZ enabled in dev/staging environment - unnecessary redundancy\",\n        mode: 2,\n        resourceType: \"rds_instances\",\n        action: \"disable_multi_az\",\n        severity: \"medium\",\n        baseConfidence: 90\n    },\n    empty_load_balancer: {\n        id: \"empty_load_balancer\",\n        name: \"Load Balancer with No Targets\",\n        description: \"Load balancer with zero registered or healthy targets\",\n        mode: 3,\n        resourceType: \"load_balancers\",\n        action: \"delete_empty_lb\",\n        severity: \"medium\",\n        baseConfidence: 85\n    },\n    s3_no_version_expiration: {\n        id: \"s3_no_version_expiration\",\n        name: \"S3 Bucket Without Version Expiration\",\n        description: \"Versioned bucket without noncurrent version expiration - old versions accumulating costs\",\n        mode: 2,\n        resourceType: \"s3_buckets\",\n        action: \"add_version_expiration\",\n        severity: \"low\",\n        baseConfidence: 85\n    },\n    over_configured_lambda_timeout: {\n        id: \"over_configured_lambda_timeout\",\n        name: \"Over-Configured Lambda Timeout\",\n        description: \"Lambda with timeout much higher than actual execution duration\",\n        mode: 3,\n        resourceType: \"lambda_functions\",\n        action: \"optimize_lambda_timeout\",\n        severity: \"low\",\n        baseConfidence: 80\n    }\n};\n// Helper to get scenarios by mode\nfunction getScenariosByMode(mode) {\n    return Object.values(WASTE_SCENARIOS).filter((s)=>s.mode === mode);\n}\n// Helper to get scenario by ID\nfunction getScenario(id) {\n    return WASTE_SCENARIOS[id];\n}\n// Mode 2 scenarios (Auto-Safe)\nconst AUTO_SAFE_SCENARIOS = getScenariosByMode(2);\n// Mode 3 scenarios (Approval Required)\nconst APPROVAL_REQUIRED_SCENARIOS = getScenariosByMode(3);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLGdCQUFnQjtJQUNsQjtJQUVBdUIsZ0NBQWdDO1FBQzlCOUIsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxnQkFBZ0I7SUFDbEI7QUFDRixFQUFDO0FBRUQsa0NBQWtDO0FBQzNCLFNBQVN3QixtQkFBbUI1QixJQUFXO0lBQzVDLE9BQU82QixPQUFPQyxNQUFNLENBQUNuQyxpQkFBaUJvQyxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRWhDLElBQUksS0FBS0E7QUFDakU7QUFFQSwrQkFBK0I7QUFDeEIsU0FBU2lDLFlBQVlwQyxFQUFtQjtJQUM3QyxPQUFPRixlQUFlLENBQUNFLEdBQUc7QUFDNUI7QUFFQSwrQkFBK0I7QUFDeEIsTUFBTXFDLHNCQUFzQk4sbUJBQW1CLEdBQUU7QUFFeEQsdUNBQXVDO0FBQ2hDLE1BQU1PLDhCQUE4QlAsbUJBQW1CLEdBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGljLWFpLXBsYXRmb3JtLy4vbGliL2FnZW50L3NjZW5hcmlvcy50cz8yMGQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2FzdGUgRGV0ZWN0aW9uIFNjZW5hcmlvc1xuICpcbiAqIDE1IHNjZW5hcmlvcyBmb3IgZGV0ZWN0aW5nIGNsb3VkIHJlc291cmNlIHdhc3RlLCBvcmdhbml6ZWQgYnk6XG4gKiAtIE1vZGUgMiAoQXV0by1TYWZlKTogQ2FuIGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkIHdpdGhvdXQgYXBwcm92YWxcbiAqIC0gTW9kZSAzIChBcHByb3ZhbCBSZXF1aXJlZCk6IFJlcXVpcmVzIGh1bWFuIGFwcHJvdmFsIGJlZm9yZSBhY3Rpb25cbiAqL1xuXG5leHBvcnQgdHlwZSBXYXN0ZVNjZW5hcmlvSWQgPVxuICB8IFwiZm9yZ290dGVuX3ByZXZpZXdcIlxuICB8IFwib3Zlcl9wcm92aXNpb25lZF9hc2dcIlxuICB8IFwiaWRsZV9jaV9ydW5uZXJcIlxuICB8IFwiczNfbm9fbGlmZWN5Y2xlXCJcbiAgfCBcImxvZ19ub19yZXRlbnRpb25cIlxuICB8IFwib2ZmX2hvdXJzX2RldlwiXG4gIHwgXCJzdGFsZV9mZWF0dXJlX2VudlwiXG4gIHwgXCJvcnBoYW5lZF9laXBcIlxuICB8IFwidW5hdHRhY2hlZF92b2x1bWVcIlxuICB8IFwib2xkX3NuYXBzaG90XCJcbiAgfCBcImlkbGVfcmRzXCJcbiAgfCBcImlkbGVfY2FjaGVcIlxuICB8IFwiaWRsZV9sb2FkX2JhbGFuY2VyXCJcbiAgfCBcIm92ZXJfcHJvdmlzaW9uZWRfbGFtYmRhXCJcbiAgfCBcImlkbGVfaW5zdGFuY2VcIlxuICB8IFwib3Zlcl9wcm92aXNpb25lZF9pbnN0YW5jZVwiXG4gIC8vIFBoYXNlIDE6IFF1aWNrLXdpbiBvcHRpbWl6YXRpb25zIChubyBtaWdyYXRpb25zIG5lZWRlZClcbiAgfCBcImdwMl92b2x1bWVcIlxuICB8IFwidW51c2VkX2xhbWJkYVwiXG4gIHwgXCJvcnBoYW5lZF9zbmFwc2hvdFwiXG4gIHwgXCJzdGF0aWNfYXNnXCJcbiAgLy8gUGhhc2UgMjogUXVpY2std2luIG9wdGltaXphdGlvbnMgKHdpdGggbWlncmF0aW9ucylcbiAgfCBcIm11bHRpX2F6X25vbl9wcm9kXCJcbiAgfCBcImVtcHR5X2xvYWRfYmFsYW5jZXJcIlxuICB8IFwiczNfbm9fdmVyc2lvbl9leHBpcmF0aW9uXCJcbiAgfCBcIm92ZXJfY29uZmlndXJlZF9sYW1iZGFfdGltZW91dFwiXG5cbmV4cG9ydCB0eXBlIEFjdGlvblR5cGUgPVxuICB8IFwidGVybWluYXRlX2FzZ1wiXG4gIHwgXCJzY2FsZV9kb3duX2FzZ1wiXG4gIHwgXCJ0ZXJtaW5hdGVfaW5zdGFuY2VcIlxuICB8IFwic3RvcF9pbnN0YW5jZVwiXG4gIHwgXCJyaWdodHNpemVfaW5zdGFuY2VcIlxuICB8IFwiYWRkX2xpZmVjeWNsZV9wb2xpY3lcIlxuICB8IFwic2V0X3JldGVudGlvblwiXG4gIHwgXCJyZWxlYXNlX2VpcFwiXG4gIHwgXCJkZWxldGVfdm9sdW1lXCJcbiAgfCBcImRlbGV0ZV9zbmFwc2hvdFwiXG4gIHwgXCJzdG9wX3Jkc1wiXG4gIHwgXCJkb3duc2l6ZV9yZHNcIlxuICB8IFwiZGVsZXRlX2NhY2hlXCJcbiAgfCBcImRlbGV0ZV9sYlwiXG4gIHwgXCJyaWdodHNpemVfbGFtYmRhXCJcbiAgLy8gUGhhc2UgMTogUXVpY2std2luIGFjdGlvbnNcbiAgfCBcInVwZ3JhZGVfdm9sdW1lX3R5cGVcIlxuICB8IFwiZGVsZXRlX2xhbWJkYVwiXG4gIHwgXCJkZWxldGVfb3JwaGFuZWRfc25hcHNob3RcIlxuICB8IFwiZW5hYmxlX2FzZ19zY2FsaW5nXCJcbiAgLy8gUGhhc2UgMjogUXVpY2std2luIGFjdGlvbnNcbiAgfCBcImRpc2FibGVfbXVsdGlfYXpcIlxuICB8IFwiZGVsZXRlX2VtcHR5X2xiXCJcbiAgfCBcImFkZF92ZXJzaW9uX2V4cGlyYXRpb25cIlxuICB8IFwib3B0aW1pemVfbGFtYmRhX3RpbWVvdXRcIlxuXG5leHBvcnQgdHlwZSBSZXNvdXJjZVR5cGUgPVxuICB8IFwiYXV0b3NjYWxpbmdfZ3JvdXBzXCJcbiAgfCBcImluc3RhbmNlc1wiXG4gIHwgXCJzM19idWNrZXRzXCJcbiAgfCBcImxvZ19ncm91cHNcIlxuICB8IFwiZWxhc3RpY19pcHNcIlxuICB8IFwidm9sdW1lc1wiXG4gIHwgXCJzbmFwc2hvdHNcIlxuICB8IFwicmRzX2luc3RhbmNlc1wiXG4gIHwgXCJjYWNoZV9jbHVzdGVyc1wiXG4gIHwgXCJsb2FkX2JhbGFuY2Vyc1wiXG4gIHwgXCJsYW1iZGFfZnVuY3Rpb25zXCJcblxuZXhwb3J0IGludGVyZmFjZSBXYXN0ZVNjZW5hcmlvIHtcbiAgaWQ6IFdhc3RlU2NlbmFyaW9JZFxuICBuYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBtb2RlOiAyIHwgMyAvLyBNb2RlIDIgPSBBdXRvLVNhZmUsIE1vZGUgMyA9IEFwcHJvdmFsIFJlcXVpcmVkXG4gIHJlc291cmNlVHlwZTogUmVzb3VyY2VUeXBlXG4gIGFjdGlvbjogQWN0aW9uVHlwZVxuICBzZXZlcml0eTogXCJsb3dcIiB8IFwibWVkaXVtXCIgfCBcImhpZ2hcIlxuICBiYXNlQ29uZmlkZW5jZTogbnVtYmVyIC8vIDAtMTAwXG59XG5cbmV4cG9ydCBjb25zdCBXQVNURV9TQ0VOQVJJT1M6IFJlY29yZDxXYXN0ZVNjZW5hcmlvSWQsIFdhc3RlU2NlbmFyaW8+ID0ge1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIE1PREUgMjogQXV0by1TYWZlIFNjZW5hcmlvcyAoY2FuIGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZm9yZ290dGVuX3ByZXZpZXc6IHtcbiAgICBpZDogXCJmb3Jnb3R0ZW5fcHJldmlld1wiLFxuICAgIG5hbWU6IFwiRm9yZ290dGVuIFByZXZpZXcgRW52aXJvbm1lbnRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQcmV2aWV3IGVudmlyb25tZW50IHdpdGggaWRsZSBpbnN0YW5jZXMgdGhhdCBzaG91bGQgYmUgY2xlYW5lZCB1cFwiLFxuICAgIG1vZGU6IDIsXG4gICAgcmVzb3VyY2VUeXBlOiBcImF1dG9zY2FsaW5nX2dyb3Vwc1wiLFxuICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVfYXNnXCIsXG4gICAgc2V2ZXJpdHk6IFwibWVkaXVtXCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDg1LFxuICB9LFxuXG4gIG92ZXJfcHJvdmlzaW9uZWRfYXNnOiB7XG4gICAgaWQ6IFwib3Zlcl9wcm92aXNpb25lZF9hc2dcIixcbiAgICBuYW1lOiBcIk92ZXItcHJvdmlzaW9uZWQgQXV0byBTY2FsaW5nIEdyb3VwXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQVNHIHdpdGggbW9yZSBjYXBhY2l0eSB0aGFuIG5lZWRlZCBiYXNlZCBvbiB1dGlsaXphdGlvblwiLFxuICAgIG1vZGU6IDIsXG4gICAgcmVzb3VyY2VUeXBlOiBcImF1dG9zY2FsaW5nX2dyb3Vwc1wiLFxuICAgIGFjdGlvbjogXCJzY2FsZV9kb3duX2FzZ1wiLFxuICAgIHNldmVyaXR5OiBcIm1lZGl1bVwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA3NSxcbiAgfSxcblxuICBpZGxlX2NpX3J1bm5lcjoge1xuICAgIGlkOiBcImlkbGVfY2lfcnVubmVyXCIsXG4gICAgbmFtZTogXCJJZGxlIENJIFJ1bm5lclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkNJIHJ1bm5lciB0aGF0IGNvbXBsZXRlZCBpdHMgam9iIGFuZCBpcyBub3cgaWRsZVwiLFxuICAgIG1vZGU6IDIsXG4gICAgcmVzb3VyY2VUeXBlOiBcImluc3RhbmNlc1wiLFxuICAgIGFjdGlvbjogXCJ0ZXJtaW5hdGVfaW5zdGFuY2VcIixcbiAgICBzZXZlcml0eTogXCJsb3dcIixcbiAgICBiYXNlQ29uZmlkZW5jZTogOTUsXG4gIH0sXG5cbiAgczNfbm9fbGlmZWN5Y2xlOiB7XG4gICAgaWQ6IFwiczNfbm9fbGlmZWN5Y2xlXCIsXG4gICAgbmFtZTogXCJTMyBCdWNrZXQgV2l0aG91dCBMaWZlY3ljbGUgUG9saWN5XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQnVja2V0IHN0b3JpbmcgZGF0YSBpbiBleHBlbnNpdmUgU3RhbmRhcmQgdGllciB3aXRob3V0IHRpZXJpbmdcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJzM19idWNrZXRzXCIsXG4gICAgYWN0aW9uOiBcImFkZF9saWZlY3ljbGVfcG9saWN5XCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDkwLFxuICB9LFxuXG4gIGxvZ19ub19yZXRlbnRpb246IHtcbiAgICBpZDogXCJsb2dfbm9fcmV0ZW50aW9uXCIsXG4gICAgbmFtZTogXCJMb2cgR3JvdXAgV2l0aG91dCBSZXRlbnRpb25cIixcbiAgICBkZXNjcmlwdGlvbjogXCJMb2cgZ3JvdXAgYWNjdW11bGF0aW5nIGRhdGEgaW5kZWZpbml0ZWx5XCIsXG4gICAgbW9kZTogMixcbiAgICByZXNvdXJjZVR5cGU6IFwibG9nX2dyb3Vwc1wiLFxuICAgIGFjdGlvbjogXCJzZXRfcmV0ZW50aW9uXCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDkwLFxuICB9LFxuXG4gIG9mZl9ob3Vyc19kZXY6IHtcbiAgICBpZDogXCJvZmZfaG91cnNfZGV2XCIsXG4gICAgbmFtZTogXCJEZXYgSW5zdGFuY2UgUnVubmluZyBPZmYtSG91cnNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJEZXZlbG9wbWVudCBpbnN0YW5jZSBydW5uaW5nIGR1cmluZyB3ZWVrZW5kcyBvciBuaWdodHNcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJpbnN0YW5jZXNcIixcbiAgICBhY3Rpb246IFwic3RvcF9pbnN0YW5jZVwiLFxuICAgIHNldmVyaXR5OiBcImxvd1wiLFxuICAgIGJhc2VDb25maWRlbmNlOiA4MCxcbiAgfSxcblxuICBzdGFsZV9mZWF0dXJlX2Vudjoge1xuICAgIGlkOiBcInN0YWxlX2ZlYXR1cmVfZW52XCIsXG4gICAgbmFtZTogXCJTdGFsZSBGZWF0dXJlIEJyYW5jaCBFbnZpcm9ubWVudFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkZlYXR1cmUgZW52aXJvbm1lbnQgb2xkZXIgdGhhbiA3IGRheXMgd2l0aCBsb3cgdXNhZ2VcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJhdXRvc2NhbGluZ19ncm91cHNcIixcbiAgICBhY3Rpb246IFwidGVybWluYXRlX2FzZ1wiLFxuICAgIHNldmVyaXR5OiBcIm1lZGl1bVwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA4NSxcbiAgfSxcblxuICBvcnBoYW5lZF9laXA6IHtcbiAgICBpZDogXCJvcnBoYW5lZF9laXBcIixcbiAgICBuYW1lOiBcIk9ycGhhbmVkIEVsYXN0aWMgSVBcIixcbiAgICBkZXNjcmlwdGlvbjogXCJFbGFzdGljIElQIG5vdCBhdHRhY2hlZCB0byBhbnkgcmVzb3VyY2VcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJlbGFzdGljX2lwc1wiLFxuICAgIGFjdGlvbjogXCJyZWxlYXNlX2VpcFwiLFxuICAgIHNldmVyaXR5OiBcImxvd1wiLFxuICAgIGJhc2VDb25maWRlbmNlOiA5OCxcbiAgfSxcblxuICB1bmF0dGFjaGVkX3ZvbHVtZToge1xuICAgIGlkOiBcInVuYXR0YWNoZWRfdm9sdW1lXCIsXG4gICAgbmFtZTogXCJVbmF0dGFjaGVkIEVCUyBWb2x1bWVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJFQlMgdm9sdW1lIG5vdCBhdHRhY2hlZCB0byBhbnkgaW5zdGFuY2VcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJ2b2x1bWVzXCIsXG4gICAgYWN0aW9uOiBcImRlbGV0ZV92b2x1bWVcIixcbiAgICBzZXZlcml0eTogXCJtZWRpdW1cIixcbiAgICBiYXNlQ29uZmlkZW5jZTogODUsXG4gIH0sXG5cbiAgb2xkX3NuYXBzaG90OiB7XG4gICAgaWQ6IFwib2xkX3NuYXBzaG90XCIsXG4gICAgbmFtZTogXCJPbGQgRUJTIFNuYXBzaG90XCIsXG4gICAgZGVzY3JpcHRpb246IFwiU25hcHNob3Qgb2xkZXIgdGhhbiA5MCBkYXlzIHRoYXQgbWF5IG5vIGxvbmdlciBiZSBuZWVkZWRcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJzbmFwc2hvdHNcIixcbiAgICBhY3Rpb246IFwiZGVsZXRlX3NuYXBzaG90XCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDcwLFxuICB9LFxuXG4gIGlkbGVfaW5zdGFuY2U6IHtcbiAgICBpZDogXCJpZGxlX2luc3RhbmNlXCIsXG4gICAgbmFtZTogXCJJZGxlIEluc3RhbmNlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSW5zdGFuY2Ugd2l0aCB2ZXJ5IGxvdyBDUFUgdXRpbGl6YXRpb24gZm9yIGV4dGVuZGVkIHBlcmlvZFwiLFxuICAgIG1vZGU6IDIsXG4gICAgcmVzb3VyY2VUeXBlOiBcImluc3RhbmNlc1wiLFxuICAgIGFjdGlvbjogXCJzdG9wX2luc3RhbmNlXCIsXG4gICAgc2V2ZXJpdHk6IFwibWVkaXVtXCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDgwLFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTU9ERSAzOiBBcHByb3ZhbCBSZXF1aXJlZCBTY2VuYXJpb3MgKHJlcXVpcmUgaHVtYW4gYXBwcm92YWwpXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBpZGxlX3Jkczoge1xuICAgIGlkOiBcImlkbGVfcmRzXCIsXG4gICAgbmFtZTogXCJJZGxlIFJEUyBJbnN0YW5jZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlJEUyBpbnN0YW5jZSB3aXRoIHZlcnkgbG93IENQVSBhbmQgY29ubmVjdGlvbnNcIixcbiAgICBtb2RlOiAzLFxuICAgIHJlc291cmNlVHlwZTogXCJyZHNfaW5zdGFuY2VzXCIsXG4gICAgYWN0aW9uOiBcInN0b3BfcmRzXCIsXG4gICAgc2V2ZXJpdHk6IFwiaGlnaFwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA3NSxcbiAgfSxcblxuICBpZGxlX2NhY2hlOiB7XG4gICAgaWQ6IFwiaWRsZV9jYWNoZVwiLFxuICAgIG5hbWU6IFwiSWRsZSBDYWNoZSBDbHVzdGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiRWxhc3RpQ2FjaGUgY2x1c3RlciB3aXRoIG1pbmltYWwgdXNhZ2VcIixcbiAgICBtb2RlOiAzLFxuICAgIHJlc291cmNlVHlwZTogXCJjYWNoZV9jbHVzdGVyc1wiLFxuICAgIGFjdGlvbjogXCJkZWxldGVfY2FjaGVcIixcbiAgICBzZXZlcml0eTogXCJoaWdoXCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDcwLFxuICB9LFxuXG4gIGlkbGVfbG9hZF9iYWxhbmNlcjoge1xuICAgIGlkOiBcImlkbGVfbG9hZF9iYWxhbmNlclwiLFxuICAgIG5hbWU6IFwiSWRsZSBMb2FkIEJhbGFuY2VyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTG9hZCBiYWxhbmNlciB3aXRoIG5lYXItemVybyB0cmFmZmljXCIsXG4gICAgbW9kZTogMyxcbiAgICByZXNvdXJjZVR5cGU6IFwibG9hZF9iYWxhbmNlcnNcIixcbiAgICBhY3Rpb246IFwiZGVsZXRlX2xiXCIsXG4gICAgc2V2ZXJpdHk6IFwibWVkaXVtXCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDgwLFxuICB9LFxuXG4gIG92ZXJfcHJvdmlzaW9uZWRfbGFtYmRhOiB7XG4gICAgaWQ6IFwib3Zlcl9wcm92aXNpb25lZF9sYW1iZGFcIixcbiAgICBuYW1lOiBcIk92ZXItcHJvdmlzaW9uZWQgTGFtYmRhIEZ1bmN0aW9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTGFtYmRhIHdpdGggbXVjaCBtb3JlIG1lbW9yeSBhbGxvY2F0ZWQgdGhhbiB1c2VkXCIsXG4gICAgbW9kZTogMyxcbiAgICByZXNvdXJjZVR5cGU6IFwibGFtYmRhX2Z1bmN0aW9uc1wiLFxuICAgIGFjdGlvbjogXCJyaWdodHNpemVfbGFtYmRhXCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDg1LFxuICB9LFxuXG4gIG92ZXJfcHJvdmlzaW9uZWRfaW5zdGFuY2U6IHtcbiAgICBpZDogXCJvdmVyX3Byb3Zpc2lvbmVkX2luc3RhbmNlXCIsXG4gICAgbmFtZTogXCJPdmVyLXByb3Zpc2lvbmVkIEVDMiBJbnN0YW5jZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkVDMiBpbnN0YW5jZSB3aXRoIG11Y2ggbW9yZSBDUFUvbWVtb3J5IHRoYW4gdXRpbGl6ZWRcIixcbiAgICBtb2RlOiAzLFxuICAgIHJlc291cmNlVHlwZTogXCJpbnN0YW5jZXNcIixcbiAgICBhY3Rpb246IFwicmlnaHRzaXplX2luc3RhbmNlXCIsXG4gICAgc2V2ZXJpdHk6IFwibWVkaXVtXCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDgwLFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUVVJQ0stV0lOIE9QVElNSVpBVElPTlMgLSBQaGFzZSAxIChObyBtaWdyYXRpb25zIG5lZWRlZClcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGdwMl92b2x1bWU6IHtcbiAgICBpZDogXCJncDJfdm9sdW1lXCIsXG4gICAgbmFtZTogXCJHUDIgVm9sdW1lIChVcGdyYWRlIHRvIEdQMylcIixcbiAgICBkZXNjcmlwdGlvbjogXCJFQlMgdm9sdW1lIHVzaW5nIG9sZGVyIGdwMiB0eXBlIC0gZ3AzIG9mZmVycyAyMCUgY29zdCBzYXZpbmdzIHdpdGggYmV0dGVyIHBlcmZvcm1hbmNlXCIsXG4gICAgbW9kZTogMixcbiAgICByZXNvdXJjZVR5cGU6IFwidm9sdW1lc1wiLFxuICAgIGFjdGlvbjogXCJ1cGdyYWRlX3ZvbHVtZV90eXBlXCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDk1LFxuICB9LFxuXG4gIHVudXNlZF9sYW1iZGE6IHtcbiAgICBpZDogXCJ1bnVzZWRfbGFtYmRhXCIsXG4gICAgbmFtZTogXCJVbnVzZWQgTGFtYmRhIEZ1bmN0aW9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTGFtYmRhIGZ1bmN0aW9uIHdpdGggemVybyBpbnZvY2F0aW9ucyBpbiB0aGUgbGFzdCA3IGRheXNcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJsYW1iZGFfZnVuY3Rpb25zXCIsXG4gICAgYWN0aW9uOiBcImRlbGV0ZV9sYW1iZGFcIixcbiAgICBzZXZlcml0eTogXCJsb3dcIixcbiAgICBiYXNlQ29uZmlkZW5jZTogOTAsXG4gIH0sXG5cbiAgb3JwaGFuZWRfc25hcHNob3Q6IHtcbiAgICBpZDogXCJvcnBoYW5lZF9zbmFwc2hvdFwiLFxuICAgIG5hbWU6IFwiT3JwaGFuZWQgRUJTIFNuYXBzaG90XCIsXG4gICAgZGVzY3JpcHRpb246IFwiU25hcHNob3Qgd2hvc2Ugc291cmNlIHZvbHVtZSBubyBsb25nZXIgZXhpc3RzXCIsXG4gICAgbW9kZTogMixcbiAgICByZXNvdXJjZVR5cGU6IFwic25hcHNob3RzXCIsXG4gICAgYWN0aW9uOiBcImRlbGV0ZV9vcnBoYW5lZF9zbmFwc2hvdFwiLFxuICAgIHNldmVyaXR5OiBcIm1lZGl1bVwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA4NSxcbiAgfSxcblxuICBzdGF0aWNfYXNnOiB7XG4gICAgaWQ6IFwic3RhdGljX2FzZ1wiLFxuICAgIG5hbWU6IFwiU3RhdGljIEF1dG8gU2NhbGluZyBHcm91cFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFTRyB3aXRoIG1pbj1tYXg9ZGVzaXJlZCBjYXBhY2l0eSAtIG5vdCBzY2FsaW5nLCBjb25zaWRlciBlbmFibGluZyBkeW5hbWljIHNjYWxpbmdcIixcbiAgICBtb2RlOiAzLFxuICAgIHJlc291cmNlVHlwZTogXCJhdXRvc2NhbGluZ19ncm91cHNcIixcbiAgICBhY3Rpb246IFwiZW5hYmxlX2FzZ19zY2FsaW5nXCIsXG4gICAgc2V2ZXJpdHk6IFwibG93XCIsXG4gICAgYmFzZUNvbmZpZGVuY2U6IDc1LFxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUVVJQ0stV0lOIE9QVElNSVpBVElPTlMgLSBQaGFzZSAyIChXaXRoIG1pZ3JhdGlvbnMpXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBtdWx0aV9hel9ub25fcHJvZDoge1xuICAgIGlkOiBcIm11bHRpX2F6X25vbl9wcm9kXCIsXG4gICAgbmFtZTogXCJNdWx0aS1BWiBvbiBOb24tUHJvZHVjdGlvbiBSRFNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJSRFMgaW5zdGFuY2Ugd2l0aCBNdWx0aS1BWiBlbmFibGVkIGluIGRldi9zdGFnaW5nIGVudmlyb25tZW50IC0gdW5uZWNlc3NhcnkgcmVkdW5kYW5jeVwiLFxuICAgIG1vZGU6IDIsXG4gICAgcmVzb3VyY2VUeXBlOiBcInJkc19pbnN0YW5jZXNcIixcbiAgICBhY3Rpb246IFwiZGlzYWJsZV9tdWx0aV9helwiLFxuICAgIHNldmVyaXR5OiBcIm1lZGl1bVwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA5MCxcbiAgfSxcblxuICBlbXB0eV9sb2FkX2JhbGFuY2VyOiB7XG4gICAgaWQ6IFwiZW1wdHlfbG9hZF9iYWxhbmNlclwiLFxuICAgIG5hbWU6IFwiTG9hZCBCYWxhbmNlciB3aXRoIE5vIFRhcmdldHNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJMb2FkIGJhbGFuY2VyIHdpdGggemVybyByZWdpc3RlcmVkIG9yIGhlYWx0aHkgdGFyZ2V0c1wiLFxuICAgIG1vZGU6IDMsXG4gICAgcmVzb3VyY2VUeXBlOiBcImxvYWRfYmFsYW5jZXJzXCIsXG4gICAgYWN0aW9uOiBcImRlbGV0ZV9lbXB0eV9sYlwiLFxuICAgIHNldmVyaXR5OiBcIm1lZGl1bVwiLFxuICAgIGJhc2VDb25maWRlbmNlOiA4NSxcbiAgfSxcblxuICBzM19ub192ZXJzaW9uX2V4cGlyYXRpb246IHtcbiAgICBpZDogXCJzM19ub192ZXJzaW9uX2V4cGlyYXRpb25cIixcbiAgICBuYW1lOiBcIlMzIEJ1Y2tldCBXaXRob3V0IFZlcnNpb24gRXhwaXJhdGlvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlZlcnNpb25lZCBidWNrZXQgd2l0aG91dCBub25jdXJyZW50IHZlcnNpb24gZXhwaXJhdGlvbiAtIG9sZCB2ZXJzaW9ucyBhY2N1bXVsYXRpbmcgY29zdHNcIixcbiAgICBtb2RlOiAyLFxuICAgIHJlc291cmNlVHlwZTogXCJzM19idWNrZXRzXCIsXG4gICAgYWN0aW9uOiBcImFkZF92ZXJzaW9uX2V4cGlyYXRpb25cIixcbiAgICBzZXZlcml0eTogXCJsb3dcIixcbiAgICBiYXNlQ29uZmlkZW5jZTogODUsXG4gIH0sXG5cbiAgb3Zlcl9jb25maWd1cmVkX2xhbWJkYV90aW1lb3V0OiB7XG4gICAgaWQ6IFwib3Zlcl9jb25maWd1cmVkX2xhbWJkYV90aW1lb3V0XCIsXG4gICAgbmFtZTogXCJPdmVyLUNvbmZpZ3VyZWQgTGFtYmRhIFRpbWVvdXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJMYW1iZGEgd2l0aCB0aW1lb3V0IG11Y2ggaGlnaGVyIHRoYW4gYWN0dWFsIGV4ZWN1dGlvbiBkdXJhdGlvblwiLFxuICAgIG1vZGU6IDMsXG4gICAgcmVzb3VyY2VUeXBlOiBcImxhbWJkYV9mdW5jdGlvbnNcIixcbiAgICBhY3Rpb246IFwib3B0aW1pemVfbGFtYmRhX3RpbWVvdXRcIixcbiAgICBzZXZlcml0eTogXCJsb3dcIixcbiAgICBiYXNlQ29uZmlkZW5jZTogODAsXG4gIH0sXG59XG5cbi8vIEhlbHBlciB0byBnZXQgc2NlbmFyaW9zIGJ5IG1vZGVcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2VuYXJpb3NCeU1vZGUobW9kZTogMiB8IDMpOiBXYXN0ZVNjZW5hcmlvW10ge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhXQVNURV9TQ0VOQVJJT1MpLmZpbHRlcigocykgPT4gcy5tb2RlID09PSBtb2RlKVxufVxuXG4vLyBIZWxwZXIgdG8gZ2V0IHNjZW5hcmlvIGJ5IElEXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NlbmFyaW8oaWQ6IFdhc3RlU2NlbmFyaW9JZCk6IFdhc3RlU2NlbmFyaW8gfCB1bmRlZmluZWQge1xuICByZXR1cm4gV0FTVEVfU0NFTkFSSU9TW2lkXVxufVxuXG4vLyBNb2RlIDIgc2NlbmFyaW9zIChBdXRvLVNhZmUpXG5leHBvcnQgY29uc3QgQVVUT19TQUZFX1NDRU5BUklPUyA9IGdldFNjZW5hcmlvc0J5TW9kZSgyKVxuXG4vLyBNb2RlIDMgc2NlbmFyaW9zIChBcHByb3ZhbCBSZXF1aXJlZClcbmV4cG9ydCBjb25zdCBBUFBST1ZBTF9SRVFVSVJFRF9TQ0VOQVJJT1MgPSBnZXRTY2VuYXJpb3NCeU1vZGUoMylcbiJdLCJuYW1lcyI6WyJXQVNURV9TQ0VOQVJJT1MiLCJmb3Jnb3R0ZW5fcHJldmlldyIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwibW9kZSIsInJlc291cmNlVHlwZSIsImFjdGlvbiIsInNldmVyaXR5IiwiYmFzZUNvbmZpZGVuY2UiLCJvdmVyX3Byb3Zpc2lvbmVkX2FzZyIsImlkbGVfY2lfcnVubmVyIiwiczNfbm9fbGlmZWN5Y2xlIiwibG9nX25vX3JldGVudGlvbiIsIm9mZl9ob3Vyc19kZXYiLCJzdGFsZV9mZWF0dXJlX2VudiIsIm9ycGhhbmVkX2VpcCIsInVuYXR0YWNoZWRfdm9sdW1lIiwib2xkX3NuYXBzaG90IiwiaWRsZV9pbnN0YW5jZSIsImlkbGVfcmRzIiwiaWRsZV9jYWNoZSIsImlkbGVfbG9hZF9iYWxhbmNlciIsIm92ZXJfcHJvdmlzaW9uZWRfbGFtYmRhIiwib3Zlcl9wcm92aXNpb25lZF9pbnN0YW5jZSIsImdwMl92b2x1bWUiLCJ1bnVzZWRfbGFtYmRhIiwib3JwaGFuZWRfc25hcHNob3QiLCJzdGF0aWNfYXNnIiwibXVsdGlfYXpfbm9uX3Byb2QiLCJlbXB0eV9sb2FkX2JhbGFuY2VyIiwiczNfbm9fdmVyc2lvbl9leHBpcmF0aW9uIiwib3Zlcl9jb25maWd1cmVkX2xhbWJkYV90aW1lb3V0IiwiZ2V0U2NlbmFyaW9zQnlNb2RlIiwiT2JqZWN0IiwidmFsdWVzIiwiZmlsdGVyIiwicyIsImdldFNjZW5hcmlvIiwiQVVUT19TQUZFX1NDRU5BUklPUyIsIkFQUFJPVkFMX1JFUVVJUkVEX1NDRU5BUklPUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/agent/scenarios.ts\n");

/***/ }),

/***/ "(rsc)/./lib/utils/pricing.ts":
/*!******************************!*\
  !*** ./lib/utils/pricing.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALB_HOURLY_RATE: () => (/* binding */ ALB_HOURLY_RATE),\n/* harmony export */   ALB_LCU_RATE: () => (/* binding */ ALB_LCU_RATE),\n/* harmony export */   CLOUDWATCH_LOGS_GB_RATE: () => (/* binding */ CLOUDWATCH_LOGS_GB_RATE),\n/* harmony export */   EBS_GB_MONTH_RATES: () => (/* binding */ EBS_GB_MONTH_RATES),\n/* harmony export */   EC2_DOWNSIZE_MAP: () => (/* binding */ EC2_DOWNSIZE_MAP),\n/* harmony export */   EC2_HOURLY_RATES: () => (/* binding */ EC2_HOURLY_RATES),\n/* harmony export */   EC2_INSTANCE_SPECS: () => (/* binding */ EC2_INSTANCE_SPECS),\n/* harmony export */   ELASTICACHE_HOURLY_RATES: () => (/* binding */ ELASTICACHE_HOURLY_RATES),\n/* harmony export */   HOURS_PER_MONTH: () => (/* binding */ HOURS_PER_MONTH),\n/* harmony export */   LAMBDA_GB_SECOND_RATE: () => (/* binding */ LAMBDA_GB_SECOND_RATE),\n/* harmony export */   LAMBDA_REQUEST_RATE: () => (/* binding */ LAMBDA_REQUEST_RATE),\n/* harmony export */   RDS_HOURLY_RATES: () => (/* binding */ RDS_HOURLY_RATES),\n/* harmony export */   S3_GLACIER_GB_MONTH: () => (/* binding */ S3_GLACIER_GB_MONTH),\n/* harmony export */   S3_INTELLIGENT_TIERING_GB_MONTH: () => (/* binding */ S3_INTELLIGENT_TIERING_GB_MONTH),\n/* harmony export */   S3_STANDARD_GB_MONTH: () => (/* binding */ S3_STANDARD_GB_MONTH),\n/* harmony export */   SNAPSHOT_GB_MONTH_RATE: () => (/* binding */ SNAPSHOT_GB_MONTH_RATE),\n/* harmony export */   UNATTACHED_EIP_HOURLY_RATE: () => (/* binding */ UNATTACHED_EIP_HOURLY_RATE),\n/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),\n/* harmony export */   formatCurrencyPrecise: () => (/* binding */ formatCurrencyPrecise),\n/* harmony export */   getCacheMonthlyCost: () => (/* binding */ getCacheMonthlyCost),\n/* harmony export */   getEC2InstanceSpecs: () => (/* binding */ getEC2InstanceSpecs),\n/* harmony export */   getEC2MonthlyCost: () => (/* binding */ getEC2MonthlyCost),\n/* harmony export */   getLambdaMonthlyCost: () => (/* binding */ getLambdaMonthlyCost),\n/* harmony export */   getLoadBalancerMonthlyCost: () => (/* binding */ getLoadBalancerMonthlyCost),\n/* harmony export */   getLogGroupMonthlyCost: () => (/* binding */ getLogGroupMonthlyCost),\n/* harmony export */   getRDSMonthlyCost: () => (/* binding */ getRDSMonthlyCost),\n/* harmony export */   getRecommendedSmallerInstance: () => (/* binding */ getRecommendedSmallerInstance),\n/* harmony export */   getS3MonthlyCost: () => (/* binding */ getS3MonthlyCost),\n/* harmony export */   getS3TieringSavings: () => (/* binding */ getS3TieringSavings),\n/* harmony export */   getSnapshotMonthlyCost: () => (/* binding */ getSnapshotMonthlyCost),\n/* harmony export */   getUnattachedEIPMonthlyCost: () => (/* binding */ getUnattachedEIPMonthlyCost),\n/* harmony export */   getVolumeMonthlyCost: () => (/* binding */ getVolumeMonthlyCost)\n/* harmony export */ });\n/**\n * AWS Pricing Utilities\n *\n * Provides cost estimation for AWS resources based on resource types,\n * sizes, and regions. These are approximate values for cost estimation.\n */ // EC2 Instance pricing (on-demand, US East, per hour)\nconst EC2_HOURLY_RATES = {\n    \"t2.micro\": 0.0116,\n    \"t2.small\": 0.023,\n    \"t2.medium\": 0.0464,\n    \"t2.large\": 0.0928,\n    \"t2.xlarge\": 0.1856,\n    \"t3.micro\": 0.0104,\n    \"t3.small\": 0.0208,\n    \"t3.medium\": 0.0416,\n    \"t3.large\": 0.0832,\n    \"t3.xlarge\": 0.1664,\n    \"m5.large\": 0.096,\n    \"m5.xlarge\": 0.192,\n    \"m5.2xlarge\": 0.384,\n    \"m5.4xlarge\": 0.768,\n    \"m6i.large\": 0.096,\n    \"m6i.xlarge\": 0.192,\n    \"c5.large\": 0.085,\n    \"c5.xlarge\": 0.17,\n    \"c5.2xlarge\": 0.34,\n    \"r5.large\": 0.126,\n    \"r5.xlarge\": 0.252,\n    \"r5.2xlarge\": 0.504\n};\n// RDS Instance pricing (on-demand, US East, per hour)\nconst RDS_HOURLY_RATES = {\n    \"db.t3.micro\": 0.017,\n    \"db.t3.small\": 0.034,\n    \"db.t3.medium\": 0.068,\n    \"db.t3.large\": 0.136,\n    \"db.m5.large\": 0.171,\n    \"db.m5.xlarge\": 0.342,\n    \"db.m5.2xlarge\": 0.684,\n    \"db.r5.large\": 0.24,\n    \"db.r5.xlarge\": 0.48,\n    \"db.r5.2xlarge\": 0.96\n};\n// ElastiCache pricing (on-demand, US East, per hour)\nconst ELASTICACHE_HOURLY_RATES = {\n    \"cache.t3.micro\": 0.017,\n    \"cache.t3.small\": 0.034,\n    \"cache.t3.medium\": 0.068,\n    \"cache.m5.large\": 0.142,\n    \"cache.m5.xlarge\": 0.284,\n    \"cache.r5.large\": 0.198,\n    \"cache.r5.xlarge\": 0.396\n};\n// Load Balancer pricing (US East)\nconst ALB_HOURLY_RATE = 0.0225;\nconst ALB_LCU_RATE = 0.008 // per LCU-hour\n;\n// EBS Volume pricing (US East, per GB-month)\nconst EBS_GB_MONTH_RATES = {\n    gp2: 0.1,\n    gp3: 0.08,\n    io1: 0.125,\n    io2: 0.125,\n    st1: 0.045,\n    sc1: 0.025,\n    standard: 0.05\n};\n// EBS Snapshot pricing (per GB-month)\nconst SNAPSHOT_GB_MONTH_RATE = 0.05;\n// Elastic IP pricing (unattached, per hour)\nconst UNATTACHED_EIP_HOURLY_RATE = 0.005;\n// CloudWatch Logs pricing (per GB ingested)\nconst CLOUDWATCH_LOGS_GB_RATE = 0.5;\n// Lambda pricing\nconst LAMBDA_REQUEST_RATE = 0.0000002 // per request after free tier\n;\nconst LAMBDA_GB_SECOND_RATE = 0.0000166667 // per GB-second\n;\n// S3 pricing (per GB-month, Standard tier)\nconst S3_STANDARD_GB_MONTH = 0.023;\nconst S3_INTELLIGENT_TIERING_GB_MONTH = 0.0025 // for frequent access\n;\nconst S3_GLACIER_GB_MONTH = 0.004;\n// Hours in a month (average)\nconst HOURS_PER_MONTH = 730;\n// Instance type specs (vCPU, Memory GB)\nconst EC2_INSTANCE_SPECS = {\n    \"t2.micro\": {\n        vcpu: 1,\n        memoryGb: 1\n    },\n    \"t2.small\": {\n        vcpu: 1,\n        memoryGb: 2\n    },\n    \"t2.medium\": {\n        vcpu: 2,\n        memoryGb: 4\n    },\n    \"t2.large\": {\n        vcpu: 2,\n        memoryGb: 8\n    },\n    \"t2.xlarge\": {\n        vcpu: 4,\n        memoryGb: 16\n    },\n    \"t3.micro\": {\n        vcpu: 2,\n        memoryGb: 1\n    },\n    \"t3.small\": {\n        vcpu: 2,\n        memoryGb: 2\n    },\n    \"t3.medium\": {\n        vcpu: 2,\n        memoryGb: 4\n    },\n    \"t3.large\": {\n        vcpu: 2,\n        memoryGb: 8\n    },\n    \"t3.xlarge\": {\n        vcpu: 4,\n        memoryGb: 16\n    },\n    \"m5.large\": {\n        vcpu: 2,\n        memoryGb: 8\n    },\n    \"m5.xlarge\": {\n        vcpu: 4,\n        memoryGb: 16\n    },\n    \"m5.2xlarge\": {\n        vcpu: 8,\n        memoryGb: 32\n    },\n    \"m5.4xlarge\": {\n        vcpu: 16,\n        memoryGb: 64\n    },\n    \"m6i.large\": {\n        vcpu: 2,\n        memoryGb: 8\n    },\n    \"m6i.xlarge\": {\n        vcpu: 4,\n        memoryGb: 16\n    },\n    \"c5.large\": {\n        vcpu: 2,\n        memoryGb: 4\n    },\n    \"c5.xlarge\": {\n        vcpu: 4,\n        memoryGb: 8\n    },\n    \"c5.2xlarge\": {\n        vcpu: 8,\n        memoryGb: 16\n    },\n    \"r5.large\": {\n        vcpu: 2,\n        memoryGb: 16\n    },\n    \"r5.xlarge\": {\n        vcpu: 4,\n        memoryGb: 32\n    },\n    \"r5.2xlarge\": {\n        vcpu: 8,\n        memoryGb: 64\n    }\n};\n// Instance type downsize mapping (current -> recommended smaller)\nconst EC2_DOWNSIZE_MAP = {\n    // T2 family\n    \"t2.xlarge\": \"t2.large\",\n    \"t2.large\": \"t2.medium\",\n    \"t2.medium\": \"t2.small\",\n    \"t2.small\": \"t2.micro\",\n    // T3 family\n    \"t3.xlarge\": \"t3.large\",\n    \"t3.large\": \"t3.medium\",\n    \"t3.medium\": \"t3.small\",\n    \"t3.small\": \"t3.micro\",\n    // M5 family\n    \"m5.4xlarge\": \"m5.2xlarge\",\n    \"m5.2xlarge\": \"m5.xlarge\",\n    \"m5.xlarge\": \"m5.large\",\n    // M6i family\n    \"m6i.xlarge\": \"m6i.large\",\n    // C5 family\n    \"c5.2xlarge\": \"c5.xlarge\",\n    \"c5.xlarge\": \"c5.large\",\n    // R5 family\n    \"r5.2xlarge\": \"r5.xlarge\",\n    \"r5.xlarge\": \"r5.large\"\n};\n/**\n * Calculate monthly cost for an EC2 instance\n */ function getEC2MonthlyCost(instanceType) {\n    const hourlyRate = EC2_HOURLY_RATES[instanceType] || 0.1 // default fallback\n    ;\n    return hourlyRate * HOURS_PER_MONTH;\n}\n/**\n * Get the recommended smaller instance type for rightsizing\n * Returns null if no smaller size is available\n */ function getRecommendedSmallerInstance(instanceType) {\n    return EC2_DOWNSIZE_MAP[instanceType] || null;\n}\n/**\n * Get instance specs (vCPU, memory) for a given instance type\n */ function getEC2InstanceSpecs(instanceType) {\n    return EC2_INSTANCE_SPECS[instanceType] || null;\n}\n/**\n * Calculate monthly cost for an RDS instance\n */ function getRDSMonthlyCost(instanceClass) {\n    const hourlyRate = RDS_HOURLY_RATES[instanceClass] || 0.17 // default fallback\n    ;\n    return hourlyRate * HOURS_PER_MONTH;\n}\n/**\n * Calculate monthly cost for an ElastiCache cluster\n */ function getCacheMonthlyCost(nodeType, nodeCount = 1) {\n    const hourlyRate = ELASTICACHE_HOURLY_RATES[nodeType] || 0.068 // default fallback\n    ;\n    return hourlyRate * HOURS_PER_MONTH * nodeCount;\n}\n/**\n * Calculate monthly cost for a Load Balancer\n */ function getLoadBalancerMonthlyCost(avgLCUs = 1) {\n    const baseCost = ALB_HOURLY_RATE * HOURS_PER_MONTH;\n    const lcuCost = ALB_LCU_RATE * avgLCUs * HOURS_PER_MONTH;\n    return baseCost + lcuCost;\n}\n/**\n * Calculate monthly cost for an EBS volume\n */ function getVolumeMonthlyCost(volumeType, sizeGb) {\n    const gbMonthRate = EBS_GB_MONTH_RATES[volumeType] || 0.1 // default to gp2\n    ;\n    return gbMonthRate * sizeGb;\n}\n/**\n * Calculate monthly cost for an EBS snapshot\n */ function getSnapshotMonthlyCost(sizeGb) {\n    return SNAPSHOT_GB_MONTH_RATE * sizeGb;\n}\n/**\n * Calculate monthly cost for an unattached Elastic IP\n */ function getUnattachedEIPMonthlyCost() {\n    return UNATTACHED_EIP_HOURLY_RATE * HOURS_PER_MONTH;\n}\n/**\n * Calculate monthly cost for CloudWatch Logs (based on ingestion)\n */ function getLogGroupMonthlyCost(monthlyIngestGb) {\n    return CLOUDWATCH_LOGS_GB_RATE * monthlyIngestGb;\n}\n/**\n * Calculate monthly cost for Lambda function\n */ function getLambdaMonthlyCost(avgMemoryMb, avgDurationMs, monthlyInvocations) {\n    const gbSeconds = avgMemoryMb / 1024 * (avgDurationMs / 1000) * monthlyInvocations;\n    const requestCost = LAMBDA_REQUEST_RATE * monthlyInvocations;\n    const computeCost = LAMBDA_GB_SECOND_RATE * gbSeconds;\n    return requestCost + computeCost;\n}\n/**\n * Calculate monthly cost for S3 bucket (simplified)\n */ function getS3MonthlyCost(sizeGb, tier = \"standard\") {\n    switch(tier){\n        case \"intelligent\":\n            return S3_INTELLIGENT_TIERING_GB_MONTH * sizeGb;\n        case \"glacier\":\n            return S3_GLACIER_GB_MONTH * sizeGb;\n        default:\n            return S3_STANDARD_GB_MONTH * sizeGb;\n    }\n}\n/**\n * Calculate potential savings from tiering S3 data\n */ function getS3TieringSavings(sizeGb, currentTier = \"STANDARD\") {\n    if (currentTier !== \"STANDARD\") return 0;\n    const currentCost = S3_STANDARD_GB_MONTH * sizeGb;\n    const intelligentCost = S3_INTELLIGENT_TIERING_GB_MONTH * sizeGb;\n    return currentCost - intelligentCost;\n}\n/**\n * Format currency for display\n */ function formatCurrency(amount) {\n    return new Intl.NumberFormat(\"en-US\", {\n        style: \"currency\",\n        currency: \"USD\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(amount);\n}\n/**\n * Format currency with more precision for small amounts\n */ function formatCurrencyPrecise(amount) {\n    if (amount < 0.01) {\n        return new Intl.NumberFormat(\"en-US\", {\n            style: \"currency\",\n            currency: \"USD\",\n            minimumFractionDigits: 4,\n            maximumFractionDigits: 4\n        }).format(amount);\n    }\n    return formatCurrency(amount);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXNCc0I7UUFDL0I7WUFDRSxPQUFPeEIsdUJBQXVCd0I7SUFDbEM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU2Usb0JBQW9CZixNQUFjLEVBQUVnQixjQUFzQixVQUFVO0lBQ2xGLElBQUlBLGdCQUFnQixZQUFZLE9BQU87SUFDdkMsTUFBTUMsY0FBY3pDLHVCQUF1QndCO0lBQzNDLE1BQU1rQixrQkFBa0J6QyxrQ0FBa0N1QjtJQUMxRCxPQUFPaUIsY0FBY0M7QUFDdkI7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLGVBQWVDLE1BQWM7SUFDM0MsT0FBTyxJQUFJQyxLQUFLQyxZQUFZLENBQUMsU0FBUztRQUNwQ0MsT0FBTztRQUNQQyxVQUFVO1FBQ1ZDLHVCQUF1QjtRQUN2QkMsdUJBQXVCO0lBQ3pCLEdBQUdDLE1BQU0sQ0FBQ1A7QUFDWjtBQUVBOztDQUVDLEdBQ00sU0FBU1Esc0JBQXNCUixNQUFjO0lBQ2xELElBQUlBLFNBQVMsTUFBTTtRQUNqQixPQUFPLElBQUlDLEtBQUtDLFlBQVksQ0FBQyxTQUFTO1lBQ3BDQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsdUJBQXVCO1lBQ3ZCQyx1QkFBdUI7UUFDekIsR0FBR0MsTUFBTSxDQUFDUDtJQUNaO0lBQ0EsT0FBT0QsZUFBZUM7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZ2VudGljLWFpLXBsYXRmb3JtLy4vbGliL3V0aWxzL3ByaWNpbmcudHM/NDU5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFXUyBQcmljaW5nIFV0aWxpdGllc1xuICpcbiAqIFByb3ZpZGVzIGNvc3QgZXN0aW1hdGlvbiBmb3IgQVdTIHJlc291cmNlcyBiYXNlZCBvbiByZXNvdXJjZSB0eXBlcyxcbiAqIHNpemVzLCBhbmQgcmVnaW9ucy4gVGhlc2UgYXJlIGFwcHJveGltYXRlIHZhbHVlcyBmb3IgY29zdCBlc3RpbWF0aW9uLlxuICovXG5cbi8vIEVDMiBJbnN0YW5jZSBwcmljaW5nIChvbi1kZW1hbmQsIFVTIEVhc3QsIHBlciBob3VyKVxuZXhwb3J0IGNvbnN0IEVDMl9IT1VSTFlfUkFURVM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gIFwidDIubWljcm9cIjogMC4wMTE2LFxuICBcInQyLnNtYWxsXCI6IDAuMDIzLFxuICBcInQyLm1lZGl1bVwiOiAwLjA0NjQsXG4gIFwidDIubGFyZ2VcIjogMC4wOTI4LFxuICBcInQyLnhsYXJnZVwiOiAwLjE4NTYsXG4gIFwidDMubWljcm9cIjogMC4wMTA0LFxuICBcInQzLnNtYWxsXCI6IDAuMDIwOCxcbiAgXCJ0My5tZWRpdW1cIjogMC4wNDE2LFxuICBcInQzLmxhcmdlXCI6IDAuMDgzMixcbiAgXCJ0My54bGFyZ2VcIjogMC4xNjY0LFxuICBcIm01LmxhcmdlXCI6IDAuMDk2LFxuICBcIm01LnhsYXJnZVwiOiAwLjE5MixcbiAgXCJtNS4yeGxhcmdlXCI6IDAuMzg0LFxuICBcIm01LjR4bGFyZ2VcIjogMC43NjgsXG4gIFwibTZpLmxhcmdlXCI6IDAuMDk2LFxuICBcIm02aS54bGFyZ2VcIjogMC4xOTIsXG4gIFwiYzUubGFyZ2VcIjogMC4wODUsXG4gIFwiYzUueGxhcmdlXCI6IDAuMTcsXG4gIFwiYzUuMnhsYXJnZVwiOiAwLjM0LFxuICBcInI1LmxhcmdlXCI6IDAuMTI2LFxuICBcInI1LnhsYXJnZVwiOiAwLjI1MixcbiAgXCJyNS4yeGxhcmdlXCI6IDAuNTA0LFxufVxuXG4vLyBSRFMgSW5zdGFuY2UgcHJpY2luZyAob24tZGVtYW5kLCBVUyBFYXN0LCBwZXIgaG91cilcbmV4cG9ydCBjb25zdCBSRFNfSE9VUkxZX1JBVEVTOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICBcImRiLnQzLm1pY3JvXCI6IDAuMDE3LFxuICBcImRiLnQzLnNtYWxsXCI6IDAuMDM0LFxuICBcImRiLnQzLm1lZGl1bVwiOiAwLjA2OCxcbiAgXCJkYi50My5sYXJnZVwiOiAwLjEzNixcbiAgXCJkYi5tNS5sYXJnZVwiOiAwLjE3MSxcbiAgXCJkYi5tNS54bGFyZ2VcIjogMC4zNDIsXG4gIFwiZGIubTUuMnhsYXJnZVwiOiAwLjY4NCxcbiAgXCJkYi5yNS5sYXJnZVwiOiAwLjI0LFxuICBcImRiLnI1LnhsYXJnZVwiOiAwLjQ4LFxuICBcImRiLnI1LjJ4bGFyZ2VcIjogMC45Nixcbn1cblxuLy8gRWxhc3RpQ2FjaGUgcHJpY2luZyAob24tZGVtYW5kLCBVUyBFYXN0LCBwZXIgaG91cilcbmV4cG9ydCBjb25zdCBFTEFTVElDQUNIRV9IT1VSTFlfUkFURVM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gIFwiY2FjaGUudDMubWljcm9cIjogMC4wMTcsXG4gIFwiY2FjaGUudDMuc21hbGxcIjogMC4wMzQsXG4gIFwiY2FjaGUudDMubWVkaXVtXCI6IDAuMDY4LFxuICBcImNhY2hlLm01LmxhcmdlXCI6IDAuMTQyLFxuICBcImNhY2hlLm01LnhsYXJnZVwiOiAwLjI4NCxcbiAgXCJjYWNoZS5yNS5sYXJnZVwiOiAwLjE5OCxcbiAgXCJjYWNoZS5yNS54bGFyZ2VcIjogMC4zOTYsXG59XG5cbi8vIExvYWQgQmFsYW5jZXIgcHJpY2luZyAoVVMgRWFzdClcbmV4cG9ydCBjb25zdCBBTEJfSE9VUkxZX1JBVEUgPSAwLjAyMjVcbmV4cG9ydCBjb25zdCBBTEJfTENVX1JBVEUgPSAwLjAwOCAvLyBwZXIgTENVLWhvdXJcblxuLy8gRUJTIFZvbHVtZSBwcmljaW5nIChVUyBFYXN0LCBwZXIgR0ItbW9udGgpXG5leHBvcnQgY29uc3QgRUJTX0dCX01PTlRIX1JBVEVTOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICBncDI6IDAuMSxcbiAgZ3AzOiAwLjA4LFxuICBpbzE6IDAuMTI1LFxuICBpbzI6IDAuMTI1LFxuICBzdDE6IDAuMDQ1LFxuICBzYzE6IDAuMDI1LFxuICBzdGFuZGFyZDogMC4wNSxcbn1cblxuLy8gRUJTIFNuYXBzaG90IHByaWNpbmcgKHBlciBHQi1tb250aClcbmV4cG9ydCBjb25zdCBTTkFQU0hPVF9HQl9NT05USF9SQVRFID0gMC4wNVxuXG4vLyBFbGFzdGljIElQIHByaWNpbmcgKHVuYXR0YWNoZWQsIHBlciBob3VyKVxuZXhwb3J0IGNvbnN0IFVOQVRUQUNIRURfRUlQX0hPVVJMWV9SQVRFID0gMC4wMDVcblxuLy8gQ2xvdWRXYXRjaCBMb2dzIHByaWNpbmcgKHBlciBHQiBpbmdlc3RlZClcbmV4cG9ydCBjb25zdCBDTE9VRFdBVENIX0xPR1NfR0JfUkFURSA9IDAuNVxuXG4vLyBMYW1iZGEgcHJpY2luZ1xuZXhwb3J0IGNvbnN0IExBTUJEQV9SRVFVRVNUX1JBVEUgPSAwLjAwMDAwMDIgLy8gcGVyIHJlcXVlc3QgYWZ0ZXIgZnJlZSB0aWVyXG5leHBvcnQgY29uc3QgTEFNQkRBX0dCX1NFQ09ORF9SQVRFID0gMC4wMDAwMTY2NjY3IC8vIHBlciBHQi1zZWNvbmRcblxuLy8gUzMgcHJpY2luZyAocGVyIEdCLW1vbnRoLCBTdGFuZGFyZCB0aWVyKVxuZXhwb3J0IGNvbnN0IFMzX1NUQU5EQVJEX0dCX01PTlRIID0gMC4wMjNcbmV4cG9ydCBjb25zdCBTM19JTlRFTExJR0VOVF9USUVSSU5HX0dCX01PTlRIID0gMC4wMDI1IC8vIGZvciBmcmVxdWVudCBhY2Nlc3NcbmV4cG9ydCBjb25zdCBTM19HTEFDSUVSX0dCX01PTlRIID0gMC4wMDRcblxuLy8gSG91cnMgaW4gYSBtb250aCAoYXZlcmFnZSlcbmV4cG9ydCBjb25zdCBIT1VSU19QRVJfTU9OVEggPSA3MzBcblxuLy8gSW5zdGFuY2UgdHlwZSBzcGVjcyAodkNQVSwgTWVtb3J5IEdCKVxuZXhwb3J0IGNvbnN0IEVDMl9JTlNUQU5DRV9TUEVDUzogUmVjb3JkPHN0cmluZywgeyB2Y3B1OiBudW1iZXI7IG1lbW9yeUdiOiBudW1iZXIgfT4gPSB7XG4gIFwidDIubWljcm9cIjogeyB2Y3B1OiAxLCBtZW1vcnlHYjogMSB9LFxuICBcInQyLnNtYWxsXCI6IHsgdmNwdTogMSwgbWVtb3J5R2I6IDIgfSxcbiAgXCJ0Mi5tZWRpdW1cIjogeyB2Y3B1OiAyLCBtZW1vcnlHYjogNCB9LFxuICBcInQyLmxhcmdlXCI6IHsgdmNwdTogMiwgbWVtb3J5R2I6IDggfSxcbiAgXCJ0Mi54bGFyZ2VcIjogeyB2Y3B1OiA0LCBtZW1vcnlHYjogMTYgfSxcbiAgXCJ0My5taWNyb1wiOiB7IHZjcHU6IDIsIG1lbW9yeUdiOiAxIH0sXG4gIFwidDMuc21hbGxcIjogeyB2Y3B1OiAyLCBtZW1vcnlHYjogMiB9LFxuICBcInQzLm1lZGl1bVwiOiB7IHZjcHU6IDIsIG1lbW9yeUdiOiA0IH0sXG4gIFwidDMubGFyZ2VcIjogeyB2Y3B1OiAyLCBtZW1vcnlHYjogOCB9LFxuICBcInQzLnhsYXJnZVwiOiB7IHZjcHU6IDQsIG1lbW9yeUdiOiAxNiB9LFxuICBcIm01LmxhcmdlXCI6IHsgdmNwdTogMiwgbWVtb3J5R2I6IDggfSxcbiAgXCJtNS54bGFyZ2VcIjogeyB2Y3B1OiA0LCBtZW1vcnlHYjogMTYgfSxcbiAgXCJtNS4yeGxhcmdlXCI6IHsgdmNwdTogOCwgbWVtb3J5R2I6IDMyIH0sXG4gIFwibTUuNHhsYXJnZVwiOiB7IHZjcHU6IDE2LCBtZW1vcnlHYjogNjQgfSxcbiAgXCJtNmkubGFyZ2VcIjogeyB2Y3B1OiAyLCBtZW1vcnlHYjogOCB9LFxuICBcIm02aS54bGFyZ2VcIjogeyB2Y3B1OiA0LCBtZW1vcnlHYjogMTYgfSxcbiAgXCJjNS5sYXJnZVwiOiB7IHZjcHU6IDIsIG1lbW9yeUdiOiA0IH0sXG4gIFwiYzUueGxhcmdlXCI6IHsgdmNwdTogNCwgbWVtb3J5R2I6IDggfSxcbiAgXCJjNS4yeGxhcmdlXCI6IHsgdmNwdTogOCwgbWVtb3J5R2I6IDE2IH0sXG4gIFwicjUubGFyZ2VcIjogeyB2Y3B1OiAyLCBtZW1vcnlHYjogMTYgfSxcbiAgXCJyNS54bGFyZ2VcIjogeyB2Y3B1OiA0LCBtZW1vcnlHYjogMzIgfSxcbiAgXCJyNS4yeGxhcmdlXCI6IHsgdmNwdTogOCwgbWVtb3J5R2I6IDY0IH0sXG59XG5cbi8vIEluc3RhbmNlIHR5cGUgZG93bnNpemUgbWFwcGluZyAoY3VycmVudCAtPiByZWNvbW1lbmRlZCBzbWFsbGVyKVxuZXhwb3J0IGNvbnN0IEVDMl9ET1dOU0laRV9NQVA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIC8vIFQyIGZhbWlseVxuICBcInQyLnhsYXJnZVwiOiBcInQyLmxhcmdlXCIsXG4gIFwidDIubGFyZ2VcIjogXCJ0Mi5tZWRpdW1cIixcbiAgXCJ0Mi5tZWRpdW1cIjogXCJ0Mi5zbWFsbFwiLFxuICBcInQyLnNtYWxsXCI6IFwidDIubWljcm9cIixcbiAgLy8gVDMgZmFtaWx5XG4gIFwidDMueGxhcmdlXCI6IFwidDMubGFyZ2VcIixcbiAgXCJ0My5sYXJnZVwiOiBcInQzLm1lZGl1bVwiLFxuICBcInQzLm1lZGl1bVwiOiBcInQzLnNtYWxsXCIsXG4gIFwidDMuc21hbGxcIjogXCJ0My5taWNyb1wiLFxuICAvLyBNNSBmYW1pbHlcbiAgXCJtNS40eGxhcmdlXCI6IFwibTUuMnhsYXJnZVwiLFxuICBcIm01LjJ4bGFyZ2VcIjogXCJtNS54bGFyZ2VcIixcbiAgXCJtNS54bGFyZ2VcIjogXCJtNS5sYXJnZVwiLFxuICAvLyBNNmkgZmFtaWx5XG4gIFwibTZpLnhsYXJnZVwiOiBcIm02aS5sYXJnZVwiLFxuICAvLyBDNSBmYW1pbHlcbiAgXCJjNS4yeGxhcmdlXCI6IFwiYzUueGxhcmdlXCIsXG4gIFwiYzUueGxhcmdlXCI6IFwiYzUubGFyZ2VcIixcbiAgLy8gUjUgZmFtaWx5XG4gIFwicjUuMnhsYXJnZVwiOiBcInI1LnhsYXJnZVwiLFxuICBcInI1LnhsYXJnZVwiOiBcInI1LmxhcmdlXCIsXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1vbnRobHkgY29zdCBmb3IgYW4gRUMyIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFQzJNb250aGx5Q29zdChpbnN0YW5jZVR5cGU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGhvdXJseVJhdGUgPSBFQzJfSE9VUkxZX1JBVEVTW2luc3RhbmNlVHlwZV0gfHwgMC4xIC8vIGRlZmF1bHQgZmFsbGJhY2tcbiAgcmV0dXJuIGhvdXJseVJhdGUgKiBIT1VSU19QRVJfTU9OVEhcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJlY29tbWVuZGVkIHNtYWxsZXIgaW5zdGFuY2UgdHlwZSBmb3IgcmlnaHRzaXppbmdcbiAqIFJldHVybnMgbnVsbCBpZiBubyBzbWFsbGVyIHNpemUgaXMgYXZhaWxhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWNvbW1lbmRlZFNtYWxsZXJJbnN0YW5jZShpbnN0YW5jZVR5cGU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICByZXR1cm4gRUMyX0RPV05TSVpFX01BUFtpbnN0YW5jZVR5cGVdIHx8IG51bGxcbn1cblxuLyoqXG4gKiBHZXQgaW5zdGFuY2Ugc3BlY3MgKHZDUFUsIG1lbW9yeSkgZm9yIGEgZ2l2ZW4gaW5zdGFuY2UgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RUMySW5zdGFuY2VTcGVjcyhpbnN0YW5jZVR5cGU6IHN0cmluZyk6IHsgdmNwdTogbnVtYmVyOyBtZW1vcnlHYjogbnVtYmVyIH0gfCBudWxsIHtcbiAgcmV0dXJuIEVDMl9JTlNUQU5DRV9TUEVDU1tpbnN0YW5jZVR5cGVdIHx8IG51bGxcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbW9udGhseSBjb3N0IGZvciBhbiBSRFMgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJEU01vbnRobHlDb3N0KGluc3RhbmNlQ2xhc3M6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGhvdXJseVJhdGUgPSBSRFNfSE9VUkxZX1JBVEVTW2luc3RhbmNlQ2xhc3NdIHx8IDAuMTcgLy8gZGVmYXVsdCBmYWxsYmFja1xuICByZXR1cm4gaG91cmx5UmF0ZSAqIEhPVVJTX1BFUl9NT05USFxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtb250aGx5IGNvc3QgZm9yIGFuIEVsYXN0aUNhY2hlIGNsdXN0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlTW9udGhseUNvc3Qobm9kZVR5cGU6IHN0cmluZywgbm9kZUNvdW50OiBudW1iZXIgPSAxKTogbnVtYmVyIHtcbiAgY29uc3QgaG91cmx5UmF0ZSA9IEVMQVNUSUNBQ0hFX0hPVVJMWV9SQVRFU1tub2RlVHlwZV0gfHwgMC4wNjggLy8gZGVmYXVsdCBmYWxsYmFja1xuICByZXR1cm4gaG91cmx5UmF0ZSAqIEhPVVJTX1BFUl9NT05USCAqIG5vZGVDb3VudFxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtb250aGx5IGNvc3QgZm9yIGEgTG9hZCBCYWxhbmNlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9hZEJhbGFuY2VyTW9udGhseUNvc3QoYXZnTENVczogbnVtYmVyID0gMSk6IG51bWJlciB7XG4gIGNvbnN0IGJhc2VDb3N0ID0gQUxCX0hPVVJMWV9SQVRFICogSE9VUlNfUEVSX01PTlRIXG4gIGNvbnN0IGxjdUNvc3QgPSBBTEJfTENVX1JBVEUgKiBhdmdMQ1VzICogSE9VUlNfUEVSX01PTlRIXG4gIHJldHVybiBiYXNlQ29zdCArIGxjdUNvc3Rcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbW9udGhseSBjb3N0IGZvciBhbiBFQlMgdm9sdW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWb2x1bWVNb250aGx5Q29zdCh2b2x1bWVUeXBlOiBzdHJpbmcsIHNpemVHYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgZ2JNb250aFJhdGUgPSBFQlNfR0JfTU9OVEhfUkFURVNbdm9sdW1lVHlwZV0gfHwgMC4xIC8vIGRlZmF1bHQgdG8gZ3AyXG4gIHJldHVybiBnYk1vbnRoUmF0ZSAqIHNpemVHYlxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtb250aGx5IGNvc3QgZm9yIGFuIEVCUyBzbmFwc2hvdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U25hcHNob3RNb250aGx5Q29zdChzaXplR2I6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBTTkFQU0hPVF9HQl9NT05USF9SQVRFICogc2l6ZUdiXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1vbnRobHkgY29zdCBmb3IgYW4gdW5hdHRhY2hlZCBFbGFzdGljIElQXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmF0dGFjaGVkRUlQTW9udGhseUNvc3QoKTogbnVtYmVyIHtcbiAgcmV0dXJuIFVOQVRUQUNIRURfRUlQX0hPVVJMWV9SQVRFICogSE9VUlNfUEVSX01PTlRIXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1vbnRobHkgY29zdCBmb3IgQ2xvdWRXYXRjaCBMb2dzIChiYXNlZCBvbiBpbmdlc3Rpb24pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dHcm91cE1vbnRobHlDb3N0KG1vbnRobHlJbmdlc3RHYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIENMT1VEV0FUQ0hfTE9HU19HQl9SQVRFICogbW9udGhseUluZ2VzdEdiXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1vbnRobHkgY29zdCBmb3IgTGFtYmRhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW1iZGFNb250aGx5Q29zdChcbiAgYXZnTWVtb3J5TWI6IG51bWJlcixcbiAgYXZnRHVyYXRpb25NczogbnVtYmVyLFxuICBtb250aGx5SW52b2NhdGlvbnM6IG51bWJlclxuKTogbnVtYmVyIHtcbiAgY29uc3QgZ2JTZWNvbmRzID0gKGF2Z01lbW9yeU1iIC8gMTAyNCkgKiAoYXZnRHVyYXRpb25NcyAvIDEwMDApICogbW9udGhseUludm9jYXRpb25zXG4gIGNvbnN0IHJlcXVlc3RDb3N0ID0gTEFNQkRBX1JFUVVFU1RfUkFURSAqIG1vbnRobHlJbnZvY2F0aW9uc1xuICBjb25zdCBjb21wdXRlQ29zdCA9IExBTUJEQV9HQl9TRUNPTkRfUkFURSAqIGdiU2Vjb25kc1xuICByZXR1cm4gcmVxdWVzdENvc3QgKyBjb21wdXRlQ29zdFxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBtb250aGx5IGNvc3QgZm9yIFMzIGJ1Y2tldCAoc2ltcGxpZmllZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFMzTW9udGhseUNvc3Qoc2l6ZUdiOiBudW1iZXIsIHRpZXI6IFwic3RhbmRhcmRcIiB8IFwiaW50ZWxsaWdlbnRcIiB8IFwiZ2xhY2llclwiID0gXCJzdGFuZGFyZFwiKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0aWVyKSB7XG4gICAgY2FzZSBcImludGVsbGlnZW50XCI6XG4gICAgICByZXR1cm4gUzNfSU5URUxMSUdFTlRfVElFUklOR19HQl9NT05USCAqIHNpemVHYlxuICAgIGNhc2UgXCJnbGFjaWVyXCI6XG4gICAgICByZXR1cm4gUzNfR0xBQ0lFUl9HQl9NT05USCAqIHNpemVHYlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUzNfU1RBTkRBUkRfR0JfTU9OVEggKiBzaXplR2JcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwb3RlbnRpYWwgc2F2aW5ncyBmcm9tIHRpZXJpbmcgUzMgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UzNUaWVyaW5nU2F2aW5ncyhzaXplR2I6IG51bWJlciwgY3VycmVudFRpZXI6IHN0cmluZyA9IFwiU1RBTkRBUkRcIik6IG51bWJlciB7XG4gIGlmIChjdXJyZW50VGllciAhPT0gXCJTVEFOREFSRFwiKSByZXR1cm4gMFxuICBjb25zdCBjdXJyZW50Q29zdCA9IFMzX1NUQU5EQVJEX0dCX01PTlRIICogc2l6ZUdiXG4gIGNvbnN0IGludGVsbGlnZW50Q29zdCA9IFMzX0lOVEVMTElHRU5UX1RJRVJJTkdfR0JfTU9OVEggKiBzaXplR2JcbiAgcmV0dXJuIGN1cnJlbnRDb3N0IC0gaW50ZWxsaWdlbnRDb3N0XG59XG5cbi8qKlxuICogRm9ybWF0IGN1cnJlbmN5IGZvciBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeShhbW91bnQ6IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgc3R5bGU6IFwiY3VycmVuY3lcIixcbiAgICBjdXJyZW5jeTogXCJVU0RcIixcbiAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICB9KS5mb3JtYXQoYW1vdW50KVxufVxuXG4vKipcbiAqIEZvcm1hdCBjdXJyZW5jeSB3aXRoIG1vcmUgcHJlY2lzaW9uIGZvciBzbWFsbCBhbW91bnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeVByZWNpc2UoYW1vdW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYW1vdW50IDwgMC4wMSkge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgICBzdHlsZTogXCJjdXJyZW5jeVwiLFxuICAgICAgY3VycmVuY3k6IFwiVVNEXCIsXG4gICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDQsXG4gICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDQsXG4gICAgfSkuZm9ybWF0KGFtb3VudClcbiAgfVxuICByZXR1cm4gZm9ybWF0Q3VycmVuY3koYW1vdW50KVxufVxuIl0sIm5hbWVzIjpbIkVDMl9IT1VSTFlfUkFURVMiLCJSRFNfSE9VUkxZX1JBVEVTIiwiRUxBU1RJQ0FDSEVfSE9VUkxZX1JBVEVTIiwiQUxCX0hPVVJMWV9SQVRFIiwiQUxCX0xDVV9SQVRFIiwiRUJTX0dCX01PTlRIX1JBVEVTIiwiZ3AyIiwiZ3AzIiwiaW8xIiwiaW8yIiwic3QxIiwic2MxIiwic3RhbmRhcmQiLCJTTkFQU0hPVF9HQl9NT05USF9SQVRFIiwiVU5BVFRBQ0hFRF9FSVBfSE9VUkxZX1JBVEUiLCJDTE9VRFdBVENIX0xPR1NfR0JfUkFURSIsIkxBTUJEQV9SRVFVRVNUX1JBVEUiLCJMQU1CREFfR0JfU0VDT05EX1JBVEUiLCJTM19TVEFOREFSRF9HQl9NT05USCIsIlMzX0lOVEVMTElHRU5UX1RJRVJJTkdfR0JfTU9OVEgiLCJTM19HTEFDSUVSX0dCX01PTlRIIiwiSE9VUlNfUEVSX01PTlRIIiwiRUMyX0lOU1RBTkNFX1NQRUNTIiwidmNwdSIsIm1lbW9yeUdiIiwiRUMyX0RPV05TSVpFX01BUCIsImdldEVDMk1vbnRobHlDb3N0IiwiaW5zdGFuY2VUeXBlIiwiaG91cmx5UmF0ZSIsImdldFJlY29tbWVuZGVkU21hbGxlckluc3RhbmNlIiwiZ2V0RUMySW5zdGFuY2VTcGVjcyIsImdldFJEU01vbnRobHlDb3N0IiwiaW5zdGFuY2VDbGFzcyIsImdldENhY2hlTW9udGhseUNvc3QiLCJub2RlVHlwZSIsIm5vZGVDb3VudCIsImdldExvYWRCYWxhbmNlck1vbnRobHlDb3N0IiwiYXZnTENVcyIsImJhc2VDb3N0IiwibGN1Q29zdCIsImdldFZvbHVtZU1vbnRobHlDb3N0Iiwidm9sdW1lVHlwZSIsInNpemVHYiIsImdiTW9udGhSYXRlIiwiZ2V0U25hcHNob3RNb250aGx5Q29zdCIsImdldFVuYXR0YWNoZWRFSVBNb250aGx5Q29zdCIsImdldExvZ0dyb3VwTW9udGhseUNvc3QiLCJtb250aGx5SW5nZXN0R2IiLCJnZXRMYW1iZGFNb250aGx5Q29zdCIsImF2Z01lbW9yeU1iIiwiYXZnRHVyYXRpb25NcyIsIm1vbnRobHlJbnZvY2F0aW9ucyIsImdiU2Vjb25kcyIsInJlcXVlc3RDb3N0IiwiY29tcHV0ZUNvc3QiLCJnZXRTM01vbnRobHlDb3N0IiwidGllciIsImdldFMzVGllcmluZ1NhdmluZ3MiLCJjdXJyZW50VGllciIsImN1cnJlbnRDb3N0IiwiaW50ZWxsaWdlbnRDb3N0IiwiZm9ybWF0Q3VycmVuY3kiLCJhbW91bnQiLCJJbnRsIiwiTnVtYmVyRm9ybWF0Iiwic3R5bGUiLCJjdXJyZW5jeSIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImZvcm1hdCIsImZvcm1hdEN1cnJlbmN5UHJlY2lzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/utils/pricing.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tslib","vendor-chunks/iceberg-js"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fdrift-tick%2Froute&page=%2Fapi%2Fdrift-tick%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fdrift-tick%2Froute.ts&appDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fsarjanpatel%2FGithub%20Repositories%2Faws-environment%2Fagentic-ai-platform&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();